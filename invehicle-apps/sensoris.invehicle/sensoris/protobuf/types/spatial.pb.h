// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/types/spatial.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include <google/protobuf/wrappers.pb.h>
#include "sensoris/protobuf/types/base.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto 

namespace protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {
class MapLocationReference;
class MapLocationReferenceDefaultTypeInternal;
extern MapLocationReferenceDefaultTypeInternal _MapLocationReference_default_instance_;
class MapLocationReference_TileIdLinkIdOffset;
class MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal;
extern MapLocationReference_TileIdLinkIdOffsetDefaultTypeInternal _MapLocationReference_TileIdLinkIdOffset_default_instance_;
class MapLocationReference_TileIdObjectId;
class MapLocationReference_TileIdObjectIdDefaultTypeInternal;
extern MapLocationReference_TileIdObjectIdDefaultTypeInternal _MapLocationReference_TileIdObjectId_default_instance_;
class PolylineAndAccuracy;
class PolylineAndAccuracyDefaultTypeInternal;
extern PolylineAndAccuracyDefaultTypeInternal _PolylineAndAccuracy_default_instance_;
class PositionAndAccuracy;
class PositionAndAccuracyDefaultTypeInternal;
extern PositionAndAccuracyDefaultTypeInternal _PositionAndAccuracy_default_instance_;
class PositionAndAccuracy_Geographic;
class PositionAndAccuracy_GeographicDefaultTypeInternal;
extern PositionAndAccuracy_GeographicDefaultTypeInternal _PositionAndAccuracy_Geographic_default_instance_;
class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev;
class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_;
class PositionAndAccuracy_HorizontalVerticalStdDev;
class PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal;
extern PositionAndAccuracy_HorizontalVerticalStdDevDefaultTypeInternal _PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_;
class PositionAndAccuracy_Metric;
class PositionAndAccuracy_MetricDefaultTypeInternal;
extern PositionAndAccuracy_MetricDefaultTypeInternal _PositionAndAccuracy_Metric_default_instance_;
class RectangularBoxAndAccuracy;
class RectangularBoxAndAccuracyDefaultTypeInternal;
extern RectangularBoxAndAccuracyDefaultTypeInternal _RectangularBoxAndAccuracy_default_instance_;
class RectangularBoxAndAccuracy_CenterOrientationSize;
class RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CenterOrientationSizeDefaultTypeInternal _RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_;
class RectangularBoxAndAccuracy_CornerVectors;
class RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal;
extern RectangularBoxAndAccuracy_CornerVectorsDefaultTypeInternal _RectangularBoxAndAccuracy_CornerVectors_default_instance_;
class RotationAndAccuracy;
class RotationAndAccuracyDefaultTypeInternal;
extern RotationAndAccuracyDefaultTypeInternal _RotationAndAccuracy_default_instance_;
class RotationAndAccuracy_Euler;
class RotationAndAccuracy_EulerDefaultTypeInternal;
extern RotationAndAccuracy_EulerDefaultTypeInternal _RotationAndAccuracy_Euler_default_instance_;
class RotationAndAccuracy_Quaternion;
class RotationAndAccuracy_QuaternionDefaultTypeInternal;
extern RotationAndAccuracy_QuaternionDefaultTypeInternal _RotationAndAccuracy_Quaternion_default_instance_;
class RotationAndAccuracy_StdDev;
class RotationAndAccuracy_StdDevDefaultTypeInternal;
extern RotationAndAccuracy_StdDevDefaultTypeInternal _RotationAndAccuracy_StdDev_default_instance_;
class RotationRateAndAccuracy;
class RotationRateAndAccuracyDefaultTypeInternal;
extern RotationRateAndAccuracyDefaultTypeInternal _RotationRateAndAccuracy_default_instance_;
class RotationRateAndAccuracy_StdDev;
class RotationRateAndAccuracy_StdDevDefaultTypeInternal;
extern RotationRateAndAccuracy_StdDevDefaultTypeInternal _RotationRateAndAccuracy_StdDev_default_instance_;
class XyzVectorAndAccuracy;
class XyzVectorAndAccuracyDefaultTypeInternal;
extern XyzVectorAndAccuracyDefaultTypeInternal _XyzVectorAndAccuracy_default_instance_;
class XyzVectorAndAccuracy_Metric;
class XyzVectorAndAccuracy_MetricDefaultTypeInternal;
extern XyzVectorAndAccuracy_MetricDefaultTypeInternal _XyzVectorAndAccuracy_Metric_default_instance_;
class XyzVectorAndAccuracy_StdDev;
class XyzVectorAndAccuracy_StdDevDefaultTypeInternal;
extern XyzVectorAndAccuracy_StdDevDefaultTypeInternal _XyzVectorAndAccuracy_StdDev_default_instance_;
}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::types::spatial::MapLocationReference* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference>(Arena*);
template<> ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset>(Arena*);
template<> ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PolylineAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PositionAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev>(Arena*);
template<> ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev>(Arena*);
template<> ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(Arena*);
template<> ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric>(Arena*);
template<> ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* Arena::CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace types {
namespace spatial {

// ===================================================================

class PositionAndAccuracy_Geographic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic) */ {
 public:
  PositionAndAccuracy_Geographic();
  virtual ~PositionAndAccuracy_Geographic();

  PositionAndAccuracy_Geographic(const PositionAndAccuracy_Geographic& from);

  inline PositionAndAccuracy_Geographic& operator=(const PositionAndAccuracy_Geographic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionAndAccuracy_Geographic(PositionAndAccuracy_Geographic&& from) noexcept
    : PositionAndAccuracy_Geographic() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_Geographic& operator=(PositionAndAccuracy_Geographic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionAndAccuracy_Geographic& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionAndAccuracy_Geographic* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_Geographic*>(
               &_PositionAndAccuracy_Geographic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(PositionAndAccuracy_Geographic* other);
  void Swap(PositionAndAccuracy_Geographic* other);
  friend void swap(PositionAndAccuracy_Geographic& a, PositionAndAccuracy_Geographic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionAndAccuracy_Geographic* New() const final {
    return CreateMaybeMessage<PositionAndAccuracy_Geographic>(NULL);
  }

  PositionAndAccuracy_Geographic* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionAndAccuracy_Geographic>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionAndAccuracy_Geographic& from);
  void MergeFrom(const PositionAndAccuracy_Geographic& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAndAccuracy_Geographic* other);
  protected:
  explicit PositionAndAccuracy_Geographic(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_longitude() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& longitude() const;
  ::sensoris::protobuf::types::base::Int64Value* release_longitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_longitude();
  void set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* longitude);
  void unsafe_arena_set_allocated_longitude(
      ::sensoris::protobuf::types::base::Int64Value* longitude);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_longitude();

  // .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_latitude() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& latitude() const;
  ::sensoris::protobuf::types::base::Int64Value* release_latitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_latitude();
  void set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* latitude);
  void unsafe_arena_set_allocated_latitude(
      ::sensoris::protobuf::types::base::Int64Value* latitude);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_latitude();

  // .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_altitude() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& altitude() const;
  ::sensoris::protobuf::types::base::Int64Value* release_altitude();
  ::sensoris::protobuf::types::base::Int64Value* mutable_altitude();
  void set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* altitude);
  void unsafe_arena_set_allocated_altitude(
      ::sensoris::protobuf::types::base::Int64Value* altitude);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_altitude();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* longitude_;
  ::sensoris::protobuf::types::base::Int64Value* latitude_;
  ::sensoris::protobuf::types::base::Int64Value* altitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionAndAccuracy_Metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric) */ {
 public:
  PositionAndAccuracy_Metric();
  virtual ~PositionAndAccuracy_Metric();

  PositionAndAccuracy_Metric(const PositionAndAccuracy_Metric& from);

  inline PositionAndAccuracy_Metric& operator=(const PositionAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionAndAccuracy_Metric(PositionAndAccuracy_Metric&& from) noexcept
    : PositionAndAccuracy_Metric() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_Metric& operator=(PositionAndAccuracy_Metric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionAndAccuracy_Metric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionAndAccuracy_Metric* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_Metric*>(
               &_PositionAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(PositionAndAccuracy_Metric* other);
  void Swap(PositionAndAccuracy_Metric* other);
  friend void swap(PositionAndAccuracy_Metric& a, PositionAndAccuracy_Metric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionAndAccuracy_Metric* New() const final {
    return CreateMaybeMessage<PositionAndAccuracy_Metric>(NULL);
  }

  PositionAndAccuracy_Metric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionAndAccuracy_Metric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionAndAccuracy_Metric& from);
  void MergeFrom(const PositionAndAccuracy_Metric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAndAccuracy_Metric* other);
  protected:
  explicit PositionAndAccuracy_Metric(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x);
  void unsafe_arena_set_allocated_x(
      ::sensoris::protobuf::types::base::Int64Value* x);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y);
  void unsafe_arena_set_allocated_y(
      ::sensoris::protobuf::types::base::Int64Value* y);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z);
  void unsafe_arena_set_allocated_z(
      ::sensoris::protobuf::types::base::Int64Value* z);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* x_;
  ::sensoris::protobuf::types::base::Int64Value* y_;
  ::sensoris::protobuf::types::base::Int64Value* z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalVerticalStdDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev) */ {
 public:
  PositionAndAccuracy_HorizontalVerticalStdDev();
  virtual ~PositionAndAccuracy_HorizontalVerticalStdDev();

  PositionAndAccuracy_HorizontalVerticalStdDev(const PositionAndAccuracy_HorizontalVerticalStdDev& from);

  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionAndAccuracy_HorizontalVerticalStdDev(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept
    : PositionAndAccuracy_HorizontalVerticalStdDev() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_HorizontalVerticalStdDev& operator=(PositionAndAccuracy_HorizontalVerticalStdDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionAndAccuracy_HorizontalVerticalStdDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionAndAccuracy_HorizontalVerticalStdDev* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_HorizontalVerticalStdDev*>(
               &_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalVerticalStdDev* other);
  void Swap(PositionAndAccuracy_HorizontalVerticalStdDev* other);
  friend void swap(PositionAndAccuracy_HorizontalVerticalStdDev& a, PositionAndAccuracy_HorizontalVerticalStdDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionAndAccuracy_HorizontalVerticalStdDev* New() const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalVerticalStdDev>(NULL);
  }

  PositionAndAccuracy_HorizontalVerticalStdDev* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalVerticalStdDev>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  void MergeFrom(const PositionAndAccuracy_HorizontalVerticalStdDev& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAndAccuracy_HorizontalVerticalStdDev* other);
  protected:
  explicit PositionAndAccuracy_HorizontalVerticalStdDev(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal() const;
  void clear_horizontal();
  static const int kHorizontalFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_horizontal() const;
  public:
  const ::google::protobuf::Int64Value& horizontal() const;
  ::google::protobuf::Int64Value* release_horizontal();
  ::google::protobuf::Int64Value* mutable_horizontal();
  void set_allocated_horizontal(::google::protobuf::Int64Value* horizontal);
  void unsafe_arena_set_allocated_horizontal(
      ::google::protobuf::Int64Value* horizontal);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal();

  // .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical();
  static const int kVerticalFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  public:
  const ::google::protobuf::Int64Value& vertical() const;
  ::google::protobuf::Int64Value* release_vertical();
  ::google::protobuf::Int64Value* mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* vertical);
  void unsafe_arena_set_allocated_vertical(
      ::google::protobuf::Int64Value* vertical);
  ::google::protobuf::Int64Value* unsafe_arena_release_vertical();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int64Value* horizontal_;
  ::google::protobuf::Int64Value* vertical_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev) */ {
 public:
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev();
  virtual ~PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev();

  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept
    : PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& operator=(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(
               &_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other);
  void Swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other);
  friend void swap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& a, PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* New() const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(NULL);
  }

  PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  void MergeFrom(const PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* other);
  protected:
  explicit PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_major() const;
  void clear_horizontal_ellipse_major();
  static const int kHorizontalEllipseMajorFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major() const;
  public:
  const ::google::protobuf::Int64Value& horizontal_ellipse_major() const;
  ::google::protobuf::Int64Value* release_horizontal_ellipse_major();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_major();
  void set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* horizontal_ellipse_major);
  void unsafe_arena_set_allocated_horizontal_ellipse_major(
      ::google::protobuf::Int64Value* horizontal_ellipse_major);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_major();

  // .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_horizontal_ellipse_minor() const;
  void clear_horizontal_ellipse_minor();
  static const int kHorizontalEllipseMinorFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_minor() const;
  public:
  const ::google::protobuf::Int64Value& horizontal_ellipse_minor() const;
  ::google::protobuf::Int64Value* release_horizontal_ellipse_minor();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_minor();
  void set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* horizontal_ellipse_minor);
  void unsafe_arena_set_allocated_horizontal_ellipse_minor(
      ::google::protobuf::Int64Value* horizontal_ellipse_minor);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_minor();

  // .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_horizontal_ellipse_major_heading() const;
  void clear_horizontal_ellipse_major_heading();
  static const int kHorizontalEllipseMajorHeadingFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_horizontal_ellipse_major_heading() const;
  public:
  const ::google::protobuf::Int64Value& horizontal_ellipse_major_heading() const;
  ::google::protobuf::Int64Value* release_horizontal_ellipse_major_heading();
  ::google::protobuf::Int64Value* mutable_horizontal_ellipse_major_heading();
  void set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* horizontal_ellipse_major_heading);
  void unsafe_arena_set_allocated_horizontal_ellipse_major_heading(
      ::google::protobuf::Int64Value* horizontal_ellipse_major_heading);
  ::google::protobuf::Int64Value* unsafe_arena_release_horizontal_ellipse_major_heading();

  // .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_vertical() const;
  void clear_vertical();
  static const int kVerticalFieldNumber = 4;
  private:
  const ::google::protobuf::Int64Value& _internal_vertical() const;
  public:
  const ::google::protobuf::Int64Value& vertical() const;
  ::google::protobuf::Int64Value* release_vertical();
  ::google::protobuf::Int64Value* mutable_vertical();
  void set_allocated_vertical(::google::protobuf::Int64Value* vertical);
  void unsafe_arena_set_allocated_vertical(
      ::google::protobuf::Int64Value* vertical);
  ::google::protobuf::Int64Value* unsafe_arena_release_vertical();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int64Value* horizontal_ellipse_major_;
  ::google::protobuf::Int64Value* horizontal_ellipse_minor_;
  ::google::protobuf::Int64Value* horizontal_ellipse_major_heading_;
  ::google::protobuf::Int64Value* vertical_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PositionAndAccuracy) */ {
 public:
  PositionAndAccuracy();
  virtual ~PositionAndAccuracy();

  PositionAndAccuracy(const PositionAndAccuracy& from);

  inline PositionAndAccuracy& operator=(const PositionAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionAndAccuracy(PositionAndAccuracy&& from) noexcept
    : PositionAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PositionAndAccuracy& operator=(PositionAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionAndAccuracy& default_instance();

  enum GeographicMetricCase {
    kGeographicWgs84 = 1,
    kMetricVehicle = 2,
    kMetricEventGroup = 3,
    kMetricEcef = 4,
    GEOGRAPHIC_METRIC_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kHorizontalConfidenceEllipseVerticalStdDev = 7,
    kCovariance = 8,
    ACCURACY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PositionAndAccuracy*>(
               &_PositionAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(PositionAndAccuracy* other);
  void Swap(PositionAndAccuracy* other);
  friend void swap(PositionAndAccuracy& a, PositionAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionAndAccuracy* New() const final {
    return CreateMaybeMessage<PositionAndAccuracy>(NULL);
  }

  PositionAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionAndAccuracy& from);
  void MergeFrom(const PositionAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionAndAccuracy* other);
  protected:
  explicit PositionAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PositionAndAccuracy_Geographic Geographic;
  typedef PositionAndAccuracy_Metric Metric;
  typedef PositionAndAccuracy_HorizontalVerticalStdDev HorizontalVerticalStdDev;
  typedef PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev HorizontalConfidenceEllipseVerticalStdDev;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
  bool has_geographic_wgs84() const;
  void clear_geographic_wgs84();
  static const int kGeographicWgs84FieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& _internal_geographic_wgs84() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& geographic_wgs84() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* release_geographic_wgs84();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* mutable_geographic_wgs84();
  void set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84);
  void unsafe_arena_set_allocated_geographic_wgs84(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* unsafe_arena_release_geographic_wgs84();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
  bool has_metric_vehicle() const;
  void clear_metric_vehicle();
  static const int kMetricVehicleFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_vehicle() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle);
  void unsafe_arena_set_allocated_metric_vehicle(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_vehicle();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
  bool has_metric_event_group() const;
  void clear_metric_event_group();
  static const int kMetricEventGroupFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_event_group() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_event_group() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_event_group();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group);
  void unsafe_arena_set_allocated_metric_event_group(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_event_group();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
  bool has_metric_ecef() const;
  void clear_metric_ecef();
  static const int kMetricEcefFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& _internal_metric_ecef() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& metric_ecef() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* release_metric_ecef();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* mutable_metric_ecef();
  void set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef);
  void unsafe_arena_set_allocated_metric_ecef(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* unsafe_arena_release_metric_ecef();

  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_combined_std_dev() const;
  void clear_combined_std_dev();
  static const int kCombinedStdDevFieldNumber = 5;
  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  public:
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev);
  void unsafe_arena_set_allocated_combined_std_dev(
      ::google::protobuf::Int64Value* combined_std_dev);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
  bool has_std_dev() const;
  void clear_std_dev();
  static const int kStdDevFieldNumber = 6;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& _internal_std_dev() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev);
  void unsafe_arena_set_allocated_std_dev(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* unsafe_arena_release_std_dev();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
  bool has_horizontal_confidence_ellipse_vertical_std_dev() const;
  void clear_horizontal_confidence_ellipse_vertical_std_dev();
  static const int kHorizontalConfidenceEllipseVerticalStdDevFieldNumber = 7;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& _internal_horizontal_confidence_ellipse_vertical_std_dev() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& horizontal_confidence_ellipse_vertical_std_dev() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* release_horizontal_confidence_ellipse_vertical_std_dev();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* mutable_horizontal_confidence_ellipse_vertical_std_dev();
  void set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev);
  void unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev();

  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_covariance() const;
  void clear_covariance();
  static const int kCovarianceFieldNumber = 8;
  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  void unsafe_arena_set_allocated_covariance(
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  void clear_geographic_metric();
  GeographicMetricCase geographic_metric_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PositionAndAccuracy)
 private:
  void set_has_geographic_wgs84();
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_ecef();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_horizontal_confidence_ellipse_vertical_std_dev();
  void set_has_covariance();

  inline bool has_geographic_metric() const;
  inline void clear_has_geographic_metric();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  union GeographicMetricUnion {
    GeographicMetricUnion() {}
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef_;
  } geographic_metric_;
  union AccuracyUnion {
    AccuracyUnion() {}
    ::google::protobuf::Int64Value* combined_std_dev_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev_;
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev_;
    ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
  } accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PolylineAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.PolylineAndAccuracy) */ {
 public:
  PolylineAndAccuracy();
  virtual ~PolylineAndAccuracy();

  PolylineAndAccuracy(const PolylineAndAccuracy& from);

  inline PolylineAndAccuracy& operator=(const PolylineAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PolylineAndAccuracy(PolylineAndAccuracy&& from) noexcept
    : PolylineAndAccuracy() {
    *this = ::std::move(from);
  }

  inline PolylineAndAccuracy& operator=(PolylineAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PolylineAndAccuracy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PolylineAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const PolylineAndAccuracy*>(
               &_PolylineAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(PolylineAndAccuracy* other);
  void Swap(PolylineAndAccuracy* other);
  friend void swap(PolylineAndAccuracy& a, PolylineAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PolylineAndAccuracy* New() const final {
    return CreateMaybeMessage<PolylineAndAccuracy>(NULL);
  }

  PolylineAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PolylineAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PolylineAndAccuracy& from);
  void MergeFrom(const PolylineAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PolylineAndAccuracy* other);
  protected:
  explicit PolylineAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  int position_and_accuracy_size() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 1;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >*
      mutable_position_and_accuracy();
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy(int index) const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* add_position_and_accuracy();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >&
      position_and_accuracy() const;

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.PolylineAndAccuracy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy > position_and_accuracy_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XyzVectorAndAccuracy_StdDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev) */ {
 public:
  XyzVectorAndAccuracy_StdDev();
  virtual ~XyzVectorAndAccuracy_StdDev();

  XyzVectorAndAccuracy_StdDev(const XyzVectorAndAccuracy_StdDev& from);

  inline XyzVectorAndAccuracy_StdDev& operator=(const XyzVectorAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XyzVectorAndAccuracy_StdDev(XyzVectorAndAccuracy_StdDev&& from) noexcept
    : XyzVectorAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy_StdDev& operator=(XyzVectorAndAccuracy_StdDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const XyzVectorAndAccuracy_StdDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XyzVectorAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy_StdDev*>(
               &_XyzVectorAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(XyzVectorAndAccuracy_StdDev* other);
  void Swap(XyzVectorAndAccuracy_StdDev* other);
  friend void swap(XyzVectorAndAccuracy_StdDev& a, XyzVectorAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XyzVectorAndAccuracy_StdDev* New() const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_StdDev>(NULL);
  }

  XyzVectorAndAccuracy_StdDev* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_StdDev>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XyzVectorAndAccuracy_StdDev& from);
  void MergeFrom(const XyzVectorAndAccuracy_StdDev& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XyzVectorAndAccuracy_StdDev* other);
  protected:
  explicit XyzVectorAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_x() const;
  public:
  const ::google::protobuf::Int64Value& x() const;
  ::google::protobuf::Int64Value* release_x();
  ::google::protobuf::Int64Value* mutable_x();
  void set_allocated_x(::google::protobuf::Int64Value* x);
  void unsafe_arena_set_allocated_x(
      ::google::protobuf::Int64Value* x);
  ::google::protobuf::Int64Value* unsafe_arena_release_x();

  // .google.protobuf.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_y() const;
  public:
  const ::google::protobuf::Int64Value& y() const;
  ::google::protobuf::Int64Value* release_y();
  ::google::protobuf::Int64Value* mutable_y();
  void set_allocated_y(::google::protobuf::Int64Value* y);
  void unsafe_arena_set_allocated_y(
      ::google::protobuf::Int64Value* y);
  ::google::protobuf::Int64Value* unsafe_arena_release_y();

  // .google.protobuf.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_z() const;
  public:
  const ::google::protobuf::Int64Value& z() const;
  ::google::protobuf::Int64Value* release_z();
  ::google::protobuf::Int64Value* mutable_z();
  void set_allocated_z(::google::protobuf::Int64Value* z);
  void unsafe_arena_set_allocated_z(
      ::google::protobuf::Int64Value* z);
  ::google::protobuf::Int64Value* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int64Value* x_;
  ::google::protobuf::Int64Value* y_;
  ::google::protobuf::Int64Value* z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XyzVectorAndAccuracy_Metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric) */ {
 public:
  XyzVectorAndAccuracy_Metric();
  virtual ~XyzVectorAndAccuracy_Metric();

  XyzVectorAndAccuracy_Metric(const XyzVectorAndAccuracy_Metric& from);

  inline XyzVectorAndAccuracy_Metric& operator=(const XyzVectorAndAccuracy_Metric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XyzVectorAndAccuracy_Metric(XyzVectorAndAccuracy_Metric&& from) noexcept
    : XyzVectorAndAccuracy_Metric() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy_Metric& operator=(XyzVectorAndAccuracy_Metric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const XyzVectorAndAccuracy_Metric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XyzVectorAndAccuracy_Metric* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy_Metric*>(
               &_XyzVectorAndAccuracy_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(XyzVectorAndAccuracy_Metric* other);
  void Swap(XyzVectorAndAccuracy_Metric* other);
  friend void swap(XyzVectorAndAccuracy_Metric& a, XyzVectorAndAccuracy_Metric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XyzVectorAndAccuracy_Metric* New() const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_Metric>(NULL);
  }

  XyzVectorAndAccuracy_Metric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy_Metric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XyzVectorAndAccuracy_Metric& from);
  void MergeFrom(const XyzVectorAndAccuracy_Metric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XyzVectorAndAccuracy_Metric* other);
  protected:
  explicit XyzVectorAndAccuracy_Metric(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x);
  void unsafe_arena_set_allocated_x(
      ::sensoris::protobuf::types::base::Int64Value* x);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y);
  void unsafe_arena_set_allocated_y(
      ::sensoris::protobuf::types::base::Int64Value* y);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z);
  void unsafe_arena_set_allocated_z(
      ::sensoris::protobuf::types::base::Int64Value* z);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* x_;
  ::sensoris::protobuf::types::base::Int64Value* y_;
  ::sensoris::protobuf::types::base::Int64Value* z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XyzVectorAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy) */ {
 public:
  XyzVectorAndAccuracy();
  virtual ~XyzVectorAndAccuracy();

  XyzVectorAndAccuracy(const XyzVectorAndAccuracy& from);

  inline XyzVectorAndAccuracy& operator=(const XyzVectorAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XyzVectorAndAccuracy(XyzVectorAndAccuracy&& from) noexcept
    : XyzVectorAndAccuracy() {
    *this = ::std::move(from);
  }

  inline XyzVectorAndAccuracy& operator=(XyzVectorAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const XyzVectorAndAccuracy& default_instance();

  enum GeometryCase {
    kMetricVehicle = 1,
    kMetricEventGroup = 2,
    kMetricOrigin = 3,
    GEOMETRY_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XyzVectorAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const XyzVectorAndAccuracy*>(
               &_XyzVectorAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(XyzVectorAndAccuracy* other);
  void Swap(XyzVectorAndAccuracy* other);
  friend void swap(XyzVectorAndAccuracy& a, XyzVectorAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XyzVectorAndAccuracy* New() const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy>(NULL);
  }

  XyzVectorAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XyzVectorAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XyzVectorAndAccuracy& from);
  void MergeFrom(const XyzVectorAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XyzVectorAndAccuracy* other);
  protected:
  explicit XyzVectorAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef XyzVectorAndAccuracy_StdDev StdDev;
  typedef XyzVectorAndAccuracy_Metric Metric;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
  bool has_metric_vehicle() const;
  void clear_metric_vehicle();
  static const int kMetricVehicleFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_vehicle() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_vehicle() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_vehicle();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_vehicle();
  void set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle);
  void unsafe_arena_set_allocated_metric_vehicle(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_vehicle();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
  bool has_metric_event_group() const;
  void clear_metric_event_group();
  static const int kMetricEventGroupFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_event_group() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_event_group() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_event_group();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_event_group();
  void set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group);
  void unsafe_arena_set_allocated_metric_event_group(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_event_group();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
  bool has_metric_origin() const;
  void clear_metric_origin();
  static const int kMetricOriginFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& _internal_metric_origin() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& metric_origin() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* release_metric_origin();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* mutable_metric_origin();
  void set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin);
  void unsafe_arena_set_allocated_metric_origin(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* unsafe_arena_release_metric_origin();

  // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_combined_std_dev() const;
  void clear_combined_std_dev();
  static const int kCombinedStdDevFieldNumber = 4;
  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  public:
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev);
  void unsafe_arena_set_allocated_combined_std_dev(
      ::google::protobuf::Int64Value* combined_std_dev);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  void clear_std_dev();
  static const int kStdDevFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& _internal_std_dev() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& std_dev() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev);
  void unsafe_arena_set_allocated_std_dev(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_covariance() const;
  void clear_covariance();
  static const int kCovarianceFieldNumber = 6;
  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  void unsafe_arena_set_allocated_covariance(
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy)
 private:
  void set_has_metric_vehicle();
  void set_has_metric_event_group();
  void set_has_metric_origin();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  union GeometryUnion {
    GeometryUnion() {}
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin_;
  } geometry_;
  union AccuracyUnion {
    AccuracyUnion() {}
    ::google::protobuf::Int64Value* combined_std_dev_;
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev_;
    ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
  } accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CornerVectors : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors) */ {
 public:
  RectangularBoxAndAccuracy_CornerVectors();
  virtual ~RectangularBoxAndAccuracy_CornerVectors();

  RectangularBoxAndAccuracy_CornerVectors(const RectangularBoxAndAccuracy_CornerVectors& from);

  inline RectangularBoxAndAccuracy_CornerVectors& operator=(const RectangularBoxAndAccuracy_CornerVectors& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectangularBoxAndAccuracy_CornerVectors(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept
    : RectangularBoxAndAccuracy_CornerVectors() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy_CornerVectors& operator=(RectangularBoxAndAccuracy_CornerVectors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RectangularBoxAndAccuracy_CornerVectors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectangularBoxAndAccuracy_CornerVectors* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy_CornerVectors*>(
               &_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CornerVectors* other);
  void Swap(RectangularBoxAndAccuracy_CornerVectors* other);
  friend void swap(RectangularBoxAndAccuracy_CornerVectors& a, RectangularBoxAndAccuracy_CornerVectors& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectangularBoxAndAccuracy_CornerVectors* New() const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CornerVectors>(NULL);
  }

  RectangularBoxAndAccuracy_CornerVectors* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CornerVectors>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RectangularBoxAndAccuracy_CornerVectors& from);
  void MergeFrom(const RectangularBoxAndAccuracy_CornerVectors& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangularBoxAndAccuracy_CornerVectors* other);
  protected:
  explicit RectangularBoxAndAccuracy_CornerVectors(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1;
  bool has_first_and_accuracy() const;
  void clear_first_and_accuracy();
  static const int kFirstAndAccuracyFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_first_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& first_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_first_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_first_and_accuracy();
  void set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* first_and_accuracy);
  void unsafe_arena_set_allocated_first_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* first_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_first_and_accuracy();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2;
  bool has_second_and_accuracy() const;
  void clear_second_and_accuracy();
  static const int kSecondAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_second_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& second_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_second_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_second_and_accuracy();
  void set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* second_and_accuracy);
  void unsafe_arena_set_allocated_second_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* second_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_second_and_accuracy();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3;
  bool has_third_and_accuracy() const;
  void clear_third_and_accuracy();
  static const int kThirdAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_third_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& third_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_third_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_third_and_accuracy();
  void set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* third_and_accuracy);
  void unsafe_arena_set_allocated_third_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* third_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_third_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* first_and_accuracy_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* second_and_accuracy_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* third_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy_CenterOrientationSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize) */ {
 public:
  RectangularBoxAndAccuracy_CenterOrientationSize();
  virtual ~RectangularBoxAndAccuracy_CenterOrientationSize();

  RectangularBoxAndAccuracy_CenterOrientationSize(const RectangularBoxAndAccuracy_CenterOrientationSize& from);

  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(const RectangularBoxAndAccuracy_CenterOrientationSize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectangularBoxAndAccuracy_CenterOrientationSize(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept
    : RectangularBoxAndAccuracy_CenterOrientationSize() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy_CenterOrientationSize& operator=(RectangularBoxAndAccuracy_CenterOrientationSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RectangularBoxAndAccuracy_CenterOrientationSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectangularBoxAndAccuracy_CenterOrientationSize* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy_CenterOrientationSize*>(
               &_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(RectangularBoxAndAccuracy_CenterOrientationSize* other);
  void Swap(RectangularBoxAndAccuracy_CenterOrientationSize* other);
  friend void swap(RectangularBoxAndAccuracy_CenterOrientationSize& a, RectangularBoxAndAccuracy_CenterOrientationSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectangularBoxAndAccuracy_CenterOrientationSize* New() const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CenterOrientationSize>(NULL);
  }

  RectangularBoxAndAccuracy_CenterOrientationSize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy_CenterOrientationSize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  void MergeFrom(const RectangularBoxAndAccuracy_CenterOrientationSize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangularBoxAndAccuracy_CenterOrientationSize* other);
  protected:
  explicit RectangularBoxAndAccuracy_CenterOrientationSize(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
  bool has_center_position_and_accuracy() const;
  void clear_center_position_and_accuracy();
  static const int kCenterPositionAndAccuracyFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_center_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& center_position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_center_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_center_position_and_accuracy();
  void set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy);
  void unsafe_arena_set_allocated_center_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_center_position_and_accuracy();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy();
  static const int kOrientationAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy);
  void unsafe_arena_set_allocated_orientation_and_accuracy(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* unsafe_arena_release_orientation_and_accuracy();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3;
  bool has_size_and_accuracy() const;
  void clear_size_and_accuracy();
  static const int kSizeAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_size_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& size_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_size_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_size_and_accuracy();
  void set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* size_and_accuracy);
  void unsafe_arena_set_allocated_size_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* size_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_size_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy_;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* size_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectangularBoxAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy) */ {
 public:
  RectangularBoxAndAccuracy();
  virtual ~RectangularBoxAndAccuracy();

  RectangularBoxAndAccuracy(const RectangularBoxAndAccuracy& from);

  inline RectangularBoxAndAccuracy& operator=(const RectangularBoxAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectangularBoxAndAccuracy(RectangularBoxAndAccuracy&& from) noexcept
    : RectangularBoxAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RectangularBoxAndAccuracy& operator=(RectangularBoxAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RectangularBoxAndAccuracy& default_instance();

  enum GeometryCase {
    kCornerVectors = 1,
    kCenterOrientationSize = 2,
    GEOMETRY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectangularBoxAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RectangularBoxAndAccuracy*>(
               &_RectangularBoxAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(RectangularBoxAndAccuracy* other);
  void Swap(RectangularBoxAndAccuracy* other);
  friend void swap(RectangularBoxAndAccuracy& a, RectangularBoxAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectangularBoxAndAccuracy* New() const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy>(NULL);
  }

  RectangularBoxAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RectangularBoxAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RectangularBoxAndAccuracy& from);
  void MergeFrom(const RectangularBoxAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangularBoxAndAccuracy* other);
  protected:
  explicit RectangularBoxAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RectangularBoxAndAccuracy_CornerVectors CornerVectors;
  typedef RectangularBoxAndAccuracy_CenterOrientationSize CenterOrientationSize;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
  bool has_corner_vectors() const;
  void clear_corner_vectors();
  static const int kCornerVectorsFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& _internal_corner_vectors() const;
  public:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& corner_vectors() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* release_corner_vectors();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* mutable_corner_vectors();
  void set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors);
  void unsafe_arena_set_allocated_corner_vectors(
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* unsafe_arena_release_corner_vectors();

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
  bool has_center_orientation_size() const;
  void clear_center_orientation_size();
  static const int kCenterOrientationSizeFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& _internal_center_orientation_size() const;
  public:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& center_orientation_size() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* release_center_orientation_size();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* mutable_center_orientation_size();
  void set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size);
  void unsafe_arena_set_allocated_center_orientation_size(
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* unsafe_arena_release_center_orientation_size();

  void clear_geometry();
  GeometryCase geometry_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy)
 private:
  void set_has_corner_vectors();
  void set_has_center_orientation_size();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  union GeometryUnion {
    GeometryUnion() {}
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors_;
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size_;
  } geometry_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationAndAccuracy_Euler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler) */ {
 public:
  RotationAndAccuracy_Euler();
  virtual ~RotationAndAccuracy_Euler();

  RotationAndAccuracy_Euler(const RotationAndAccuracy_Euler& from);

  inline RotationAndAccuracy_Euler& operator=(const RotationAndAccuracy_Euler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationAndAccuracy_Euler(RotationAndAccuracy_Euler&& from) noexcept
    : RotationAndAccuracy_Euler() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_Euler& operator=(RotationAndAccuracy_Euler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationAndAccuracy_Euler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationAndAccuracy_Euler* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_Euler*>(
               &_RotationAndAccuracy_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(RotationAndAccuracy_Euler* other);
  void Swap(RotationAndAccuracy_Euler* other);
  friend void swap(RotationAndAccuracy_Euler& a, RotationAndAccuracy_Euler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationAndAccuracy_Euler* New() const final {
    return CreateMaybeMessage<RotationAndAccuracy_Euler>(NULL);
  }

  RotationAndAccuracy_Euler* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationAndAccuracy_Euler>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationAndAccuracy_Euler& from);
  void MergeFrom(const RotationAndAccuracy_Euler& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationAndAccuracy_Euler* other);
  protected:
  explicit RotationAndAccuracy_Euler(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* yaw);
  void unsafe_arena_set_allocated_yaw(
      ::sensoris::protobuf::types::base::Int64Value* yaw);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_yaw();

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* pitch);
  void unsafe_arena_set_allocated_pitch(
      ::sensoris::protobuf::types::base::Int64Value* pitch);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_pitch();

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  ::sensoris::protobuf::types::base::Int64Value* release_roll();
  ::sensoris::protobuf::types::base::Int64Value* mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* roll);
  void unsafe_arena_set_allocated_roll(
      ::sensoris::protobuf::types::base::Int64Value* roll);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_roll();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* yaw_;
  ::sensoris::protobuf::types::base::Int64Value* pitch_;
  ::sensoris::protobuf::types::base::Int64Value* roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationAndAccuracy_Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion) */ {
 public:
  RotationAndAccuracy_Quaternion();
  virtual ~RotationAndAccuracy_Quaternion();

  RotationAndAccuracy_Quaternion(const RotationAndAccuracy_Quaternion& from);

  inline RotationAndAccuracy_Quaternion& operator=(const RotationAndAccuracy_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationAndAccuracy_Quaternion(RotationAndAccuracy_Quaternion&& from) noexcept
    : RotationAndAccuracy_Quaternion() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_Quaternion& operator=(RotationAndAccuracy_Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationAndAccuracy_Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationAndAccuracy_Quaternion* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_Quaternion*>(
               &_RotationAndAccuracy_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(RotationAndAccuracy_Quaternion* other);
  void Swap(RotationAndAccuracy_Quaternion* other);
  friend void swap(RotationAndAccuracy_Quaternion& a, RotationAndAccuracy_Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationAndAccuracy_Quaternion* New() const final {
    return CreateMaybeMessage<RotationAndAccuracy_Quaternion>(NULL);
  }

  RotationAndAccuracy_Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationAndAccuracy_Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationAndAccuracy_Quaternion& from);
  void MergeFrom(const RotationAndAccuracy_Quaternion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationAndAccuracy_Quaternion* other);
  protected:
  explicit RotationAndAccuracy_Quaternion(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_x() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& x() const;
  ::sensoris::protobuf::types::base::Int64Value* release_x();
  ::sensoris::protobuf::types::base::Int64Value* mutable_x();
  void set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x);
  void unsafe_arena_set_allocated_x(
      ::sensoris::protobuf::types::base::Int64Value* x);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_x();

  // .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_y() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& y() const;
  ::sensoris::protobuf::types::base::Int64Value* release_y();
  ::sensoris::protobuf::types::base::Int64Value* mutable_y();
  void set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y);
  void unsafe_arena_set_allocated_y(
      ::sensoris::protobuf::types::base::Int64Value* y);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_y();

  // .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_z() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& z() const;
  ::sensoris::protobuf::types::base::Int64Value* release_z();
  ::sensoris::protobuf::types::base::Int64Value* mutable_z();
  void set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z);
  void unsafe_arena_set_allocated_z(
      ::sensoris::protobuf::types::base::Int64Value* z);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_z();

  // .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_w() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& w() const;
  ::sensoris::protobuf::types::base::Int64Value* release_w();
  ::sensoris::protobuf::types::base::Int64Value* mutable_w();
  void set_allocated_w(::sensoris::protobuf::types::base::Int64Value* w);
  void unsafe_arena_set_allocated_w(
      ::sensoris::protobuf::types::base::Int64Value* w);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_w();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* x_;
  ::sensoris::protobuf::types::base::Int64Value* y_;
  ::sensoris::protobuf::types::base::Int64Value* z_;
  ::sensoris::protobuf::types::base::Int64Value* w_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationAndAccuracy_StdDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev) */ {
 public:
  RotationAndAccuracy_StdDev();
  virtual ~RotationAndAccuracy_StdDev();

  RotationAndAccuracy_StdDev(const RotationAndAccuracy_StdDev& from);

  inline RotationAndAccuracy_StdDev& operator=(const RotationAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationAndAccuracy_StdDev(RotationAndAccuracy_StdDev&& from) noexcept
    : RotationAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy_StdDev& operator=(RotationAndAccuracy_StdDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationAndAccuracy_StdDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy_StdDev*>(
               &_RotationAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(RotationAndAccuracy_StdDev* other);
  void Swap(RotationAndAccuracy_StdDev* other);
  friend void swap(RotationAndAccuracy_StdDev& a, RotationAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationAndAccuracy_StdDev* New() const final {
    return CreateMaybeMessage<RotationAndAccuracy_StdDev>(NULL);
  }

  RotationAndAccuracy_StdDev* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationAndAccuracy_StdDev>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationAndAccuracy_StdDev& from);
  void MergeFrom(const RotationAndAccuracy_StdDev& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationAndAccuracy_StdDev* other);
  protected:
  explicit RotationAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  public:
  const ::google::protobuf::Int64Value& yaw() const;
  ::google::protobuf::Int64Value* release_yaw();
  ::google::protobuf::Int64Value* mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* yaw);
  void unsafe_arena_set_allocated_yaw(
      ::google::protobuf::Int64Value* yaw);
  ::google::protobuf::Int64Value* unsafe_arena_release_yaw();

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  public:
  const ::google::protobuf::Int64Value& pitch() const;
  ::google::protobuf::Int64Value* release_pitch();
  ::google::protobuf::Int64Value* mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* pitch);
  void unsafe_arena_set_allocated_pitch(
      ::google::protobuf::Int64Value* pitch);
  ::google::protobuf::Int64Value* unsafe_arena_release_pitch();

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  public:
  const ::google::protobuf::Int64Value& roll() const;
  ::google::protobuf::Int64Value* release_roll();
  ::google::protobuf::Int64Value* mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* roll);
  void unsafe_arena_set_allocated_roll(
      ::google::protobuf::Int64Value* roll);
  ::google::protobuf::Int64Value* unsafe_arena_release_roll();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int64Value* yaw_;
  ::google::protobuf::Int64Value* pitch_;
  ::google::protobuf::Int64Value* roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationAndAccuracy) */ {
 public:
  RotationAndAccuracy();
  virtual ~RotationAndAccuracy();

  RotationAndAccuracy(const RotationAndAccuracy& from);

  inline RotationAndAccuracy& operator=(const RotationAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationAndAccuracy(RotationAndAccuracy&& from) noexcept
    : RotationAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RotationAndAccuracy& operator=(RotationAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationAndAccuracy& default_instance();

  enum EulerQuaternionCase {
    kEulerVehicle = 1,
    kEulerEventGroup = 2,
    kQuaternionVehicle = 3,
    kQuaternionEventGroup = 4,
    EULER_QUATERNION_NOT_SET = 0,
  };

  enum AccuracyCase {
    kCombinedStdDev = 5,
    kStdDev = 6,
    kCovariance = 7,
    ACCURACY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RotationAndAccuracy*>(
               &_RotationAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(RotationAndAccuracy* other);
  void Swap(RotationAndAccuracy* other);
  friend void swap(RotationAndAccuracy& a, RotationAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationAndAccuracy* New() const final {
    return CreateMaybeMessage<RotationAndAccuracy>(NULL);
  }

  RotationAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationAndAccuracy& from);
  void MergeFrom(const RotationAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationAndAccuracy* other);
  protected:
  explicit RotationAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RotationAndAccuracy_Euler Euler;
  typedef RotationAndAccuracy_Quaternion Quaternion;
  typedef RotationAndAccuracy_StdDev StdDev;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
  bool has_euler_vehicle() const;
  void clear_euler_vehicle();
  static const int kEulerVehicleFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_vehicle() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* release_euler_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* mutable_euler_vehicle();
  void set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle);
  void unsafe_arena_set_allocated_euler_vehicle(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* unsafe_arena_release_euler_vehicle();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
  bool has_euler_event_group() const;
  void clear_euler_event_group();
  static const int kEulerEventGroupFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& _internal_euler_event_group() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& euler_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* release_euler_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* mutable_euler_event_group();
  void set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group);
  void unsafe_arena_set_allocated_euler_event_group(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* unsafe_arena_release_euler_event_group();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
  bool has_quaternion_vehicle() const;
  void clear_quaternion_vehicle();
  static const int kQuaternionVehicleFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_vehicle() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_vehicle() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* release_quaternion_vehicle();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* mutable_quaternion_vehicle();
  void set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle);
  void unsafe_arena_set_allocated_quaternion_vehicle(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* unsafe_arena_release_quaternion_vehicle();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
  bool has_quaternion_event_group() const;
  void clear_quaternion_event_group();
  static const int kQuaternionEventGroupFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& _internal_quaternion_event_group() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& quaternion_event_group() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* release_quaternion_event_group();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* mutable_quaternion_event_group();
  void set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group);
  void unsafe_arena_set_allocated_quaternion_event_group(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* unsafe_arena_release_quaternion_event_group();

  // .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  void clear_combined_std_dev();
  static const int kCombinedStdDevFieldNumber = 5;
  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  public:
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev);
  void unsafe_arena_set_allocated_combined_std_dev(
      ::google::protobuf::Int64Value* combined_std_dev);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
  bool has_std_dev() const;
  void clear_std_dev();
  static const int kStdDevFieldNumber = 6;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& _internal_std_dev() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev);
  void unsafe_arena_set_allocated_std_dev(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  void clear_covariance();
  static const int kCovarianceFieldNumber = 7;
  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  void unsafe_arena_set_allocated_covariance(
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  void clear_euler_quaternion();
  EulerQuaternionCase euler_quaternion_case() const;
  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationAndAccuracy)
 private:
  void set_has_euler_vehicle();
  void set_has_euler_event_group();
  void set_has_quaternion_vehicle();
  void set_has_quaternion_event_group();
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_euler_quaternion() const;
  inline void clear_has_euler_quaternion();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  union EulerQuaternionUnion {
    EulerQuaternionUnion() {}
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group_;
  } euler_quaternion_;
  union AccuracyUnion {
    AccuracyUnion() {}
    ::google::protobuf::Int64Value* combined_std_dev_;
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev_;
    ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
  } accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationRateAndAccuracy_StdDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev) */ {
 public:
  RotationRateAndAccuracy_StdDev();
  virtual ~RotationRateAndAccuracy_StdDev();

  RotationRateAndAccuracy_StdDev(const RotationRateAndAccuracy_StdDev& from);

  inline RotationRateAndAccuracy_StdDev& operator=(const RotationRateAndAccuracy_StdDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationRateAndAccuracy_StdDev(RotationRateAndAccuracy_StdDev&& from) noexcept
    : RotationRateAndAccuracy_StdDev() {
    *this = ::std::move(from);
  }

  inline RotationRateAndAccuracy_StdDev& operator=(RotationRateAndAccuracy_StdDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationRateAndAccuracy_StdDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationRateAndAccuracy_StdDev* internal_default_instance() {
    return reinterpret_cast<const RotationRateAndAccuracy_StdDev*>(
               &_RotationRateAndAccuracy_StdDev_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(RotationRateAndAccuracy_StdDev* other);
  void Swap(RotationRateAndAccuracy_StdDev* other);
  friend void swap(RotationRateAndAccuracy_StdDev& a, RotationRateAndAccuracy_StdDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationRateAndAccuracy_StdDev* New() const final {
    return CreateMaybeMessage<RotationRateAndAccuracy_StdDev>(NULL);
  }

  RotationRateAndAccuracy_StdDev* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationRateAndAccuracy_StdDev>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationRateAndAccuracy_StdDev& from);
  void MergeFrom(const RotationRateAndAccuracy_StdDev& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationRateAndAccuracy_StdDev* other);
  protected:
  explicit RotationRateAndAccuracy_StdDev(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_yaw() const;
  public:
  const ::google::protobuf::Int64Value& yaw() const;
  ::google::protobuf::Int64Value* release_yaw();
  ::google::protobuf::Int64Value* mutable_yaw();
  void set_allocated_yaw(::google::protobuf::Int64Value* yaw);
  void unsafe_arena_set_allocated_yaw(
      ::google::protobuf::Int64Value* yaw);
  ::google::protobuf::Int64Value* unsafe_arena_release_yaw();

  // .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_pitch() const;
  public:
  const ::google::protobuf::Int64Value& pitch() const;
  ::google::protobuf::Int64Value* release_pitch();
  ::google::protobuf::Int64Value* mutable_pitch();
  void set_allocated_pitch(::google::protobuf::Int64Value* pitch);
  void unsafe_arena_set_allocated_pitch(
      ::google::protobuf::Int64Value* pitch);
  ::google::protobuf::Int64Value* unsafe_arena_release_pitch();

  // .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_roll() const;
  public:
  const ::google::protobuf::Int64Value& roll() const;
  ::google::protobuf::Int64Value* release_roll();
  ::google::protobuf::Int64Value* mutable_roll();
  void set_allocated_roll(::google::protobuf::Int64Value* roll);
  void unsafe_arena_set_allocated_roll(
      ::google::protobuf::Int64Value* roll);
  ::google::protobuf::Int64Value* unsafe_arena_release_roll();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::Int64Value* yaw_;
  ::google::protobuf::Int64Value* pitch_;
  ::google::protobuf::Int64Value* roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RotationRateAndAccuracy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.RotationRateAndAccuracy) */ {
 public:
  RotationRateAndAccuracy();
  virtual ~RotationRateAndAccuracy();

  RotationRateAndAccuracy(const RotationRateAndAccuracy& from);

  inline RotationRateAndAccuracy& operator=(const RotationRateAndAccuracy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RotationRateAndAccuracy(RotationRateAndAccuracy&& from) noexcept
    : RotationRateAndAccuracy() {
    *this = ::std::move(from);
  }

  inline RotationRateAndAccuracy& operator=(RotationRateAndAccuracy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RotationRateAndAccuracy& default_instance();

  enum AccuracyCase {
    kCombinedStdDev = 4,
    kStdDev = 5,
    kCovariance = 6,
    ACCURACY_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RotationRateAndAccuracy* internal_default_instance() {
    return reinterpret_cast<const RotationRateAndAccuracy*>(
               &_RotationRateAndAccuracy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(RotationRateAndAccuracy* other);
  void Swap(RotationRateAndAccuracy* other);
  friend void swap(RotationRateAndAccuracy& a, RotationRateAndAccuracy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RotationRateAndAccuracy* New() const final {
    return CreateMaybeMessage<RotationRateAndAccuracy>(NULL);
  }

  RotationRateAndAccuracy* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RotationRateAndAccuracy>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RotationRateAndAccuracy& from);
  void MergeFrom(const RotationRateAndAccuracy& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RotationRateAndAccuracy* other);
  protected:
  explicit RotationRateAndAccuracy(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RotationRateAndAccuracy_StdDev StdDev;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_yaw() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& yaw() const;
  ::sensoris::protobuf::types::base::Int64Value* release_yaw();
  ::sensoris::protobuf::types::base::Int64Value* mutable_yaw();
  void set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* yaw);
  void unsafe_arena_set_allocated_yaw(
      ::sensoris::protobuf::types::base::Int64Value* yaw);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_yaw();

  // .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pitch() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& pitch() const;
  ::sensoris::protobuf::types::base::Int64Value* release_pitch();
  ::sensoris::protobuf::types::base::Int64Value* mutable_pitch();
  void set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* pitch);
  void unsafe_arena_set_allocated_pitch(
      ::sensoris::protobuf::types::base::Int64Value* pitch);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_pitch();

  // .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_roll() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& roll() const;
  ::sensoris::protobuf::types::base::Int64Value* release_roll();
  ::sensoris::protobuf::types::base::Int64Value* mutable_roll();
  void set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* roll);
  void unsafe_arena_set_allocated_roll(
      ::sensoris::protobuf::types::base::Int64Value* roll);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_roll();

  // .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_combined_std_dev() const;
  void clear_combined_std_dev();
  static const int kCombinedStdDevFieldNumber = 4;
  private:
  const ::google::protobuf::Int64Value& _internal_combined_std_dev() const;
  public:
  const ::google::protobuf::Int64Value& combined_std_dev() const;
  ::google::protobuf::Int64Value* release_combined_std_dev();
  ::google::protobuf::Int64Value* mutable_combined_std_dev();
  void set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev);
  void unsafe_arena_set_allocated_combined_std_dev(
      ::google::protobuf::Int64Value* combined_std_dev);
  ::google::protobuf::Int64Value* unsafe_arena_release_combined_std_dev();

  // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
  bool has_std_dev() const;
  void clear_std_dev();
  static const int kStdDevFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& _internal_std_dev() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& std_dev() const;
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* release_std_dev();
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* mutable_std_dev();
  void set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev);
  void unsafe_arena_set_allocated_std_dev(
      ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev);
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* unsafe_arena_release_std_dev();

  // .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_covariance() const;
  void clear_covariance();
  static const int kCovarianceFieldNumber = 6;
  private:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& _internal_covariance() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Matrix3x3& covariance() const;
  ::sensoris::protobuf::types::base::Int64Matrix3x3* release_covariance();
  ::sensoris::protobuf::types::base::Int64Matrix3x3* mutable_covariance();
  void set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  void unsafe_arena_set_allocated_covariance(
      ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance);
  ::sensoris::protobuf::types::base::Int64Matrix3x3* unsafe_arena_release_covariance();

  void clear_accuracy();
  AccuracyCase accuracy_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.RotationRateAndAccuracy)
 private:
  void set_has_combined_std_dev();
  void set_has_std_dev();
  void set_has_covariance();

  inline bool has_accuracy() const;
  inline void clear_has_accuracy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  ::sensoris::protobuf::types::base::Int64Value* yaw_;
  ::sensoris::protobuf::types::base::Int64Value* pitch_;
  ::sensoris::protobuf::types::base::Int64Value* roll_;
  union AccuracyUnion {
    AccuracyUnion() {}
    ::google::protobuf::Int64Value* combined_std_dev_;
    ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev_;
    ::sensoris::protobuf::types::base::Int64Matrix3x3* covariance_;
  } accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapLocationReference_TileIdLinkIdOffset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset) */ {
 public:
  MapLocationReference_TileIdLinkIdOffset();
  virtual ~MapLocationReference_TileIdLinkIdOffset();

  MapLocationReference_TileIdLinkIdOffset(const MapLocationReference_TileIdLinkIdOffset& from);

  inline MapLocationReference_TileIdLinkIdOffset& operator=(const MapLocationReference_TileIdLinkIdOffset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapLocationReference_TileIdLinkIdOffset(MapLocationReference_TileIdLinkIdOffset&& from) noexcept
    : MapLocationReference_TileIdLinkIdOffset() {
    *this = ::std::move(from);
  }

  inline MapLocationReference_TileIdLinkIdOffset& operator=(MapLocationReference_TileIdLinkIdOffset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLocationReference_TileIdLinkIdOffset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapLocationReference_TileIdLinkIdOffset* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference_TileIdLinkIdOffset*>(
               &_MapLocationReference_TileIdLinkIdOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(MapLocationReference_TileIdLinkIdOffset* other);
  void Swap(MapLocationReference_TileIdLinkIdOffset* other);
  friend void swap(MapLocationReference_TileIdLinkIdOffset& a, MapLocationReference_TileIdLinkIdOffset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapLocationReference_TileIdLinkIdOffset* New() const final {
    return CreateMaybeMessage<MapLocationReference_TileIdLinkIdOffset>(NULL);
  }

  MapLocationReference_TileIdLinkIdOffset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapLocationReference_TileIdLinkIdOffset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapLocationReference_TileIdLinkIdOffset& from);
  void MergeFrom(const MapLocationReference_TileIdLinkIdOffset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapLocationReference_TileIdLinkIdOffset* other);
  protected:
  explicit MapLocationReference_TileIdLinkIdOffset(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id();
  static const int kTileIdFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  public:
  const ::google::protobuf::Int64Value& tile_id() const;
  ::google::protobuf::Int64Value* release_tile_id();
  ::google::protobuf::Int64Value* mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* tile_id);
  void unsafe_arena_set_allocated_tile_id(
      ::google::protobuf::Int64Value* tile_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_tile_id();

  // .google.protobuf.Int64Value link_id = 2;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_link_id() const;
  public:
  const ::google::protobuf::Int64Value& link_id() const;
  ::google::protobuf::Int64Value* release_link_id();
  ::google::protobuf::Int64Value* mutable_link_id();
  void set_allocated_link_id(::google::protobuf::Int64Value* link_id);
  void unsafe_arena_set_allocated_link_id(
      ::google::protobuf::Int64Value* link_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_link_id();

  // .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_offset() const;
  public:
  const ::google::protobuf::Int64Value& offset() const;
  ::google::protobuf::Int64Value* release_offset();
  ::google::protobuf::Int64Value* mutable_offset();
  void set_allocated_offset(::google::protobuf::Int64Value* offset);
  void unsafe_arena_set_allocated_offset(
      ::google::protobuf::Int64Value* offset);
  ::google::protobuf::Int64Value* unsafe_arena_release_offset();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  ::google::protobuf::Int64Value* tile_id_;
  ::google::protobuf::Int64Value* link_id_;
  ::google::protobuf::Int64Value* offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapLocationReference_TileIdObjectId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId) */ {
 public:
  MapLocationReference_TileIdObjectId();
  virtual ~MapLocationReference_TileIdObjectId();

  MapLocationReference_TileIdObjectId(const MapLocationReference_TileIdObjectId& from);

  inline MapLocationReference_TileIdObjectId& operator=(const MapLocationReference_TileIdObjectId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapLocationReference_TileIdObjectId(MapLocationReference_TileIdObjectId&& from) noexcept
    : MapLocationReference_TileIdObjectId() {
    *this = ::std::move(from);
  }

  inline MapLocationReference_TileIdObjectId& operator=(MapLocationReference_TileIdObjectId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLocationReference_TileIdObjectId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapLocationReference_TileIdObjectId* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference_TileIdObjectId*>(
               &_MapLocationReference_TileIdObjectId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(MapLocationReference_TileIdObjectId* other);
  void Swap(MapLocationReference_TileIdObjectId* other);
  friend void swap(MapLocationReference_TileIdObjectId& a, MapLocationReference_TileIdObjectId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapLocationReference_TileIdObjectId* New() const final {
    return CreateMaybeMessage<MapLocationReference_TileIdObjectId>(NULL);
  }

  MapLocationReference_TileIdObjectId* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapLocationReference_TileIdObjectId>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapLocationReference_TileIdObjectId& from);
  void MergeFrom(const MapLocationReference_TileIdObjectId& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapLocationReference_TileIdObjectId* other);
  protected:
  explicit MapLocationReference_TileIdObjectId(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .google.protobuf.Int64Value tile_id = 1;
  bool has_tile_id() const;
  void clear_tile_id();
  static const int kTileIdFieldNumber = 1;
  private:
  const ::google::protobuf::Int64Value& _internal_tile_id() const;
  public:
  const ::google::protobuf::Int64Value& tile_id() const;
  ::google::protobuf::Int64Value* release_tile_id();
  ::google::protobuf::Int64Value* mutable_tile_id();
  void set_allocated_tile_id(::google::protobuf::Int64Value* tile_id);
  void unsafe_arena_set_allocated_tile_id(
      ::google::protobuf::Int64Value* tile_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_tile_id();

  // .google.protobuf.Int64Value object_id = 2;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_object_id() const;
  public:
  const ::google::protobuf::Int64Value& object_id() const;
  ::google::protobuf::Int64Value* release_object_id();
  ::google::protobuf::Int64Value* mutable_object_id();
  void set_allocated_object_id(::google::protobuf::Int64Value* object_id);
  void unsafe_arena_set_allocated_object_id(
      ::google::protobuf::Int64Value* object_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_object_id();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  ::google::protobuf::Int64Value* tile_id_;
  ::google::protobuf::Int64Value* object_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapLocationReference : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.types.spatial.MapLocationReference) */ {
 public:
  MapLocationReference();
  virtual ~MapLocationReference();

  MapLocationReference(const MapLocationReference& from);

  inline MapLocationReference& operator=(const MapLocationReference& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapLocationReference(MapLocationReference&& from) noexcept
    : MapLocationReference() {
    *this = ::std::move(from);
  }

  inline MapLocationReference& operator=(MapLocationReference&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MapLocationReference& default_instance();

  enum MapBasedReferenceCase {
    kTileLinkOffsetReference = 3,
    kMapObjectId = 4,
    MAP_BASED_REFERENCE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapLocationReference* internal_default_instance() {
    return reinterpret_cast<const MapLocationReference*>(
               &_MapLocationReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(MapLocationReference* other);
  void Swap(MapLocationReference* other);
  friend void swap(MapLocationReference& a, MapLocationReference& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapLocationReference* New() const final {
    return CreateMaybeMessage<MapLocationReference>(NULL);
  }

  MapLocationReference* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapLocationReference>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapLocationReference& from);
  void MergeFrom(const MapLocationReference& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapLocationReference* other);
  protected:
  explicit MapLocationReference(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MapLocationReference_TileIdLinkIdOffset TileIdLinkIdOffset;
  typedef MapLocationReference_TileIdObjectId TileIdObjectId;

  // accessors -------------------------------------------------------

  // repeated .google.protobuf.Any extension = 15;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 15;
  ::google::protobuf::Any* mutable_extension(int index);
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
      mutable_extension();
  const ::google::protobuf::Any& extension(int index) const;
  ::google::protobuf::Any* add_extension();
  const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
      extension() const;

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // .google.protobuf.Int64Value z_level = 2;
  bool has_z_level() const;
  void clear_z_level();
  static const int kZLevelFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_z_level() const;
  public:
  const ::google::protobuf::Int64Value& z_level() const;
  ::google::protobuf::Int64Value* release_z_level();
  ::google::protobuf::Int64Value* mutable_z_level();
  void set_allocated_z_level(::google::protobuf::Int64Value* z_level);
  void unsafe_arena_set_allocated_z_level(
      ::google::protobuf::Int64Value* z_level);
  ::google::protobuf::Int64Value* unsafe_arena_release_z_level();

  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
  bool has_tile_link_offset_reference() const;
  void clear_tile_link_offset_reference();
  static const int kTileLinkOffsetReferenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& _internal_tile_link_offset_reference() const;
  public:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& tile_link_offset_reference() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* release_tile_link_offset_reference();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* mutable_tile_link_offset_reference();
  void set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference);
  void unsafe_arena_set_allocated_tile_link_offset_reference(
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* unsafe_arena_release_tile_link_offset_reference();

  // .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
  bool has_map_object_id() const;
  void clear_map_object_id();
  static const int kMapObjectIdFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& _internal_map_object_id() const;
  public:
  const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& map_object_id() const;
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* release_map_object_id();
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* mutable_map_object_id();
  void set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id);
  void unsafe_arena_set_allocated_map_object_id(
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id);
  ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* unsafe_arena_release_map_object_id();

  void clear_map_based_reference();
  MapBasedReferenceCase map_based_reference_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.types.spatial.MapLocationReference)
 private:
  void set_has_tile_link_offset_reference();
  void set_has_map_object_id();

  inline bool has_map_based_reference() const;
  inline void clear_has_map_based_reference();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any > extension_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  ::google::protobuf::Int64Value* z_level_;
  union MapBasedReferenceUnion {
    MapBasedReferenceUnion() {}
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference_;
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id_;
  } map_based_reference_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PositionAndAccuracy_Geographic

// .sensoris.protobuf.types.base.Int64Value longitude = 1 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_longitude() const {
  return this != internal_default_instance() && longitude_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_longitude() const {
  return *longitude_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::longitude() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = longitude_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_longitude() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = longitude_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  longitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_longitude() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = longitude_;
  longitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_longitude() {
  
  if (longitude_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    longitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
  return longitude_;
}
inline void PositionAndAccuracy_Geographic::set_allocated_longitude(::sensoris::protobuf::types::base::Int64Value* longitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(longitude_);
  }
  if (longitude) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(longitude)->GetArena();
    if (message_arena != submessage_arena) {
      longitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longitude, submessage_arena);
    }
    
  } else {
    
  }
  longitude_ = longitude;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.longitude)
}

// .sensoris.protobuf.types.base.Int64Value latitude = 2 [(.sensoris.protobuf.types.base.exponent) = 8];
inline bool PositionAndAccuracy_Geographic::has_latitude() const {
  return this != internal_default_instance() && latitude_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_latitude() const {
  return *latitude_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::latitude() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = latitude_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_latitude() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = latitude_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  latitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_latitude() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = latitude_;
  latitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_latitude() {
  
  if (latitude_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    latitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
  return latitude_;
}
inline void PositionAndAccuracy_Geographic::set_allocated_latitude(::sensoris::protobuf::types::base::Int64Value* latitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(latitude_);
  }
  if (latitude) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(latitude)->GetArena();
    if (message_arena != submessage_arena) {
      latitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, latitude, submessage_arena);
    }
    
  } else {
    
  }
  latitude_ = latitude;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.latitude)
}

// .sensoris.protobuf.types.base.Int64Value altitude = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool PositionAndAccuracy_Geographic::has_altitude() const {
  return this != internal_default_instance() && altitude_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::_internal_altitude() const {
  return *altitude_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Geographic::altitude() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = altitude_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::release_altitude() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = altitude_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  altitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::unsafe_arena_release_altitude() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = altitude_;
  altitude_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Geographic::mutable_altitude() {
  
  if (altitude_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    altitude_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
  return altitude_;
}
inline void PositionAndAccuracy_Geographic::set_allocated_altitude(::sensoris::protobuf::types::base::Int64Value* altitude) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(altitude_);
  }
  if (altitude) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(altitude)->GetArena();
    if (message_arena != submessage_arena) {
      altitude = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, altitude, submessage_arena);
    }
    
  } else {
    
  }
  altitude_ = altitude;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic.altitude)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_x() const {
  return this != internal_default_instance() && x_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_x() const {
  return *x_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::x() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = x_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_x() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_x() {
  
  if (x_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
  return x_;
}
inline void PositionAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(x_);
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_y() const {
  return this != internal_default_instance() && y_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_y() const {
  return *y_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::y() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = y_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_y() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_y() {
  
  if (y_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
  return y_;
}
inline void PositionAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(y_);
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_Metric::has_z() const {
  return this != internal_default_instance() && z_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::_internal_z() const {
  return *z_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& PositionAndAccuracy_Metric::z() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = z_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::release_z() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* PositionAndAccuracy_Metric::mutable_z() {
  
  if (z_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
  return z_;
}
inline void PositionAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(z_);
  }
  if (z) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(z)->GetArena();
    if (message_arena != submessage_arena) {
      z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalVerticalStdDev

// .google.protobuf.Int64Value horizontal = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_horizontal() const {
  return this != internal_default_instance() && horizontal_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_horizontal() const {
  return *horizontal_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::horizontal() const {
  const ::google::protobuf::Int64Value* p = horizontal_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::release_horizontal() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  
  ::google::protobuf::Int64Value* temp = horizontal_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  horizontal_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_horizontal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  
  ::google::protobuf::Int64Value* temp = horizontal_;
  horizontal_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::mutable_horizontal() {
  
  if (horizontal_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    horizontal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
  return horizontal_;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_horizontal(::google::protobuf::Int64Value* horizontal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(horizontal_);
  }
  if (horizontal) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(horizontal)->GetArena();
    if (message_arena != submessage_arena) {
      horizontal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, horizontal, submessage_arena);
    }
    
  } else {
    
  }
  horizontal_ = horizontal;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.horizontal)
}

// .google.protobuf.Int64Value vertical = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalVerticalStdDev::has_vertical() const {
  return this != internal_default_instance() && vertical_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::_internal_vertical() const {
  return *vertical_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalVerticalStdDev::vertical() const {
  const ::google::protobuf::Int64Value* p = vertical_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::release_vertical() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  
  ::google::protobuf::Int64Value* temp = vertical_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  vertical_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::unsafe_arena_release_vertical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  
  ::google::protobuf::Int64Value* temp = vertical_;
  vertical_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalVerticalStdDev::mutable_vertical() {
  
  if (vertical_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    vertical_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
  return vertical_;
}
inline void PositionAndAccuracy_HorizontalVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* vertical) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vertical_);
  }
  if (vertical) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(vertical)->GetArena();
    if (message_arena != submessage_arena) {
      vertical = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vertical, submessage_arena);
    }
    
  } else {
    
  }
  vertical_ = vertical;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev

// .google.protobuf.Int64Value horizontal_ellipse_major = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major() const {
  return this != internal_default_instance() && horizontal_ellipse_major_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major() const {
  return *horizontal_ellipse_major_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major() const {
  const ::google::protobuf::Int64Value* p = horizontal_ellipse_major_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_major_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  horizontal_ellipse_major_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_major_;
  horizontal_ellipse_major_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major() {
  
  if (horizontal_ellipse_major_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    horizontal_ellipse_major_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
  return horizontal_ellipse_major_;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major(::google::protobuf::Int64Value* horizontal_ellipse_major) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(horizontal_ellipse_major_);
  }
  if (horizontal_ellipse_major) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(horizontal_ellipse_major)->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_ellipse_major = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, horizontal_ellipse_major, submessage_arena);
    }
    
  } else {
    
  }
  horizontal_ellipse_major_ = horizontal_ellipse_major;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major)
}

// .google.protobuf.Int64Value horizontal_ellipse_minor = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_minor() const {
  return this != internal_default_instance() && horizontal_ellipse_minor_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_minor() const {
  return *horizontal_ellipse_minor_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_minor() const {
  const ::google::protobuf::Int64Value* p = horizontal_ellipse_minor_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_minor() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_minor_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  horizontal_ellipse_minor_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_minor() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_minor_;
  horizontal_ellipse_minor_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_minor() {
  
  if (horizontal_ellipse_minor_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    horizontal_ellipse_minor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
  return horizontal_ellipse_minor_;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_minor(::google::protobuf::Int64Value* horizontal_ellipse_minor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(horizontal_ellipse_minor_);
  }
  if (horizontal_ellipse_minor) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(horizontal_ellipse_minor)->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_ellipse_minor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, horizontal_ellipse_minor, submessage_arena);
    }
    
  } else {
    
  }
  horizontal_ellipse_minor_ = horizontal_ellipse_minor;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_minor)
}

// .google.protobuf.Int64Value horizontal_ellipse_major_heading = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_horizontal_ellipse_major_heading() const {
  return this != internal_default_instance() && horizontal_ellipse_major_heading_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_horizontal_ellipse_major_heading() const {
  return *horizontal_ellipse_major_heading_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::horizontal_ellipse_major_heading() const {
  const ::google::protobuf::Int64Value* p = horizontal_ellipse_major_heading_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_horizontal_ellipse_major_heading() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_major_heading_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  horizontal_ellipse_major_heading_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_horizontal_ellipse_major_heading() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  
  ::google::protobuf::Int64Value* temp = horizontal_ellipse_major_heading_;
  horizontal_ellipse_major_heading_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_horizontal_ellipse_major_heading() {
  
  if (horizontal_ellipse_major_heading_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    horizontal_ellipse_major_heading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
  return horizontal_ellipse_major_heading_;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_horizontal_ellipse_major_heading(::google::protobuf::Int64Value* horizontal_ellipse_major_heading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(horizontal_ellipse_major_heading_);
  }
  if (horizontal_ellipse_major_heading) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(horizontal_ellipse_major_heading)->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_ellipse_major_heading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, horizontal_ellipse_major_heading, submessage_arena);
    }
    
  } else {
    
  }
  horizontal_ellipse_major_heading_ = horizontal_ellipse_major_heading;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.horizontal_ellipse_major_heading)
}

// .google.protobuf.Int64Value vertical = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::has_vertical() const {
  return this != internal_default_instance() && vertical_ != NULL;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::_internal_vertical() const {
  return *vertical_;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::vertical() const {
  const ::google::protobuf::Int64Value* p = vertical_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::release_vertical() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  
  ::google::protobuf::Int64Value* temp = vertical_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  vertical_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::unsafe_arena_release_vertical() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  
  ::google::protobuf::Int64Value* temp = vertical_;
  vertical_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::mutable_vertical() {
  
  if (vertical_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    vertical_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
  return vertical_;
}
inline void PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev::set_allocated_vertical(::google::protobuf::Int64Value* vertical) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vertical_);
  }
  if (vertical) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(vertical)->GetArena();
    if (message_arena != submessage_arena) {
      vertical = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vertical, submessage_arena);
    }
    
  } else {
    
  }
  vertical_ = vertical;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev.vertical)
}

// -------------------------------------------------------------------

// PositionAndAccuracy

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Geographic geographic_wgs84 = 1;
inline bool PositionAndAccuracy::has_geographic_wgs84() const {
  return geographic_metric_case() == kGeographicWgs84;
}
inline void PositionAndAccuracy::set_has_geographic_wgs84() {
  _oneof_case_[0] = kGeographicWgs84;
}
inline void PositionAndAccuracy::clear_geographic_wgs84() {
  if (has_geographic_wgs84()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geographic_metric_.geographic_wgs84_;
    }
    clear_has_geographic_metric();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::_internal_geographic_wgs84() const {
  return *geographic_metric_.geographic_wgs84_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::release_geographic_wgs84() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (has_geographic_wgs84()) {
    clear_has_geographic_metric();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* temp = geographic_metric_.geographic_wgs84_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geographic_metric_.geographic_wgs84_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic& PositionAndAccuracy::geographic_wgs84() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return has_geographic_wgs84()
      ? *geographic_metric_.geographic_wgs84_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Geographic_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::unsafe_arena_release_geographic_wgs84() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  if (has_geographic_wgs84()) {
    clear_has_geographic_metric();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* temp = geographic_metric_.geographic_wgs84_;
    geographic_metric_.geographic_wgs84_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_geographic_wgs84(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* geographic_wgs84) {
  clear_geographic_metric();
  if (geographic_wgs84) {
    set_has_geographic_wgs84();
    geographic_metric_.geographic_wgs84_ = geographic_wgs84;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic* PositionAndAccuracy::mutable_geographic_wgs84() {
  if (!has_geographic_wgs84()) {
    clear_geographic_metric();
    set_has_geographic_wgs84();
    geographic_metric_.geographic_wgs84_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Geographic >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.geographic_wgs84)
  return geographic_metric_.geographic_wgs84_;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_vehicle = 2;
inline bool PositionAndAccuracy::has_metric_vehicle() const {
  return geographic_metric_case() == kMetricVehicle;
}
inline void PositionAndAccuracy::set_has_metric_vehicle() {
  _oneof_case_[0] = kMetricVehicle;
}
inline void PositionAndAccuracy::clear_metric_vehicle() {
  if (has_metric_vehicle()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geographic_metric_.metric_vehicle_;
    }
    clear_has_geographic_metric();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_vehicle() const {
  return *geographic_metric_.metric_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (has_metric_vehicle()) {
    clear_has_geographic_metric();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_vehicle_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geographic_metric_.metric_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_vehicle() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return has_metric_vehicle()
      ? *geographic_metric_.metric_vehicle_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  if (has_metric_vehicle()) {
    clear_has_geographic_metric();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_vehicle_;
    geographic_metric_.metric_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_vehicle) {
  clear_geographic_metric();
  if (metric_vehicle) {
    set_has_metric_vehicle();
    geographic_metric_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_vehicle() {
  if (!has_metric_vehicle()) {
    clear_geographic_metric();
    set_has_metric_vehicle();
    geographic_metric_.metric_vehicle_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_vehicle)
  return geographic_metric_.metric_vehicle_;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_event_group = 3;
inline bool PositionAndAccuracy::has_metric_event_group() const {
  return geographic_metric_case() == kMetricEventGroup;
}
inline void PositionAndAccuracy::set_has_metric_event_group() {
  _oneof_case_[0] = kMetricEventGroup;
}
inline void PositionAndAccuracy::clear_metric_event_group() {
  if (has_metric_event_group()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geographic_metric_.metric_event_group_;
    }
    clear_has_geographic_metric();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_event_group() const {
  return *geographic_metric_.metric_event_group_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (has_metric_event_group()) {
    clear_has_geographic_metric();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_event_group_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geographic_metric_.metric_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_event_group() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return has_metric_event_group()
      ? *geographic_metric_.metric_event_group_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  if (has_metric_event_group()) {
    clear_has_geographic_metric();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_event_group_;
    geographic_metric_.metric_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_event_group) {
  clear_geographic_metric();
  if (metric_event_group) {
    set_has_metric_event_group();
    geographic_metric_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_event_group() {
  if (!has_metric_event_group()) {
    clear_geographic_metric();
    set_has_metric_event_group();
    geographic_metric_.metric_event_group_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_event_group)
  return geographic_metric_.metric_event_group_;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.Metric metric_ecef = 4;
inline bool PositionAndAccuracy::has_metric_ecef() const {
  return geographic_metric_case() == kMetricEcef;
}
inline void PositionAndAccuracy::set_has_metric_ecef() {
  _oneof_case_[0] = kMetricEcef;
}
inline void PositionAndAccuracy::clear_metric_ecef() {
  if (has_metric_ecef()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geographic_metric_.metric_ecef_;
    }
    clear_has_geographic_metric();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::_internal_metric_ecef() const {
  return *geographic_metric_.metric_ecef_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::release_metric_ecef() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (has_metric_ecef()) {
    clear_has_geographic_metric();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_ecef_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geographic_metric_.metric_ecef_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric& PositionAndAccuracy::metric_ecef() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return has_metric_ecef()
      ? *geographic_metric_.metric_ecef_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::unsafe_arena_release_metric_ecef() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  if (has_metric_ecef()) {
    clear_has_geographic_metric();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* temp = geographic_metric_.metric_ecef_;
    geographic_metric_.metric_ecef_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_metric_ecef(::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* metric_ecef) {
  clear_geographic_metric();
  if (metric_ecef) {
    set_has_metric_ecef();
    geographic_metric_.metric_ecef_ = metric_ecef;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric* PositionAndAccuracy::mutable_metric_ecef() {
  if (!has_metric_ecef()) {
    clear_geographic_metric();
    set_has_metric_ecef();
    geographic_metric_.metric_ecef_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.metric_ecef)
  return geographic_metric_.metric_ecef_;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void PositionAndAccuracy::set_has_combined_std_dev() {
  _oneof_case_[1] = kCombinedStdDev;
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::_internal_combined_std_dev() const {
  return *accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
      ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Int64Value& PositionAndAccuracy::combined_std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return has_combined_std_dev()
      ? *accuracy_.combined_std_dev_
      : *reinterpret_cast< ::google::protobuf::Int64Value*>(&::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
    ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  clear_accuracy();
  if (combined_std_dev) {
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* PositionAndAccuracy::mutable_combined_std_dev() {
  if (!has_combined_std_dev()) {
    clear_accuracy();
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = CreateMaybeMessage< ::google::protobuf::Int64Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.combined_std_dev)
  return accuracy_.combined_std_dev_;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalVerticalStdDev std_dev = 6;
inline bool PositionAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void PositionAndAccuracy::set_has_std_dev() {
  _oneof_case_[1] = kStdDev;
}
inline void PositionAndAccuracy::clear_std_dev() {
  if (has_std_dev()) {
    if (GetArenaNoVirtual() == NULL) {
      delete accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::_internal_std_dev() const {
  return *accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* temp = accuracy_.std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev& PositionAndAccuracy::std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return has_std_dev()
      ? *accuracy_.std_dev_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalVerticalStdDev_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* temp = accuracy_.std_dev_;
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* std_dev) {
  clear_accuracy();
  if (std_dev) {
    set_has_std_dev();
    accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev* PositionAndAccuracy::mutable_std_dev() {
  if (!has_std_dev()) {
    clear_accuracy();
    set_has_std_dev();
    accuracy_.std_dev_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalVerticalStdDev >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.std_dev)
  return accuracy_.std_dev_;
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy.HorizontalConfidenceEllipseVerticalStdDev horizontal_confidence_ellipse_vertical_std_dev = 7;
inline bool PositionAndAccuracy::has_horizontal_confidence_ellipse_vertical_std_dev() const {
  return accuracy_case() == kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::set_has_horizontal_confidence_ellipse_vertical_std_dev() {
  _oneof_case_[1] = kHorizontalConfidenceEllipseVerticalStdDev;
}
inline void PositionAndAccuracy::clear_horizontal_confidence_ellipse_vertical_std_dev() {
  if (has_horizontal_confidence_ellipse_vertical_std_dev()) {
    if (GetArenaNoVirtual() == NULL) {
      delete accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    }
    clear_has_accuracy();
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::_internal_horizontal_confidence_ellipse_vertical_std_dev() const {
  return *accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (has_horizontal_confidence_ellipse_vertical_std_dev()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* temp = accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev& PositionAndAccuracy::horizontal_confidence_ellipse_vertical_std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return has_horizontal_confidence_ellipse_vertical_std_dev()
      ? *accuracy_.horizontal_confidence_ellipse_vertical_std_dev_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev*>(&::sensoris::protobuf::types::spatial::_PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::unsafe_arena_release_horizontal_confidence_ellipse_vertical_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  if (has_horizontal_confidence_ellipse_vertical_std_dev()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* temp = accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
    accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_horizontal_confidence_ellipse_vertical_std_dev(::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* horizontal_confidence_ellipse_vertical_std_dev) {
  clear_accuracy();
  if (horizontal_confidence_ellipse_vertical_std_dev) {
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = horizontal_confidence_ellipse_vertical_std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev* PositionAndAccuracy::mutable_horizontal_confidence_ellipse_vertical_std_dev() {
  if (!has_horizontal_confidence_ellipse_vertical_std_dev()) {
    clear_accuracy();
    set_has_horizontal_confidence_ellipse_vertical_std_dev();
    accuracy_.horizontal_confidence_ellipse_vertical_std_dev_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PositionAndAccuracy_HorizontalConfidenceEllipseVerticalStdDev >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.horizontal_confidence_ellipse_vertical_std_dev)
  return accuracy_.horizontal_confidence_ellipse_vertical_std_dev_;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 8 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool PositionAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void PositionAndAccuracy::set_has_covariance() {
  _oneof_case_[1] = kCovariance;
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::_internal_covariance() const {
  return *accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& PositionAndAccuracy::covariance() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return has_covariance()
      ? *accuracy_.covariance_
      : *reinterpret_cast< ::sensoris::protobuf::types::base::Int64Matrix3x3*>(&::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void PositionAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  clear_accuracy();
  if (covariance) {
    set_has_covariance();
    accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* PositionAndAccuracy::mutable_covariance() {
  if (!has_covariance()) {
    clear_accuracy();
    set_has_covariance();
    accuracy_.covariance_ = CreateMaybeMessage< ::sensoris::protobuf::types::base::Int64Matrix3x3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.covariance)
  return accuracy_.covariance_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PositionAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* PositionAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
PositionAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& PositionAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* PositionAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
PositionAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PositionAndAccuracy.extension)
  return extension_;
}

inline bool PositionAndAccuracy::has_geographic_metric() const {
  return geographic_metric_case() != GEOGRAPHIC_METRIC_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_geographic_metric() {
  _oneof_case_[0] = GEOGRAPHIC_METRIC_NOT_SET;
}
inline bool PositionAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void PositionAndAccuracy::clear_has_accuracy() {
  _oneof_case_[1] = ACCURACY_NOT_SET;
}
inline PositionAndAccuracy::GeographicMetricCase PositionAndAccuracy::geographic_metric_case() const {
  return PositionAndAccuracy::GeographicMetricCase(_oneof_case_[0]);
}
inline PositionAndAccuracy::AccuracyCase PositionAndAccuracy::accuracy_case() const {
  return PositionAndAccuracy::AccuracyCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// PolylineAndAccuracy

// repeated .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline int PolylineAndAccuracy::position_and_accuracy_size() const {
  return position_and_accuracy_.size();
}
inline void PolylineAndAccuracy::clear_position_and_accuracy() {
  position_and_accuracy_.Clear();
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolylineAndAccuracy::mutable_position_and_accuracy(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return position_and_accuracy_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >*
PolylineAndAccuracy::mutable_position_and_accuracy() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return &position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& PolylineAndAccuracy::position_and_accuracy(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return position_and_accuracy_.Get(index);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* PolylineAndAccuracy::add_position_and_accuracy() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return position_and_accuracy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::types::spatial::PositionAndAccuracy >&
PolylineAndAccuracy::position_and_accuracy() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.position_and_accuracy)
  return position_and_accuracy_;
}

// repeated .google.protobuf.Any extension = 15;
inline int PolylineAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* PolylineAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
PolylineAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& PolylineAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* PolylineAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
PolylineAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.PolylineAndAccuracy.extension)
  return extension_;
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_StdDev

// .google.protobuf.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_StdDev::has_x() const {
  return this != internal_default_instance() && x_ != NULL;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_x() const {
  return *x_;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::x() const {
  const ::google::protobuf::Int64Value* p = x_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_x() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  
  ::google::protobuf::Int64Value* temp = x_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  x_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  
  ::google::protobuf::Int64Value* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_x() {
  
  if (x_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
  return x_;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_x(::google::protobuf::Int64Value* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(x_);
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.x)
}

// .google.protobuf.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_StdDev::has_y() const {
  return this != internal_default_instance() && y_ != NULL;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_y() const {
  return *y_;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::y() const {
  const ::google::protobuf::Int64Value* p = y_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_y() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  
  ::google::protobuf::Int64Value* temp = y_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  y_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  
  ::google::protobuf::Int64Value* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_y() {
  
  if (y_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
  return y_;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_y(::google::protobuf::Int64Value* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(y_);
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.y)
}

// .google.protobuf.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_StdDev::has_z() const {
  return this != internal_default_instance() && z_ != NULL;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::_internal_z() const {
  return *z_;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy_StdDev::z() const {
  const ::google::protobuf::Int64Value* p = z_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::release_z() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  
  ::google::protobuf::Int64Value* temp = z_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  z_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  
  ::google::protobuf::Int64Value* temp = z_;
  z_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy_StdDev::mutable_z() {
  
  if (z_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
  return z_;
}
inline void XyzVectorAndAccuracy_StdDev::set_allocated_z(::google::protobuf::Int64Value* z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(z_);
  }
  if (z) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(z)->GetArena();
    if (message_arena != submessage_arena) {
      z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy_Metric

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_Metric::has_x() const {
  return this != internal_default_instance() && x_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_x() const {
  return *x_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::x() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = x_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_x() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_x() {
  
  if (x_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
  return x_;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(x_);
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_Metric::has_y() const {
  return this != internal_default_instance() && y_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_y() const {
  return *y_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::y() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = y_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_y() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_y() {
  
  if (y_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
  return y_;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(y_);
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy_Metric::has_z() const {
  return this != internal_default_instance() && z_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::_internal_z() const {
  return *z_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& XyzVectorAndAccuracy_Metric::z() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = z_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::release_z() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* XyzVectorAndAccuracy_Metric::mutable_z() {
  
  if (z_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
  return z_;
}
inline void XyzVectorAndAccuracy_Metric::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(z_);
  }
  if (z) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(z)->GetArena();
    if (message_arena != submessage_arena) {
      z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric.z)
}

// -------------------------------------------------------------------

// XyzVectorAndAccuracy

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_vehicle = 1;
inline bool XyzVectorAndAccuracy::has_metric_vehicle() const {
  return geometry_case() == kMetricVehicle;
}
inline void XyzVectorAndAccuracy::set_has_metric_vehicle() {
  _oneof_case_[0] = kMetricVehicle;
}
inline void XyzVectorAndAccuracy::clear_metric_vehicle() {
  if (has_metric_vehicle()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geometry_.metric_vehicle_;
    }
    clear_has_geometry();
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_vehicle() const {
  return *geometry_.metric_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (has_metric_vehicle()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_vehicle_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.metric_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_vehicle() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return has_metric_vehicle()
      ? *geometry_.metric_vehicle_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  if (has_metric_vehicle()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_vehicle_;
    geometry_.metric_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_vehicle(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_vehicle) {
  clear_geometry();
  if (metric_vehicle) {
    set_has_metric_vehicle();
    geometry_.metric_vehicle_ = metric_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_vehicle() {
  if (!has_metric_vehicle()) {
    clear_geometry();
    set_has_metric_vehicle();
    geometry_.metric_vehicle_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_vehicle)
  return geometry_.metric_vehicle_;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_event_group = 2;
inline bool XyzVectorAndAccuracy::has_metric_event_group() const {
  return geometry_case() == kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::set_has_metric_event_group() {
  _oneof_case_[0] = kMetricEventGroup;
}
inline void XyzVectorAndAccuracy::clear_metric_event_group() {
  if (has_metric_event_group()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geometry_.metric_event_group_;
    }
    clear_has_geometry();
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_event_group() const {
  return *geometry_.metric_event_group_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (has_metric_event_group()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_event_group_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.metric_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_event_group() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return has_metric_event_group()
      ? *geometry_.metric_event_group_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  if (has_metric_event_group()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_event_group_;
    geometry_.metric_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_event_group(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_event_group) {
  clear_geometry();
  if (metric_event_group) {
    set_has_metric_event_group();
    geometry_.metric_event_group_ = metric_event_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_event_group() {
  if (!has_metric_event_group()) {
    clear_geometry();
    set_has_metric_event_group();
    geometry_.metric_event_group_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_event_group)
  return geometry_.metric_event_group_;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.Metric metric_origin = 3;
inline bool XyzVectorAndAccuracy::has_metric_origin() const {
  return geometry_case() == kMetricOrigin;
}
inline void XyzVectorAndAccuracy::set_has_metric_origin() {
  _oneof_case_[0] = kMetricOrigin;
}
inline void XyzVectorAndAccuracy::clear_metric_origin() {
  if (has_metric_origin()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geometry_.metric_origin_;
    }
    clear_has_geometry();
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::_internal_metric_origin() const {
  return *geometry_.metric_origin_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::release_metric_origin() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (has_metric_origin()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_origin_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.metric_origin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric& XyzVectorAndAccuracy::metric_origin() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return has_metric_origin()
      ? *geometry_.metric_origin_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric*>(&::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_Metric_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::unsafe_arena_release_metric_origin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  if (has_metric_origin()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* temp = geometry_.metric_origin_;
    geometry_.metric_origin_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_metric_origin(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* metric_origin) {
  clear_geometry();
  if (metric_origin) {
    set_has_metric_origin();
    geometry_.metric_origin_ = metric_origin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric* XyzVectorAndAccuracy::mutable_metric_origin() {
  if (!has_metric_origin()) {
    clear_geometry();
    set_has_metric_origin();
    geometry_.metric_origin_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_Metric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.metric_origin)
  return geometry_.metric_origin_;
}

// .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void XyzVectorAndAccuracy::set_has_combined_std_dev() {
  _oneof_case_[1] = kCombinedStdDev;
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::_internal_combined_std_dev() const {
  return *accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
      ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Int64Value& XyzVectorAndAccuracy::combined_std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return has_combined_std_dev()
      ? *accuracy_.combined_std_dev_
      : *reinterpret_cast< ::google::protobuf::Int64Value*>(&::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
    ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  clear_accuracy();
  if (combined_std_dev) {
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* XyzVectorAndAccuracy::mutable_combined_std_dev() {
  if (!has_combined_std_dev()) {
    clear_accuracy();
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = CreateMaybeMessage< ::google::protobuf::Int64Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.combined_std_dev)
  return accuracy_.combined_std_dev_;
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.StdDev std_dev = 5;
inline bool XyzVectorAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void XyzVectorAndAccuracy::set_has_std_dev() {
  _oneof_case_[1] = kStdDev;
}
inline void XyzVectorAndAccuracy::clear_std_dev() {
  if (has_std_dev()) {
    if (GetArenaNoVirtual() == NULL) {
      delete accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::_internal_std_dev() const {
  return *accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev& XyzVectorAndAccuracy::std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return has_std_dev()
      ? *accuracy_.std_dev_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev*>(&::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_StdDev_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* std_dev) {
  clear_accuracy();
  if (std_dev) {
    set_has_std_dev();
    accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev* XyzVectorAndAccuracy::mutable_std_dev() {
  if (!has_std_dev()) {
    clear_accuracy();
    set_has_std_dev();
    accuracy_.std_dev_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy_StdDev >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.std_dev)
  return accuracy_.std_dev_;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool XyzVectorAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void XyzVectorAndAccuracy::set_has_covariance() {
  _oneof_case_[1] = kCovariance;
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::_internal_covariance() const {
  return *accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& XyzVectorAndAccuracy::covariance() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return has_covariance()
      ? *accuracy_.covariance_
      : *reinterpret_cast< ::sensoris::protobuf::types::base::Int64Matrix3x3*>(&::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void XyzVectorAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  clear_accuracy();
  if (covariance) {
    set_has_covariance();
    accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* XyzVectorAndAccuracy::mutable_covariance() {
  if (!has_covariance()) {
    clear_accuracy();
    set_has_covariance();
    accuracy_.covariance_ = CreateMaybeMessage< ::sensoris::protobuf::types::base::Int64Matrix3x3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.covariance)
  return accuracy_.covariance_;
}

// repeated .google.protobuf.Any extension = 15;
inline int XyzVectorAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* XyzVectorAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
XyzVectorAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& XyzVectorAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* XyzVectorAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
XyzVectorAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.XyzVectorAndAccuracy.extension)
  return extension_;
}

inline bool XyzVectorAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool XyzVectorAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void XyzVectorAndAccuracy::clear_has_accuracy() {
  _oneof_case_[1] = ACCURACY_NOT_SET;
}
inline XyzVectorAndAccuracy::GeometryCase XyzVectorAndAccuracy::geometry_case() const {
  return XyzVectorAndAccuracy::GeometryCase(_oneof_case_[0]);
}
inline XyzVectorAndAccuracy::AccuracyCase XyzVectorAndAccuracy::accuracy_case() const {
  return XyzVectorAndAccuracy::AccuracyCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CornerVectors

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy first_and_accuracy = 1;
inline bool RectangularBoxAndAccuracy_CornerVectors::has_first_and_accuracy() const {
  return this != internal_default_instance() && first_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_first_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && first_and_accuracy_ != NULL) {
    delete first_and_accuracy_;
  }
  first_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_first_and_accuracy() const {
  return *first_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::first_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = first_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_first_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = first_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  first_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_first_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = first_and_accuracy_;
  first_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_first_and_accuracy() {
  
  if (first_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    first_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
  return first_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_first_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* first_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete first_and_accuracy_;
  }
  if (first_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(first_and_accuracy);
    if (message_arena != submessage_arena) {
      first_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, first_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  first_and_accuracy_ = first_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.first_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy second_and_accuracy = 2;
inline bool RectangularBoxAndAccuracy_CornerVectors::has_second_and_accuracy() const {
  return this != internal_default_instance() && second_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_second_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && second_and_accuracy_ != NULL) {
    delete second_and_accuracy_;
  }
  second_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_second_and_accuracy() const {
  return *second_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::second_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = second_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_second_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = second_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  second_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_second_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = second_and_accuracy_;
  second_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_second_and_accuracy() {
  
  if (second_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    second_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
  return second_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_second_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* second_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete second_and_accuracy_;
  }
  if (second_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(second_and_accuracy);
    if (message_arena != submessage_arena) {
      second_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, second_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  second_and_accuracy_ = second_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.second_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy third_and_accuracy = 3;
inline bool RectangularBoxAndAccuracy_CornerVectors::has_third_and_accuracy() const {
  return this != internal_default_instance() && third_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CornerVectors::clear_third_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && third_and_accuracy_ != NULL) {
    delete third_and_accuracy_;
  }
  third_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::_internal_third_and_accuracy() const {
  return *third_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CornerVectors::third_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = third_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::release_third_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = third_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  third_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::unsafe_arena_release_third_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = third_and_accuracy_;
  third_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CornerVectors::mutable_third_and_accuracy() {
  
  if (third_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    third_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
  return third_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CornerVectors::set_allocated_third_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* third_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete third_and_accuracy_;
  }
  if (third_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(third_and_accuracy);
    if (message_arena != submessage_arena) {
      third_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, third_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  third_and_accuracy_ = third_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors.third_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy_CenterOrientationSize

// .sensoris.protobuf.types.spatial.PositionAndAccuracy center_position_and_accuracy = 1;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_center_position_and_accuracy() const {
  return this != internal_default_instance() && center_position_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_center_position_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && center_position_and_accuracy_ != NULL) {
    delete center_position_and_accuracy_;
  }
  center_position_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_center_position_and_accuracy() const {
  return *center_position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::center_position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = center_position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_center_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = center_position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  center_position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_center_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = center_position_and_accuracy_;
  center_position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_center_position_and_accuracy() {
  
  if (center_position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    center_position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
  return center_position_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_center_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* center_position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete center_position_and_accuracy_;
  }
  if (center_position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(center_position_and_accuracy);
    if (message_arena != submessage_arena) {
      center_position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, center_position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  center_position_and_accuracy_ = center_position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.center_position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 2;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_orientation_and_accuracy() const {
  return this != internal_default_instance() && orientation_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_orientation_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && orientation_and_accuracy_ != NULL) {
    delete orientation_and_accuracy_;
  }
  orientation_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_orientation_and_accuracy() const {
  return *orientation_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::orientation_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = orientation_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_orientation_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = orientation_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  orientation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_orientation_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = orientation_and_accuracy_;
  orientation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_orientation_and_accuracy() {
  
  if (orientation_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArenaNoVirtual());
    orientation_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
  return orientation_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_and_accuracy_;
  }
  if (orientation_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(orientation_and_accuracy);
    if (message_arena != submessage_arena) {
      orientation_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  orientation_and_accuracy_ = orientation_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.orientation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy size_and_accuracy = 3;
inline bool RectangularBoxAndAccuracy_CenterOrientationSize::has_size_and_accuracy() const {
  return this != internal_default_instance() && size_and_accuracy_ != NULL;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::clear_size_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && size_and_accuracy_ != NULL) {
    delete size_and_accuracy_;
  }
  size_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::_internal_size_and_accuracy() const {
  return *size_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& RectangularBoxAndAccuracy_CenterOrientationSize::size_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = size_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::release_size_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = size_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  size_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::unsafe_arena_release_size_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = size_and_accuracy_;
  size_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* RectangularBoxAndAccuracy_CenterOrientationSize::mutable_size_and_accuracy() {
  
  if (size_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    size_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
  return size_and_accuracy_;
}
inline void RectangularBoxAndAccuracy_CenterOrientationSize::set_allocated_size_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* size_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete size_and_accuracy_;
  }
  if (size_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(size_and_accuracy);
    if (message_arena != submessage_arena) {
      size_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, size_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  size_and_accuracy_ = size_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize.size_and_accuracy)
}

// -------------------------------------------------------------------

// RectangularBoxAndAccuracy

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CornerVectors corner_vectors = 1;
inline bool RectangularBoxAndAccuracy::has_corner_vectors() const {
  return geometry_case() == kCornerVectors;
}
inline void RectangularBoxAndAccuracy::set_has_corner_vectors() {
  _oneof_case_[0] = kCornerVectors;
}
inline void RectangularBoxAndAccuracy::clear_corner_vectors() {
  if (has_corner_vectors()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geometry_.corner_vectors_;
    }
    clear_has_geometry();
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::_internal_corner_vectors() const {
  return *geometry_.corner_vectors_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::release_corner_vectors() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (has_corner_vectors()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* temp = geometry_.corner_vectors_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.corner_vectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors& RectangularBoxAndAccuracy::corner_vectors() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return has_corner_vectors()
      ? *geometry_.corner_vectors_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors*>(&::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CornerVectors_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::unsafe_arena_release_corner_vectors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  if (has_corner_vectors()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* temp = geometry_.corner_vectors_;
    geometry_.corner_vectors_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_corner_vectors(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* corner_vectors) {
  clear_geometry();
  if (corner_vectors) {
    set_has_corner_vectors();
    geometry_.corner_vectors_ = corner_vectors;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors* RectangularBoxAndAccuracy::mutable_corner_vectors() {
  if (!has_corner_vectors()) {
    clear_geometry();
    set_has_corner_vectors();
    geometry_.corner_vectors_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CornerVectors >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.corner_vectors)
  return geometry_.corner_vectors_;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.CenterOrientationSize center_orientation_size = 2;
inline bool RectangularBoxAndAccuracy::has_center_orientation_size() const {
  return geometry_case() == kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::set_has_center_orientation_size() {
  _oneof_case_[0] = kCenterOrientationSize;
}
inline void RectangularBoxAndAccuracy::clear_center_orientation_size() {
  if (has_center_orientation_size()) {
    if (GetArenaNoVirtual() == NULL) {
      delete geometry_.center_orientation_size_;
    }
    clear_has_geometry();
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::_internal_center_orientation_size() const {
  return *geometry_.center_orientation_size_;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::release_center_orientation_size() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (has_center_orientation_size()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* temp = geometry_.center_orientation_size_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.center_orientation_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize& RectangularBoxAndAccuracy::center_orientation_size() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return has_center_orientation_size()
      ? *geometry_.center_orientation_size_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize*>(&::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_CenterOrientationSize_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::unsafe_arena_release_center_orientation_size() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  if (has_center_orientation_size()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* temp = geometry_.center_orientation_size_;
    geometry_.center_orientation_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RectangularBoxAndAccuracy::unsafe_arena_set_allocated_center_orientation_size(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* center_orientation_size) {
  clear_geometry();
  if (center_orientation_size) {
    set_has_center_orientation_size();
    geometry_.center_orientation_size_ = center_orientation_size;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize* RectangularBoxAndAccuracy::mutable_center_orientation_size() {
  if (!has_center_orientation_size()) {
    clear_geometry();
    set_has_center_orientation_size();
    geometry_.center_orientation_size_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy_CenterOrientationSize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.center_orientation_size)
  return geometry_.center_orientation_size_;
}

// repeated .google.protobuf.Any extension = 15;
inline int RectangularBoxAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* RectangularBoxAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
RectangularBoxAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& RectangularBoxAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* RectangularBoxAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
RectangularBoxAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy.extension)
  return extension_;
}

inline bool RectangularBoxAndAccuracy::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void RectangularBoxAndAccuracy::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline RectangularBoxAndAccuracy::GeometryCase RectangularBoxAndAccuracy::geometry_case() const {
  return RectangularBoxAndAccuracy::GeometryCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RotationAndAccuracy_Euler

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_yaw() const {
  return this != internal_default_instance() && yaw_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_yaw() const {
  return *yaw_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::yaw() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = yaw_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_yaw() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = yaw_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  yaw_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_yaw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_yaw() {
  
  if (yaw_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
  return yaw_;
}
inline void RotationAndAccuracy_Euler::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(yaw)->GetArena();
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_pitch() const {
  return this != internal_default_instance() && pitch_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_pitch() const {
  return *pitch_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::pitch() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = pitch_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_pitch() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pitch_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pitch_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_pitch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_pitch() {
  
  if (pitch_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
  return pitch_;
}
inline void RotationAndAccuracy_Euler::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pitch)->GetArena();
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_Euler::has_roll() const {
  return this != internal_default_instance() && roll_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::_internal_roll() const {
  return *roll_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Euler::roll() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = roll_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::release_roll() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = roll_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  roll_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::unsafe_arena_release_roll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Euler::mutable_roll() {
  
  if (roll_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
  return roll_;
}
inline void RotationAndAccuracy_Euler::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(roll)->GetArena();
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_Quaternion

// .sensoris.protobuf.types.base.Int64Value x = 1 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_x() const {
  return this != internal_default_instance() && x_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_x() const {
  return *x_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::x() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = x_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_x() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = x_;
  x_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_x() {
  
  if (x_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
  return x_;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_x(::sensoris::protobuf::types::base::Int64Value* x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(x_);
  }
  if (x) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(x)->GetArena();
    if (message_arena != submessage_arena) {
      x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    
  } else {
    
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.x)
}

// .sensoris.protobuf.types.base.Int64Value y = 2 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_y() const {
  return this != internal_default_instance() && y_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_y() const {
  return *y_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::y() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = y_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_y() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = y_;
  y_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_y() {
  
  if (y_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    y_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
  return y_;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_y(::sensoris::protobuf::types::base::Int64Value* y) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(y_);
  }
  if (y) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(y)->GetArena();
    if (message_arena != submessage_arena) {
      y = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    
  } else {
    
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.y)
}

// .sensoris.protobuf.types.base.Int64Value z = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_z() const {
  return this != internal_default_instance() && z_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_z() const {
  return *z_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::z() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = z_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_z() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_z() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = z_;
  z_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_z() {
  
  if (z_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    z_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
  return z_;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_z(::sensoris::protobuf::types::base::Int64Value* z) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(z_);
  }
  if (z) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(z)->GetArena();
    if (message_arena != submessage_arena) {
      z = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z, submessage_arena);
    }
    
  } else {
    
  }
  z_ = z;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.z)
}

// .sensoris.protobuf.types.base.Int64Value w = 4 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool RotationAndAccuracy_Quaternion::has_w() const {
  return this != internal_default_instance() && w_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::_internal_w() const {
  return *w_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationAndAccuracy_Quaternion::w() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = w_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::release_w() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = w_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  w_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::unsafe_arena_release_w() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = w_;
  w_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationAndAccuracy_Quaternion::mutable_w() {
  
  if (w_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    w_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
  return w_;
}
inline void RotationAndAccuracy_Quaternion::set_allocated_w(::sensoris::protobuf::types::base::Int64Value* w) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(w_);
  }
  if (w) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(w)->GetArena();
    if (message_arena != submessage_arena) {
      w = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, w, submessage_arena);
    }
    
  } else {
    
  }
  w_ = w;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion.w)
}

// -------------------------------------------------------------------

// RotationAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_yaw() const {
  return this != internal_default_instance() && yaw_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_yaw() const {
  return *yaw_;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::yaw() const {
  const ::google::protobuf::Int64Value* p = yaw_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_yaw() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  
  ::google::protobuf::Int64Value* temp = yaw_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  yaw_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  
  ::google::protobuf::Int64Value* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_yaw() {
  
  if (yaw_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
  return yaw_;
}
inline void RotationAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(yaw)->GetArena();
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_pitch() const {
  return this != internal_default_instance() && pitch_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_pitch() const {
  return *pitch_;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::pitch() const {
  const ::google::protobuf::Int64Value* p = pitch_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_pitch() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  
  ::google::protobuf::Int64Value* temp = pitch_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pitch_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  
  ::google::protobuf::Int64Value* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_pitch() {
  
  if (pitch_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
  return pitch_;
}
inline void RotationAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pitch)->GetArena();
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy_StdDev::has_roll() const {
  return this != internal_default_instance() && roll_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::_internal_roll() const {
  return *roll_;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy_StdDev::roll() const {
  const ::google::protobuf::Int64Value* p = roll_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::release_roll() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  
  ::google::protobuf::Int64Value* temp = roll_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  roll_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::unsafe_arena_release_roll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  
  ::google::protobuf::Int64Value* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy_StdDev::mutable_roll() {
  
  if (roll_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
  return roll_;
}
inline void RotationAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(roll)->GetArena();
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationAndAccuracy

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_vehicle = 1;
inline bool RotationAndAccuracy::has_euler_vehicle() const {
  return euler_quaternion_case() == kEulerVehicle;
}
inline void RotationAndAccuracy::set_has_euler_vehicle() {
  _oneof_case_[0] = kEulerVehicle;
}
inline void RotationAndAccuracy::clear_euler_vehicle() {
  if (has_euler_vehicle()) {
    if (GetArenaNoVirtual() == NULL) {
      delete euler_quaternion_.euler_vehicle_;
    }
    clear_has_euler_quaternion();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_vehicle() const {
  return *euler_quaternion_.euler_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::release_euler_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (has_euler_vehicle()) {
    clear_has_euler_quaternion();
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* temp = euler_quaternion_.euler_vehicle_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    euler_quaternion_.euler_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_vehicle() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return has_euler_vehicle()
      ? *euler_quaternion_.euler_vehicle_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(&::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::unsafe_arena_release_euler_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  if (has_euler_vehicle()) {
    clear_has_euler_quaternion();
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* temp = euler_quaternion_.euler_vehicle_;
    euler_quaternion_.euler_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_vehicle) {
  clear_euler_quaternion();
  if (euler_vehicle) {
    set_has_euler_vehicle();
    euler_quaternion_.euler_vehicle_ = euler_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::mutable_euler_vehicle() {
  if (!has_euler_vehicle()) {
    clear_euler_quaternion();
    set_has_euler_vehicle();
    euler_quaternion_.euler_vehicle_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_vehicle)
  return euler_quaternion_.euler_vehicle_;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Euler euler_event_group = 2;
inline bool RotationAndAccuracy::has_euler_event_group() const {
  return euler_quaternion_case() == kEulerEventGroup;
}
inline void RotationAndAccuracy::set_has_euler_event_group() {
  _oneof_case_[0] = kEulerEventGroup;
}
inline void RotationAndAccuracy::clear_euler_event_group() {
  if (has_euler_event_group()) {
    if (GetArenaNoVirtual() == NULL) {
      delete euler_quaternion_.euler_event_group_;
    }
    clear_has_euler_quaternion();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::_internal_euler_event_group() const {
  return *euler_quaternion_.euler_event_group_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::release_euler_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (has_euler_event_group()) {
    clear_has_euler_quaternion();
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* temp = euler_quaternion_.euler_event_group_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    euler_quaternion_.euler_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler& RotationAndAccuracy::euler_event_group() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return has_euler_event_group()
      ? *euler_quaternion_.euler_event_group_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler*>(&::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Euler_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::unsafe_arena_release_euler_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  if (has_euler_event_group()) {
    clear_has_euler_quaternion();
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* temp = euler_quaternion_.euler_event_group_;
    euler_quaternion_.euler_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_euler_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* euler_event_group) {
  clear_euler_quaternion();
  if (euler_event_group) {
    set_has_euler_event_group();
    euler_quaternion_.euler_event_group_ = euler_event_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler* RotationAndAccuracy::mutable_euler_event_group() {
  if (!has_euler_event_group()) {
    clear_euler_quaternion();
    set_has_euler_event_group();
    euler_quaternion_.euler_event_group_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Euler >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.euler_event_group)
  return euler_quaternion_.euler_event_group_;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_vehicle = 3;
inline bool RotationAndAccuracy::has_quaternion_vehicle() const {
  return euler_quaternion_case() == kQuaternionVehicle;
}
inline void RotationAndAccuracy::set_has_quaternion_vehicle() {
  _oneof_case_[0] = kQuaternionVehicle;
}
inline void RotationAndAccuracy::clear_quaternion_vehicle() {
  if (has_quaternion_vehicle()) {
    if (GetArenaNoVirtual() == NULL) {
      delete euler_quaternion_.quaternion_vehicle_;
    }
    clear_has_euler_quaternion();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_vehicle() const {
  return *euler_quaternion_.quaternion_vehicle_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (has_quaternion_vehicle()) {
    clear_has_euler_quaternion();
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* temp = euler_quaternion_.quaternion_vehicle_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    euler_quaternion_.quaternion_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_vehicle() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return has_quaternion_vehicle()
      ? *euler_quaternion_.quaternion_vehicle_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(&::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::unsafe_arena_release_quaternion_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  if (has_quaternion_vehicle()) {
    clear_has_euler_quaternion();
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* temp = euler_quaternion_.quaternion_vehicle_;
    euler_quaternion_.quaternion_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_vehicle(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_vehicle) {
  clear_euler_quaternion();
  if (quaternion_vehicle) {
    set_has_quaternion_vehicle();
    euler_quaternion_.quaternion_vehicle_ = quaternion_vehicle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::mutable_quaternion_vehicle() {
  if (!has_quaternion_vehicle()) {
    clear_euler_quaternion();
    set_has_quaternion_vehicle();
    euler_quaternion_.quaternion_vehicle_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_vehicle)
  return euler_quaternion_.quaternion_vehicle_;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.Quaternion quaternion_event_group = 4;
inline bool RotationAndAccuracy::has_quaternion_event_group() const {
  return euler_quaternion_case() == kQuaternionEventGroup;
}
inline void RotationAndAccuracy::set_has_quaternion_event_group() {
  _oneof_case_[0] = kQuaternionEventGroup;
}
inline void RotationAndAccuracy::clear_quaternion_event_group() {
  if (has_quaternion_event_group()) {
    if (GetArenaNoVirtual() == NULL) {
      delete euler_quaternion_.quaternion_event_group_;
    }
    clear_has_euler_quaternion();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::_internal_quaternion_event_group() const {
  return *euler_quaternion_.quaternion_event_group_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::release_quaternion_event_group() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (has_quaternion_event_group()) {
    clear_has_euler_quaternion();
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* temp = euler_quaternion_.quaternion_event_group_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    euler_quaternion_.quaternion_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion& RotationAndAccuracy::quaternion_event_group() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return has_quaternion_event_group()
      ? *euler_quaternion_.quaternion_event_group_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion*>(&::sensoris::protobuf::types::spatial::_RotationAndAccuracy_Quaternion_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::unsafe_arena_release_quaternion_event_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  if (has_quaternion_event_group()) {
    clear_has_euler_quaternion();
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* temp = euler_quaternion_.quaternion_event_group_;
    euler_quaternion_.quaternion_event_group_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_quaternion_event_group(::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* quaternion_event_group) {
  clear_euler_quaternion();
  if (quaternion_event_group) {
    set_has_quaternion_event_group();
    euler_quaternion_.quaternion_event_group_ = quaternion_event_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion* RotationAndAccuracy::mutable_quaternion_event_group() {
  if (!has_quaternion_event_group()) {
    clear_euler_quaternion();
    set_has_quaternion_event_group();
    euler_quaternion_.quaternion_event_group_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_Quaternion >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.quaternion_event_group)
  return euler_quaternion_.quaternion_event_group_;
}

// .google.protobuf.Int64Value combined_std_dev = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationAndAccuracy::set_has_combined_std_dev() {
  _oneof_case_[1] = kCombinedStdDev;
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::_internal_combined_std_dev() const {
  return *accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
      ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Int64Value& RotationAndAccuracy::combined_std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return has_combined_std_dev()
      ? *accuracy_.combined_std_dev_
      : *reinterpret_cast< ::google::protobuf::Int64Value*>(&::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
    ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  clear_accuracy();
  if (combined_std_dev) {
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* RotationAndAccuracy::mutable_combined_std_dev() {
  if (!has_combined_std_dev()) {
    clear_accuracy();
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = CreateMaybeMessage< ::google::protobuf::Int64Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.combined_std_dev)
  return accuracy_.combined_std_dev_;
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy.StdDev std_dev = 6;
inline bool RotationAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationAndAccuracy::set_has_std_dev() {
  _oneof_case_[1] = kStdDev;
}
inline void RotationAndAccuracy::clear_std_dev() {
  if (has_std_dev()) {
    if (GetArenaNoVirtual() == NULL) {
      delete accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::_internal_std_dev() const {
  return *accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev& RotationAndAccuracy::std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return has_std_dev()
      ? *accuracy_.std_dev_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev*>(&::sensoris::protobuf::types::spatial::_RotationAndAccuracy_StdDev_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* std_dev) {
  clear_accuracy();
  if (std_dev) {
    set_has_std_dev();
    accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev* RotationAndAccuracy::mutable_std_dev() {
  if (!has_std_dev()) {
    clear_accuracy();
    set_has_std_dev();
    accuracy_.std_dev_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationAndAccuracy_StdDev >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.std_dev)
  return accuracy_.std_dev_;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 7 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationAndAccuracy::set_has_covariance() {
  _oneof_case_[1] = kCovariance;
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::_internal_covariance() const {
  return *accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationAndAccuracy::covariance() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return has_covariance()
      ? *accuracy_.covariance_
      : *reinterpret_cast< ::sensoris::protobuf::types::base::Int64Matrix3x3*>(&::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  clear_accuracy();
  if (covariance) {
    set_has_covariance();
    accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationAndAccuracy::mutable_covariance() {
  if (!has_covariance()) {
    clear_accuracy();
    set_has_covariance();
    accuracy_.covariance_ = CreateMaybeMessage< ::sensoris::protobuf::types::base::Int64Matrix3x3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.covariance)
  return accuracy_.covariance_;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* RotationAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
RotationAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& RotationAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* RotationAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
RotationAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationAndAccuracy.extension)
  return extension_;
}

inline bool RotationAndAccuracy::has_euler_quaternion() const {
  return euler_quaternion_case() != EULER_QUATERNION_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_euler_quaternion() {
  _oneof_case_[0] = EULER_QUATERNION_NOT_SET;
}
inline bool RotationAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationAndAccuracy::clear_has_accuracy() {
  _oneof_case_[1] = ACCURACY_NOT_SET;
}
inline RotationAndAccuracy::EulerQuaternionCase RotationAndAccuracy::euler_quaternion_case() const {
  return RotationAndAccuracy::EulerQuaternionCase(_oneof_case_[0]);
}
inline RotationAndAccuracy::AccuracyCase RotationAndAccuracy::accuracy_case() const {
  return RotationAndAccuracy::AccuracyCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// RotationRateAndAccuracy_StdDev

// .google.protobuf.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_yaw() const {
  return this != internal_default_instance() && yaw_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_yaw() const {
  return *yaw_;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::yaw() const {
  const ::google::protobuf::Int64Value* p = yaw_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_yaw() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  
  ::google::protobuf::Int64Value* temp = yaw_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  yaw_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_yaw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  
  ::google::protobuf::Int64Value* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_yaw() {
  
  if (yaw_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
  return yaw_;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_yaw(::google::protobuf::Int64Value* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(yaw)->GetArena();
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.yaw)
}

// .google.protobuf.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_pitch() const {
  return this != internal_default_instance() && pitch_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_pitch() const {
  return *pitch_;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::pitch() const {
  const ::google::protobuf::Int64Value* p = pitch_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_pitch() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  
  ::google::protobuf::Int64Value* temp = pitch_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pitch_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_pitch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  
  ::google::protobuf::Int64Value* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_pitch() {
  
  if (pitch_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
  return pitch_;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_pitch(::google::protobuf::Int64Value* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pitch)->GetArena();
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.pitch)
}

// .google.protobuf.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy_StdDev::has_roll() const {
  return this != internal_default_instance() && roll_ != NULL;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::_internal_roll() const {
  return *roll_;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy_StdDev::roll() const {
  const ::google::protobuf::Int64Value* p = roll_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::release_roll() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  
  ::google::protobuf::Int64Value* temp = roll_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  roll_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::unsafe_arena_release_roll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  
  ::google::protobuf::Int64Value* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy_StdDev::mutable_roll() {
  
  if (roll_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
  return roll_;
}
inline void RotationRateAndAccuracy_StdDev::set_allocated_roll(::google::protobuf::Int64Value* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(roll)->GetArena();
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev.roll)
}

// -------------------------------------------------------------------

// RotationRateAndAccuracy

// .sensoris.protobuf.types.base.Int64Value yaw = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_yaw() const {
  return this != internal_default_instance() && yaw_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_yaw() const {
  return *yaw_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::yaw() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = yaw_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_yaw() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = yaw_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  yaw_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_yaw() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = yaw_;
  yaw_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_yaw() {
  
  if (yaw_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    yaw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
  return yaw_;
}
inline void RotationRateAndAccuracy::set_allocated_yaw(::sensoris::protobuf::types::base::Int64Value* yaw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(yaw_);
  }
  if (yaw) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(yaw)->GetArena();
    if (message_arena != submessage_arena) {
      yaw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, yaw, submessage_arena);
    }
    
  } else {
    
  }
  yaw_ = yaw;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.yaw)
}

// .sensoris.protobuf.types.base.Int64Value pitch = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_pitch() const {
  return this != internal_default_instance() && pitch_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_pitch() const {
  return *pitch_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::pitch() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = pitch_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_pitch() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pitch_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pitch_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_pitch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pitch_;
  pitch_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_pitch() {
  
  if (pitch_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    pitch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
  return pitch_;
}
inline void RotationRateAndAccuracy::set_allocated_pitch(::sensoris::protobuf::types::base::Int64Value* pitch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pitch_);
  }
  if (pitch) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pitch)->GetArena();
    if (message_arena != submessage_arena) {
      pitch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pitch, submessage_arena);
    }
    
  } else {
    
  }
  pitch_ = pitch;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.pitch)
}

// .sensoris.protobuf.types.base.Int64Value roll = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_roll() const {
  return this != internal_default_instance() && roll_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::_internal_roll() const {
  return *roll_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& RotationRateAndAccuracy::roll() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = roll_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::release_roll() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = roll_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  roll_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_roll() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = roll_;
  roll_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* RotationRateAndAccuracy::mutable_roll() {
  
  if (roll_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    roll_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
  return roll_;
}
inline void RotationRateAndAccuracy::set_allocated_roll(::sensoris::protobuf::types::base::Int64Value* roll) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(roll_);
  }
  if (roll) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(roll)->GetArena();
    if (message_arena != submessage_arena) {
      roll = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roll, submessage_arena);
    }
    
  } else {
    
  }
  roll_ = roll;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.roll)
}

// .google.protobuf.Int64Value combined_std_dev = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_combined_std_dev() const {
  return accuracy_case() == kCombinedStdDev;
}
inline void RotationRateAndAccuracy::set_has_combined_std_dev() {
  _oneof_case_[0] = kCombinedStdDev;
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::_internal_combined_std_dev() const {
  return *accuracy_.combined_std_dev_;
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::release_combined_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
      ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::google::protobuf::Int64Value& RotationRateAndAccuracy::combined_std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return has_combined_std_dev()
      ? *accuracy_.combined_std_dev_
      : *reinterpret_cast< ::google::protobuf::Int64Value*>(&::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::unsafe_arena_release_combined_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  if (has_combined_std_dev()) {
    clear_has_accuracy();
    ::google::protobuf::Int64Value* temp = accuracy_.combined_std_dev_;
    accuracy_.combined_std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_combined_std_dev(::google::protobuf::Int64Value* combined_std_dev) {
  clear_accuracy();
  if (combined_std_dev) {
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = combined_std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
}
inline ::google::protobuf::Int64Value* RotationRateAndAccuracy::mutable_combined_std_dev() {
  if (!has_combined_std_dev()) {
    clear_accuracy();
    set_has_combined_std_dev();
    accuracy_.combined_std_dev_ = CreateMaybeMessage< ::google::protobuf::Int64Value >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.combined_std_dev)
  return accuracy_.combined_std_dev_;
}

// .sensoris.protobuf.types.spatial.RotationRateAndAccuracy.StdDev std_dev = 5;
inline bool RotationRateAndAccuracy::has_std_dev() const {
  return accuracy_case() == kStdDev;
}
inline void RotationRateAndAccuracy::set_has_std_dev() {
  _oneof_case_[0] = kStdDev;
}
inline void RotationRateAndAccuracy::clear_std_dev() {
  if (has_std_dev()) {
    if (GetArenaNoVirtual() == NULL) {
      delete accuracy_.std_dev_;
    }
    clear_has_accuracy();
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::_internal_std_dev() const {
  return *accuracy_.std_dev_;
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::release_std_dev() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev& RotationRateAndAccuracy::std_dev() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return has_std_dev()
      ? *accuracy_.std_dev_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev*>(&::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_StdDev_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::unsafe_arena_release_std_dev() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  if (has_std_dev()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* temp = accuracy_.std_dev_;
    accuracy_.std_dev_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_std_dev(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* std_dev) {
  clear_accuracy();
  if (std_dev) {
    set_has_std_dev();
    accuracy_.std_dev_ = std_dev;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev* RotationRateAndAccuracy::mutable_std_dev() {
  if (!has_std_dev()) {
    clear_accuracy();
    set_has_std_dev();
    accuracy_.std_dev_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy_StdDev >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.std_dev)
  return accuracy_.std_dev_;
}

// .sensoris.protobuf.types.base.Int64Matrix3x3 covariance = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool RotationRateAndAccuracy::has_covariance() const {
  return accuracy_case() == kCovariance;
}
inline void RotationRateAndAccuracy::set_has_covariance() {
  _oneof_case_[0] = kCovariance;
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::_internal_covariance() const {
  return *accuracy_.covariance_;
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::release_covariance() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
      ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::base::Int64Matrix3x3& RotationRateAndAccuracy::covariance() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return has_covariance()
      ? *accuracy_.covariance_
      : *reinterpret_cast< ::sensoris::protobuf::types::base::Int64Matrix3x3*>(&::sensoris::protobuf::types::base::_Int64Matrix3x3_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::unsafe_arena_release_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  if (has_covariance()) {
    clear_has_accuracy();
    ::sensoris::protobuf::types::base::Int64Matrix3x3* temp = accuracy_.covariance_;
    accuracy_.covariance_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void RotationRateAndAccuracy::unsafe_arena_set_allocated_covariance(::sensoris::protobuf::types::base::Int64Matrix3x3* covariance) {
  clear_accuracy();
  if (covariance) {
    set_has_covariance();
    accuracy_.covariance_ = covariance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
}
inline ::sensoris::protobuf::types::base::Int64Matrix3x3* RotationRateAndAccuracy::mutable_covariance() {
  if (!has_covariance()) {
    clear_accuracy();
    set_has_covariance();
    accuracy_.covariance_ = CreateMaybeMessage< ::sensoris::protobuf::types::base::Int64Matrix3x3 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.covariance)
  return accuracy_.covariance_;
}

// repeated .google.protobuf.Any extension = 15;
inline int RotationRateAndAccuracy::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* RotationRateAndAccuracy::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
RotationRateAndAccuracy::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& RotationRateAndAccuracy::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* RotationRateAndAccuracy::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
RotationRateAndAccuracy::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.RotationRateAndAccuracy.extension)
  return extension_;
}

inline bool RotationRateAndAccuracy::has_accuracy() const {
  return accuracy_case() != ACCURACY_NOT_SET;
}
inline void RotationRateAndAccuracy::clear_has_accuracy() {
  _oneof_case_[0] = ACCURACY_NOT_SET;
}
inline RotationRateAndAccuracy::AccuracyCase RotationRateAndAccuracy::accuracy_case() const {
  return RotationRateAndAccuracy::AccuracyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MapLocationReference_TileIdLinkIdOffset

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdLinkIdOffset::has_tile_id() const {
  return this != internal_default_instance() && tile_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_tile_id() const {
  return *tile_id_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::tile_id() const {
  const ::google::protobuf::Int64Value* p = tile_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_tile_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  
  ::google::protobuf::Int64Value* temp = tile_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  tile_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_tile_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  
  ::google::protobuf::Int64Value* temp = tile_id_;
  tile_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_tile_id() {
  
  if (tile_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    tile_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
  return tile_id_;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_tile_id(::google::protobuf::Int64Value* tile_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tile_id_);
  }
  if (tile_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tile_id)->GetArena();
    if (message_arena != submessage_arena) {
      tile_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tile_id, submessage_arena);
    }
    
  } else {
    
  }
  tile_id_ = tile_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.tile_id)
}

// .google.protobuf.Int64Value link_id = 2;
inline bool MapLocationReference_TileIdLinkIdOffset::has_link_id() const {
  return this != internal_default_instance() && link_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_link_id() const {
  return *link_id_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::link_id() const {
  const ::google::protobuf::Int64Value* p = link_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_link_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  
  ::google::protobuf::Int64Value* temp = link_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  link_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_link_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  
  ::google::protobuf::Int64Value* temp = link_id_;
  link_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_link_id() {
  
  if (link_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    link_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
  return link_id_;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_link_id(::google::protobuf::Int64Value* link_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(link_id_);
  }
  if (link_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(link_id)->GetArena();
    if (message_arena != submessage_arena) {
      link_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, link_id, submessage_arena);
    }
    
  } else {
    
  }
  link_id_ = link_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.link_id)
}

// .google.protobuf.Int64Value offset = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool MapLocationReference_TileIdLinkIdOffset::has_offset() const {
  return this != internal_default_instance() && offset_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::_internal_offset() const {
  return *offset_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdLinkIdOffset::offset() const {
  const ::google::protobuf::Int64Value* p = offset_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::release_offset() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  
  ::google::protobuf::Int64Value* temp = offset_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  offset_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::unsafe_arena_release_offset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  
  ::google::protobuf::Int64Value* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdLinkIdOffset::mutable_offset() {
  
  if (offset_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    offset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
  return offset_;
}
inline void MapLocationReference_TileIdLinkIdOffset::set_allocated_offset(::google::protobuf::Int64Value* offset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offset_);
  }
  if (offset) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(offset)->GetArena();
    if (message_arena != submessage_arena) {
      offset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset, submessage_arena);
    }
    
  } else {
    
  }
  offset_ = offset;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.offset)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdLinkIdOffset::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* MapLocationReference_TileIdLinkIdOffset::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
MapLocationReference_TileIdLinkIdOffset::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdLinkIdOffset::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* MapLocationReference_TileIdLinkIdOffset::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
MapLocationReference_TileIdLinkIdOffset::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset.extension)
  return extension_;
}

// -------------------------------------------------------------------

// MapLocationReference_TileIdObjectId

// .google.protobuf.Int64Value tile_id = 1;
inline bool MapLocationReference_TileIdObjectId::has_tile_id() const {
  return this != internal_default_instance() && tile_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_tile_id() const {
  return *tile_id_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::tile_id() const {
  const ::google::protobuf::Int64Value* p = tile_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::release_tile_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  
  ::google::protobuf::Int64Value* temp = tile_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  tile_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::unsafe_arena_release_tile_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  
  ::google::protobuf::Int64Value* temp = tile_id_;
  tile_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::mutable_tile_id() {
  
  if (tile_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    tile_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
  return tile_id_;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_tile_id(::google::protobuf::Int64Value* tile_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tile_id_);
  }
  if (tile_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tile_id)->GetArena();
    if (message_arena != submessage_arena) {
      tile_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tile_id, submessage_arena);
    }
    
  } else {
    
  }
  tile_id_ = tile_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.tile_id)
}

// .google.protobuf.Int64Value object_id = 2;
inline bool MapLocationReference_TileIdObjectId::has_object_id() const {
  return this != internal_default_instance() && object_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::_internal_object_id() const {
  return *object_id_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference_TileIdObjectId::object_id() const {
  const ::google::protobuf::Int64Value* p = object_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::release_object_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  
  ::google::protobuf::Int64Value* temp = object_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  object_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::unsafe_arena_release_object_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  
  ::google::protobuf::Int64Value* temp = object_id_;
  object_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference_TileIdObjectId::mutable_object_id() {
  
  if (object_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    object_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
  return object_id_;
}
inline void MapLocationReference_TileIdObjectId::set_allocated_object_id(::google::protobuf::Int64Value* object_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_id_);
  }
  if (object_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(object_id)->GetArena();
    if (message_arena != submessage_arena) {
      object_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_id, submessage_arena);
    }
    
  } else {
    
  }
  object_id_ = object_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.object_id)
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference_TileIdObjectId::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* MapLocationReference_TileIdObjectId::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
MapLocationReference_TileIdObjectId::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& MapLocationReference_TileIdObjectId::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* MapLocationReference_TileIdObjectId::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
MapLocationReference_TileIdObjectId::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId.extension)
  return extension_;
}

// -------------------------------------------------------------------

// MapLocationReference

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 1;
inline bool MapLocationReference::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline void MapLocationReference::clear_position_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && position_and_accuracy_ != NULL) {
    delete position_and_accuracy_;
  }
  position_and_accuracy_ = NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& MapLocationReference::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* MapLocationReference::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
  return position_and_accuracy_;
}
inline void MapLocationReference::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_and_accuracy_;
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(position_and_accuracy);
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.position_and_accuracy)
}

// .google.protobuf.Int64Value z_level = 2;
inline bool MapLocationReference::has_z_level() const {
  return this != internal_default_instance() && z_level_ != NULL;
}
inline const ::google::protobuf::Int64Value& MapLocationReference::_internal_z_level() const {
  return *z_level_;
}
inline const ::google::protobuf::Int64Value& MapLocationReference::z_level() const {
  const ::google::protobuf::Int64Value* p = z_level_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* MapLocationReference::release_z_level() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  
  ::google::protobuf::Int64Value* temp = z_level_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  z_level_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference::unsafe_arena_release_z_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  
  ::google::protobuf::Int64Value* temp = z_level_;
  z_level_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* MapLocationReference::mutable_z_level() {
  
  if (z_level_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    z_level_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
  return z_level_;
}
inline void MapLocationReference::set_allocated_z_level(::google::protobuf::Int64Value* z_level) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(z_level_);
  }
  if (z_level) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(z_level)->GetArena();
    if (message_arena != submessage_arena) {
      z_level = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, z_level, submessage_arena);
    }
    
  } else {
    
  }
  z_level_ = z_level;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.z_level)
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdLinkIdOffset tile_link_offset_reference = 3;
inline bool MapLocationReference::has_tile_link_offset_reference() const {
  return map_based_reference_case() == kTileLinkOffsetReference;
}
inline void MapLocationReference::set_has_tile_link_offset_reference() {
  _oneof_case_[0] = kTileLinkOffsetReference;
}
inline void MapLocationReference::clear_tile_link_offset_reference() {
  if (has_tile_link_offset_reference()) {
    if (GetArenaNoVirtual() == NULL) {
      delete map_based_reference_.tile_link_offset_reference_;
    }
    clear_has_map_based_reference();
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::_internal_tile_link_offset_reference() const {
  return *map_based_reference_.tile_link_offset_reference_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (has_tile_link_offset_reference()) {
    clear_has_map_based_reference();
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* temp = map_based_reference_.tile_link_offset_reference_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    map_based_reference_.tile_link_offset_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset& MapLocationReference::tile_link_offset_reference() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return has_tile_link_offset_reference()
      ? *map_based_reference_.tile_link_offset_reference_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset*>(&::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdLinkIdOffset_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::unsafe_arena_release_tile_link_offset_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  if (has_tile_link_offset_reference()) {
    clear_has_map_based_reference();
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* temp = map_based_reference_.tile_link_offset_reference_;
    map_based_reference_.tile_link_offset_reference_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_tile_link_offset_reference(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* tile_link_offset_reference) {
  clear_map_based_reference();
  if (tile_link_offset_reference) {
    set_has_tile_link_offset_reference();
    map_based_reference_.tile_link_offset_reference_ = tile_link_offset_reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset* MapLocationReference::mutable_tile_link_offset_reference() {
  if (!has_tile_link_offset_reference()) {
    clear_map_based_reference();
    set_has_tile_link_offset_reference();
    map_based_reference_.tile_link_offset_reference_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdLinkIdOffset >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.tile_link_offset_reference)
  return map_based_reference_.tile_link_offset_reference_;
}

// .sensoris.protobuf.types.spatial.MapLocationReference.TileIdObjectId map_object_id = 4;
inline bool MapLocationReference::has_map_object_id() const {
  return map_based_reference_case() == kMapObjectId;
}
inline void MapLocationReference::set_has_map_object_id() {
  _oneof_case_[0] = kMapObjectId;
}
inline void MapLocationReference::clear_map_object_id() {
  if (has_map_object_id()) {
    if (GetArenaNoVirtual() == NULL) {
      delete map_based_reference_.map_object_id_;
    }
    clear_has_map_based_reference();
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::_internal_map_object_id() const {
  return *map_based_reference_.map_object_id_;
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::release_map_object_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (has_map_object_id()) {
    clear_has_map_based_reference();
      ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* temp = map_based_reference_.map_object_id_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    map_based_reference_.map_object_id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId& MapLocationReference::map_object_id() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return has_map_object_id()
      ? *map_based_reference_.map_object_id_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId*>(&::sensoris::protobuf::types::spatial::_MapLocationReference_TileIdObjectId_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::unsafe_arena_release_map_object_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  if (has_map_object_id()) {
    clear_has_map_based_reference();
    ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* temp = map_based_reference_.map_object_id_;
    map_based_reference_.map_object_id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MapLocationReference::unsafe_arena_set_allocated_map_object_id(::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* map_object_id) {
  clear_map_based_reference();
  if (map_object_id) {
    set_has_map_object_id();
    map_based_reference_.map_object_id_ = map_object_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
}
inline ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId* MapLocationReference::mutable_map_object_id() {
  if (!has_map_object_id()) {
    clear_map_based_reference();
    set_has_map_object_id();
    map_based_reference_.map_object_id_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::MapLocationReference_TileIdObjectId >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.map_object_id)
  return map_based_reference_.map_object_id_;
}

// repeated .google.protobuf.Any extension = 15;
inline int MapLocationReference::extension_size() const {
  return extension_.size();
}
inline ::google::protobuf::Any* MapLocationReference::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return extension_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >*
MapLocationReference::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return &extension_;
}
inline const ::google::protobuf::Any& MapLocationReference::extension(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return extension_.Get(index);
}
inline ::google::protobuf::Any* MapLocationReference::add_extension() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return extension_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::google::protobuf::Any >&
MapLocationReference::extension() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.types.spatial.MapLocationReference.extension)
  return extension_;
}

inline bool MapLocationReference::has_map_based_reference() const {
  return map_based_reference_case() != MAP_BASED_REFERENCE_NOT_SET;
}
inline void MapLocationReference::clear_has_map_based_reference() {
  _oneof_case_[0] = MAP_BASED_REFERENCE_NOT_SET;
}
inline MapLocationReference::MapBasedReferenceCase MapLocationReference::map_based_reference_case() const {
  return MapLocationReference::MapBasedReferenceCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace spatial
}  // namespace types
}  // namespace protobuf
}  // namespace sensoris

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/road_attribution.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto 

namespace protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[21];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {
class InclinationAndCurvature;
class InclinationAndCurvatureDefaultTypeInternal;
extern InclinationAndCurvatureDefaultTypeInternal _InclinationAndCurvature_default_instance_;
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class LaneBoundary;
class LaneBoundaryDefaultTypeInternal;
extern LaneBoundaryDefaultTypeInternal _LaneBoundary_default_instance_;
class LaneBoundaryMergeSplit;
class LaneBoundaryMergeSplitDefaultTypeInternal;
extern LaneBoundaryMergeSplitDefaultTypeInternal _LaneBoundaryMergeSplit_default_instance_;
class LaneBoundaryMergeSplit_TypeAndConfidence;
class LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundaryMergeSplit_TypeAndConfidenceDefaultTypeInternal _LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_;
class LaneBoundary_DashStatistics;
class LaneBoundary_DashStatisticsDefaultTypeInternal;
extern LaneBoundary_DashStatisticsDefaultTypeInternal _LaneBoundary_DashStatistics_default_instance_;
class LaneBoundary_MarkingOffsets;
class LaneBoundary_MarkingOffsetsDefaultTypeInternal;
extern LaneBoundary_MarkingOffsetsDefaultTypeInternal _LaneBoundary_MarkingOffsets_default_instance_;
class LaneBoundary_MarkingOffsets_TypeAndOffset;
class LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal;
extern LaneBoundary_MarkingOffsets_TypeAndOffsetDefaultTypeInternal _LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_;
class LaneBoundary_TypeAndConfidence;
class LaneBoundary_TypeAndConfidenceDefaultTypeInternal;
extern LaneBoundary_TypeAndConfidenceDefaultTypeInternal _LaneBoundary_TypeAndConfidence_default_instance_;
class LaneCountAndConfidence;
class LaneCountAndConfidenceDefaultTypeInternal;
extern LaneCountAndConfidenceDefaultTypeInternal _LaneCountAndConfidence_default_instance_;
class MarkingColorAndConfidence;
class MarkingColorAndConfidenceDefaultTypeInternal;
extern MarkingColorAndConfidenceDefaultTypeInternal _MarkingColorAndConfidence_default_instance_;
class MarkingMaterialAndConfidence;
class MarkingMaterialAndConfidenceDefaultTypeInternal;
extern MarkingMaterialAndConfidenceDefaultTypeInternal _MarkingMaterialAndConfidence_default_instance_;
class Road;
class RoadDefaultTypeInternal;
extern RoadDefaultTypeInternal _Road_default_instance_;
class RoadAttribution;
class RoadAttributionDefaultTypeInternal;
extern RoadAttributionDefaultTypeInternal _RoadAttribution_default_instance_;
class RoadAttributionCategory;
class RoadAttributionCategoryDefaultTypeInternal;
extern RoadAttributionCategoryDefaultTypeInternal _RoadAttributionCategory_default_instance_;
class RoadAttribution_ChangeTypeAndConfidence;
class RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_ChangeTypeAndConfidenceDefaultTypeInternal _RoadAttribution_ChangeTypeAndConfidence_default_instance_;
class RoadAttribution_TypeAndConfidence;
class RoadAttribution_TypeAndConfidenceDefaultTypeInternal;
extern RoadAttribution_TypeAndConfidenceDefaultTypeInternal _RoadAttribution_TypeAndConfidence_default_instance_;
class SurfaceAttribution;
class SurfaceAttributionDefaultTypeInternal;
extern SurfaceAttributionDefaultTypeInternal _SurfaceAttribution_default_instance_;
class SurfaceMarking;
class SurfaceMarkingDefaultTypeInternal;
extern SurfaceMarkingDefaultTypeInternal _SurfaceMarking_default_instance_;
class SurfaceMarking_TypeAndConfidence;
class SurfaceMarking_TypeAndConfidenceDefaultTypeInternal;
extern SurfaceMarking_TypeAndConfidenceDefaultTypeInternal _SurfaceMarking_TypeAndConfidence_default_instance_;
class SurfaceMaterialAndConfidence;
class SurfaceMaterialAndConfidenceDefaultTypeInternal;
extern SurfaceMaterialAndConfidenceDefaultTypeInternal _SurfaceMaterialAndConfidence_default_instance_;
}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::Lane* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::Lane>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundary* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::Road* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::Road>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::RoadAttribution* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::RoadAttributionCategory* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttributionCategory>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceAttribution>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceMarking>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace categories {
namespace roadattribution {

enum MarkingColorAndConfidence_Type {
  MarkingColorAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingColorAndConfidence_Type_WHITE = 1,
  MarkingColorAndConfidence_Type_GRAY = 2,
  MarkingColorAndConfidence_Type_GRAY_LIGHT = 3,
  MarkingColorAndConfidence_Type_GRAY_DARK = 4,
  MarkingColorAndConfidence_Type_BLACK = 5,
  MarkingColorAndConfidence_Type_RED = 6,
  MarkingColorAndConfidence_Type_YELLOW = 7,
  MarkingColorAndConfidence_Type_GREEN = 8,
  MarkingColorAndConfidence_Type_CYAN = 9,
  MarkingColorAndConfidence_Type_BLUE = 10,
  MarkingColorAndConfidence_Type_ORANGE = 11,
  MarkingColorAndConfidence_Type_PINK = 12,
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MarkingColorAndConfidence_Type_MarkingColorAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MarkingColorAndConfidence_Type_IsValid(int value);
const MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MIN = MarkingColorAndConfidence_Type_UNKNOWN_TYPE;
const MarkingColorAndConfidence_Type MarkingColorAndConfidence_Type_Type_MAX = MarkingColorAndConfidence_Type_PINK;
const int MarkingColorAndConfidence_Type_Type_ARRAYSIZE = MarkingColorAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarkingColorAndConfidence_Type_descriptor();
inline const ::std::string& MarkingColorAndConfidence_Type_Name(MarkingColorAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarkingColorAndConfidence_Type_descriptor(), value);
}
inline bool MarkingColorAndConfidence_Type_Parse(
    const ::std::string& name, MarkingColorAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingColorAndConfidence_Type>(
    MarkingColorAndConfidence_Type_descriptor(), name, value);
}
enum MarkingMaterialAndConfidence_Type {
  MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  MarkingMaterialAndConfidence_Type_METAL = 1,
  MarkingMaterialAndConfidence_Type_CONCRETE = 2,
  MarkingMaterialAndConfidence_Type_STONE = 3,
  MarkingMaterialAndConfidence_Type_WOOD = 4,
  MarkingMaterialAndConfidence_Type_PLASTIC = 5,
  MarkingMaterialAndConfidence_Type_TRANSPARENT = 6,
  MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS = 7,
  MarkingMaterialAndConfidence_Type_PAINT = 8,
  MarkingMaterialAndConfidence_Type_ASPHALT = 9,
  MarkingMaterialAndConfidence_Type_GRAVEL = 10,
  MarkingMaterialAndConfidence_Type_COBBLESTONE = 11,
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MarkingMaterialAndConfidence_Type_MarkingMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MarkingMaterialAndConfidence_Type_IsValid(int value);
const MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MIN = MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE;
const MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence_Type_Type_MAX = MarkingMaterialAndConfidence_Type_COBBLESTONE;
const int MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE = MarkingMaterialAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* MarkingMaterialAndConfidence_Type_descriptor();
inline const ::std::string& MarkingMaterialAndConfidence_Type_Name(MarkingMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    MarkingMaterialAndConfidence_Type_descriptor(), value);
}
inline bool MarkingMaterialAndConfidence_Type_Parse(
    const ::std::string& name, MarkingMaterialAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MarkingMaterialAndConfidence_Type>(
    MarkingMaterialAndConfidence_Type_descriptor(), name, value);
}
enum SurfaceMaterialAndConfidence_Type {
  SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMaterialAndConfidence_Type_ASPHALT = 1,
  SurfaceMaterialAndConfidence_Type_CONCRETE = 2,
  SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT = 3,
  SurfaceMaterialAndConfidence_Type_RECYCLING = 4,
  SurfaceMaterialAndConfidence_Type_GRAVEL = 5,
  SurfaceMaterialAndConfidence_Type_COBBLESTONE = 6,
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SurfaceMaterialAndConfidence_Type_SurfaceMaterialAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SurfaceMaterialAndConfidence_Type_IsValid(int value);
const SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MIN = SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE;
const SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence_Type_Type_MAX = SurfaceMaterialAndConfidence_Type_COBBLESTONE;
const int SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE = SurfaceMaterialAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SurfaceMaterialAndConfidence_Type_descriptor();
inline const ::std::string& SurfaceMaterialAndConfidence_Type_Name(SurfaceMaterialAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SurfaceMaterialAndConfidence_Type_descriptor(), value);
}
inline bool SurfaceMaterialAndConfidence_Type_Parse(
    const ::std::string& name, SurfaceMaterialAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMaterialAndConfidence_Type>(
    SurfaceMaterialAndConfidence_Type_descriptor(), name, value);
}
enum LaneBoundary_TypeAndConfidence_Type {
  LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_TypeAndConfidence_Type_LINE = 1,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE = 2,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID = 3,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED = 4,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT = 5,
  LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG = 6,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE = 7,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID = 8,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED = 9,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED = 10,
  LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID = 11,
  LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING = 12,
  LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED = 13,
  LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT = 14,
  LaneBoundary_TypeAndConfidence_Type_CURB = 15,
  LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE = 16,
  LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE = 17,
  LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER = 18,
  LaneBoundary_TypeAndConfidence_Type_WALL = 19,
  LaneBoundary_TypeAndConfidence_Type_WALL_FLAT = 20,
  LaneBoundary_TypeAndConfidence_Type_WALL_CURVED = 21,
  LaneBoundary_TypeAndConfidence_Type_BARRIER = 22,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY = 23,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND = 24,
  LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE = 25,
  LaneBoundary_TypeAndConfidence_Type_GUARDRAIL = 26,
  LaneBoundary_TypeAndConfidence_Type_FENCE = 27,
  LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE = 28,
  LaneBoundary_TypeAndConfidence_Type_CLIFF = 29,
  LaneBoundary_TypeAndConfidence_Type_DITCH = 30,
  LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT = 31,
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneBoundary_TypeAndConfidence_Type_LaneBoundary_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneBoundary_TypeAndConfidence_Type_IsValid(int value);
const LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MIN = LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE;
const LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence_Type_Type_MAX = LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT;
const int LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE = LaneBoundary_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundary_TypeAndConfidence_Type_descriptor();
inline const ::std::string& LaneBoundary_TypeAndConfidence_Type_Name(LaneBoundary_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundary_TypeAndConfidence_Type_descriptor(), value);
}
inline bool LaneBoundary_TypeAndConfidence_Type_Parse(
    const ::std::string& name, LaneBoundary_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_TypeAndConfidence_Type>(
    LaneBoundary_TypeAndConfidence_Type_descriptor(), name, value);
}
enum LaneBoundary_MarkingOffsets_TypeAndOffset_Type {
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE = 0,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING = 1,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING = 2,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING = 3,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING = 4,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneBoundary_MarkingOffsets_TypeAndOffset_Type_LaneBoundary_MarkingOffsets_TypeAndOffset_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(int value);
const LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE;
const LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING;
const int LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE = LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
inline const ::std::string& LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor(), value);
}
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(
    const ::std::string& name, LaneBoundary_MarkingOffsets_TypeAndOffset_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_MarkingOffsets_TypeAndOffset_Type>(
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor(), name, value);
}
enum LaneBoundary_PositionReference {
  LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE = 0,
  LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY = 1,
  LaneBoundary_PositionReference_CENTER_LINE = 2,
  LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY = 3,
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneBoundary_PositionReference_LaneBoundary_PositionReference_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneBoundary_PositionReference_IsValid(int value);
const LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MIN = LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE;
const LaneBoundary_PositionReference LaneBoundary_PositionReference_PositionReference_MAX = LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY;
const int LaneBoundary_PositionReference_PositionReference_ARRAYSIZE = LaneBoundary_PositionReference_PositionReference_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundary_PositionReference_descriptor();
inline const ::std::string& LaneBoundary_PositionReference_Name(LaneBoundary_PositionReference value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundary_PositionReference_descriptor(), value);
}
inline bool LaneBoundary_PositionReference_Parse(
    const ::std::string& name, LaneBoundary_PositionReference* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundary_PositionReference>(
    LaneBoundary_PositionReference_descriptor(), name, value);
}
enum LaneBoundaryMergeSplit_TypeAndConfidence_Type {
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE = 1,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT = 2,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneBoundaryMergeSplit_TypeAndConfidence_Type_LaneBoundaryMergeSplit_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(int value);
const LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN = LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE;
const LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX = LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT;
const int LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE = LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
inline const ::std::string& LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor(), value);
}
inline bool LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(
    const ::std::string& name, LaneBoundaryMergeSplit_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryMergeSplit_TypeAndConfidence_Type>(
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor(), name, value);
}
enum SurfaceMarking_TypeAndConfidence_Type {
  SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  SurfaceMarking_TypeAndConfidence_Type_SIGN = 1,
  SurfaceMarking_TypeAndConfidence_Type_TEXT = 2,
  SurfaceMarking_TypeAndConfidence_Type_ICON = 3,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN = 4,
  SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK = 5,
  SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT = 6,
  SurfaceMarking_TypeAndConfidence_Type_STOP_LINE = 7,
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SurfaceMarking_TypeAndConfidence_Type_SurfaceMarking_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SurfaceMarking_TypeAndConfidence_Type_IsValid(int value);
const SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MIN = SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE;
const SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence_Type_Type_MAX = SurfaceMarking_TypeAndConfidence_Type_STOP_LINE;
const int SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE = SurfaceMarking_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* SurfaceMarking_TypeAndConfidence_Type_descriptor();
inline const ::std::string& SurfaceMarking_TypeAndConfidence_Type_Name(SurfaceMarking_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    SurfaceMarking_TypeAndConfidence_Type_descriptor(), value);
}
inline bool SurfaceMarking_TypeAndConfidence_Type_Parse(
    const ::std::string& name, SurfaceMarking_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceMarking_TypeAndConfidence_Type>(
    SurfaceMarking_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadAttribution_TypeAndConfidence_Type {
  RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_TypeAndConfidence_Type_MOTORWAY = 1,
  RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC = 2,
  RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC = 3,
  RoadAttribution_TypeAndConfidence_Type_OFFROAD = 4,
  RoadAttribution_TypeAndConfidence_Type_TUNNEL = 5,
  RoadAttribution_TypeAndConfidence_Type_BRIDGE = 6,
  RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION = 7,
  RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES = 8,
  RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT = 9,
  RoadAttribution_TypeAndConfidence_Type_LANE_LEFT = 10,
  RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE = 11,
  RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE = 12,
  RoadAttribution_TypeAndConfidence_Type_CROSSWALK = 13,
  RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE = 14,
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadAttribution_TypeAndConfidence_Type_RoadAttribution_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadAttribution_TypeAndConfidence_Type_IsValid(int value);
const RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MIN = RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE;
const RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence_Type_Type_MAX = RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE;
const int RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE = RoadAttribution_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadAttribution_TypeAndConfidence_Type_descriptor();
inline const ::std::string& RoadAttribution_TypeAndConfidence_Type_Name(RoadAttribution_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadAttribution_TypeAndConfidence_Type_descriptor(), value);
}
inline bool RoadAttribution_TypeAndConfidence_Type_Parse(
    const ::std::string& name, RoadAttribution_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_TypeAndConfidence_Type>(
    RoadAttribution_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadAttribution_ChangeTypeAndConfidence_Type {
  RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED = 1,
  RoadAttribution_ChangeTypeAndConfidence_Type_START = 2,
  RoadAttribution_ChangeTypeAndConfidence_Type_END = 3,
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadAttribution_ChangeTypeAndConfidence_Type_RoadAttribution_ChangeTypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(int value);
const RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN = RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE;
const RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX = RoadAttribution_ChangeTypeAndConfidence_Type_END;
const int RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE = RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
inline const ::std::string& RoadAttribution_ChangeTypeAndConfidence_Type_Name(RoadAttribution_ChangeTypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadAttribution_ChangeTypeAndConfidence_Type_descriptor(), value);
}
inline bool RoadAttribution_ChangeTypeAndConfidence_Type_Parse(
    const ::std::string& name, RoadAttribution_ChangeTypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAttribution_ChangeTypeAndConfidence_Type>(
    RoadAttribution_ChangeTypeAndConfidence_Type_descriptor(), name, value);
}
enum LaneCountAndConfidence_Type {
  LaneCountAndConfidence_Type_UNKNOWN_TYPE = 0,
  LaneCountAndConfidence_Type_TOTAL = 1,
  LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE = 2,
  LaneCountAndConfidence_Type_RIGHT = 3,
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LaneCountAndConfidence_Type_LaneCountAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LaneCountAndConfidence_Type_IsValid(int value);
const LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MIN = LaneCountAndConfidence_Type_UNKNOWN_TYPE;
const LaneCountAndConfidence_Type LaneCountAndConfidence_Type_Type_MAX = LaneCountAndConfidence_Type_RIGHT;
const int LaneCountAndConfidence_Type_Type_ARRAYSIZE = LaneCountAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneCountAndConfidence_Type_descriptor();
inline const ::std::string& LaneCountAndConfidence_Type_Name(LaneCountAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneCountAndConfidence_Type_descriptor(), value);
}
inline bool LaneCountAndConfidence_Type_Parse(
    const ::std::string& name, LaneCountAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneCountAndConfidence_Type>(
    LaneCountAndConfidence_Type_descriptor(), name, value);
}
// ===================================================================

class MarkingColorAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence) */ {
 public:
  MarkingColorAndConfidence();
  virtual ~MarkingColorAndConfidence();

  MarkingColorAndConfidence(const MarkingColorAndConfidence& from);

  inline MarkingColorAndConfidence& operator=(const MarkingColorAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarkingColorAndConfidence(MarkingColorAndConfidence&& from) noexcept
    : MarkingColorAndConfidence() {
    *this = ::std::move(from);
  }

  inline MarkingColorAndConfidence& operator=(MarkingColorAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkingColorAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkingColorAndConfidence* internal_default_instance() {
    return reinterpret_cast<const MarkingColorAndConfidence*>(
               &_MarkingColorAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(MarkingColorAndConfidence* other);
  void Swap(MarkingColorAndConfidence* other);
  friend void swap(MarkingColorAndConfidence& a, MarkingColorAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkingColorAndConfidence* New() const final {
    return CreateMaybeMessage<MarkingColorAndConfidence>(NULL);
  }

  MarkingColorAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarkingColorAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarkingColorAndConfidence& from);
  void MergeFrom(const MarkingColorAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkingColorAndConfidence* other);
  protected:
  explicit MarkingColorAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MarkingColorAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    MarkingColorAndConfidence_Type_UNKNOWN_TYPE;
  static const Type WHITE =
    MarkingColorAndConfidence_Type_WHITE;
  static const Type GRAY =
    MarkingColorAndConfidence_Type_GRAY;
  static const Type GRAY_LIGHT =
    MarkingColorAndConfidence_Type_GRAY_LIGHT;
  static const Type GRAY_DARK =
    MarkingColorAndConfidence_Type_GRAY_DARK;
  static const Type BLACK =
    MarkingColorAndConfidence_Type_BLACK;
  static const Type RED =
    MarkingColorAndConfidence_Type_RED;
  static const Type YELLOW =
    MarkingColorAndConfidence_Type_YELLOW;
  static const Type GREEN =
    MarkingColorAndConfidence_Type_GREEN;
  static const Type CYAN =
    MarkingColorAndConfidence_Type_CYAN;
  static const Type BLUE =
    MarkingColorAndConfidence_Type_BLUE;
  static const Type ORANGE =
    MarkingColorAndConfidence_Type_ORANGE;
  static const Type PINK =
    MarkingColorAndConfidence_Type_PINK;
  static inline bool Type_IsValid(int value) {
    return MarkingColorAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MarkingColorAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    MarkingColorAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MarkingColorAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MarkingColorAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MarkingColorAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MarkingColorAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarkingMaterialAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence) */ {
 public:
  MarkingMaterialAndConfidence();
  virtual ~MarkingMaterialAndConfidence();

  MarkingMaterialAndConfidence(const MarkingMaterialAndConfidence& from);

  inline MarkingMaterialAndConfidence& operator=(const MarkingMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarkingMaterialAndConfidence(MarkingMaterialAndConfidence&& from) noexcept
    : MarkingMaterialAndConfidence() {
    *this = ::std::move(from);
  }

  inline MarkingMaterialAndConfidence& operator=(MarkingMaterialAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarkingMaterialAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkingMaterialAndConfidence* internal_default_instance() {
    return reinterpret_cast<const MarkingMaterialAndConfidence*>(
               &_MarkingMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(MarkingMaterialAndConfidence* other);
  void Swap(MarkingMaterialAndConfidence* other);
  friend void swap(MarkingMaterialAndConfidence& a, MarkingMaterialAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarkingMaterialAndConfidence* New() const final {
    return CreateMaybeMessage<MarkingMaterialAndConfidence>(NULL);
  }

  MarkingMaterialAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarkingMaterialAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarkingMaterialAndConfidence& from);
  void MergeFrom(const MarkingMaterialAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkingMaterialAndConfidence* other);
  protected:
  explicit MarkingMaterialAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MarkingMaterialAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    MarkingMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static const Type METAL =
    MarkingMaterialAndConfidence_Type_METAL;
  static const Type CONCRETE =
    MarkingMaterialAndConfidence_Type_CONCRETE;
  static const Type STONE =
    MarkingMaterialAndConfidence_Type_STONE;
  static const Type WOOD =
    MarkingMaterialAndConfidence_Type_WOOD;
  static const Type PLASTIC =
    MarkingMaterialAndConfidence_Type_PLASTIC;
  static const Type TRANSPARENT =
    MarkingMaterialAndConfidence_Type_TRANSPARENT;
  static const Type VIBRATION_MARKINGS =
    MarkingMaterialAndConfidence_Type_VIBRATION_MARKINGS;
  static const Type PAINT =
    MarkingMaterialAndConfidence_Type_PAINT;
  static const Type ASPHALT =
    MarkingMaterialAndConfidence_Type_ASPHALT;
  static const Type GRAVEL =
    MarkingMaterialAndConfidence_Type_GRAVEL;
  static const Type COBBLESTONE =
    MarkingMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return MarkingMaterialAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    MarkingMaterialAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    MarkingMaterialAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    MarkingMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return MarkingMaterialAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return MarkingMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return MarkingMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SurfaceMaterialAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence) */ {
 public:
  SurfaceMaterialAndConfidence();
  virtual ~SurfaceMaterialAndConfidence();

  SurfaceMaterialAndConfidence(const SurfaceMaterialAndConfidence& from);

  inline SurfaceMaterialAndConfidence& operator=(const SurfaceMaterialAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceMaterialAndConfidence(SurfaceMaterialAndConfidence&& from) noexcept
    : SurfaceMaterialAndConfidence() {
    *this = ::std::move(from);
  }

  inline SurfaceMaterialAndConfidence& operator=(SurfaceMaterialAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceMaterialAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceMaterialAndConfidence* internal_default_instance() {
    return reinterpret_cast<const SurfaceMaterialAndConfidence*>(
               &_SurfaceMaterialAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(SurfaceMaterialAndConfidence* other);
  void Swap(SurfaceMaterialAndConfidence* other);
  friend void swap(SurfaceMaterialAndConfidence& a, SurfaceMaterialAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceMaterialAndConfidence* New() const final {
    return CreateMaybeMessage<SurfaceMaterialAndConfidence>(NULL);
  }

  SurfaceMaterialAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceMaterialAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceMaterialAndConfidence& from);
  void MergeFrom(const SurfaceMaterialAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceMaterialAndConfidence* other);
  protected:
  explicit SurfaceMaterialAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SurfaceMaterialAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    SurfaceMaterialAndConfidence_Type_UNKNOWN_TYPE;
  static const Type ASPHALT =
    SurfaceMaterialAndConfidence_Type_ASPHALT;
  static const Type CONCRETE =
    SurfaceMaterialAndConfidence_Type_CONCRETE;
  static const Type COMPOSITE_PAVEMENT =
    SurfaceMaterialAndConfidence_Type_COMPOSITE_PAVEMENT;
  static const Type RECYCLING =
    SurfaceMaterialAndConfidence_Type_RECYCLING;
  static const Type GRAVEL =
    SurfaceMaterialAndConfidence_Type_GRAVEL;
  static const Type COBBLESTONE =
    SurfaceMaterialAndConfidence_Type_COBBLESTONE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMaterialAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SurfaceMaterialAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    SurfaceMaterialAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SurfaceMaterialAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SurfaceMaterialAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SurfaceMaterialAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SurfaceMaterialAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InclinationAndCurvature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature) */ {
 public:
  InclinationAndCurvature();
  virtual ~InclinationAndCurvature();

  InclinationAndCurvature(const InclinationAndCurvature& from);

  inline InclinationAndCurvature& operator=(const InclinationAndCurvature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InclinationAndCurvature(InclinationAndCurvature&& from) noexcept
    : InclinationAndCurvature() {
    *this = ::std::move(from);
  }

  inline InclinationAndCurvature& operator=(InclinationAndCurvature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const InclinationAndCurvature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InclinationAndCurvature* internal_default_instance() {
    return reinterpret_cast<const InclinationAndCurvature*>(
               &_InclinationAndCurvature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(InclinationAndCurvature* other);
  void Swap(InclinationAndCurvature* other);
  friend void swap(InclinationAndCurvature& a, InclinationAndCurvature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InclinationAndCurvature* New() const final {
    return CreateMaybeMessage<InclinationAndCurvature>(NULL);
  }

  InclinationAndCurvature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InclinationAndCurvature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InclinationAndCurvature& from);
  void MergeFrom(const InclinationAndCurvature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InclinationAndCurvature* other);
  protected:
  explicit InclinationAndCurvature(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_longitudinal_inclination_and_accuracy() const;
  void clear_longitudinal_inclination_and_accuracy();
  static const int kLongitudinalInclinationAndAccuracyFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_longitudinal_inclination_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& longitudinal_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_longitudinal_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_longitudinal_inclination_and_accuracy();
  void set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* longitudinal_inclination_and_accuracy);
  void unsafe_arena_set_allocated_longitudinal_inclination_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* longitudinal_inclination_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_longitudinal_inclination_and_accuracy();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_lateral_inclination_and_accuracy() const;
  void clear_lateral_inclination_and_accuracy();
  static const int kLateralInclinationAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_lateral_inclination_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& lateral_inclination_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_lateral_inclination_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_lateral_inclination_and_accuracy();
  void set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* lateral_inclination_and_accuracy);
  void unsafe_arena_set_allocated_lateral_inclination_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* lateral_inclination_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_lateral_inclination_and_accuracy();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
  bool has_horizontal_curvature_and_accuracy() const;
  void clear_horizontal_curvature_and_accuracy();
  static const int kHorizontalCurvatureAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_horizontal_curvature_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& horizontal_curvature_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_horizontal_curvature_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_horizontal_curvature_and_accuracy();
  void set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* horizontal_curvature_and_accuracy);
  void unsafe_arena_set_allocated_horizontal_curvature_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* horizontal_curvature_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_horizontal_curvature_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* longitudinal_inclination_and_accuracy_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* lateral_inclination_and_accuracy_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* horizontal_curvature_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundary_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence) */ {
 public:
  LaneBoundary_TypeAndConfidence();
  virtual ~LaneBoundary_TypeAndConfidence();

  LaneBoundary_TypeAndConfidence(const LaneBoundary_TypeAndConfidence& from);

  inline LaneBoundary_TypeAndConfidence& operator=(const LaneBoundary_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundary_TypeAndConfidence(LaneBoundary_TypeAndConfidence&& from) noexcept
    : LaneBoundary_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_TypeAndConfidence& operator=(LaneBoundary_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_TypeAndConfidence*>(
               &_LaneBoundary_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(LaneBoundary_TypeAndConfidence* other);
  void Swap(LaneBoundary_TypeAndConfidence* other);
  friend void swap(LaneBoundary_TypeAndConfidence& a, LaneBoundary_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<LaneBoundary_TypeAndConfidence>(NULL);
  }

  LaneBoundary_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundary_TypeAndConfidence& from);
  void MergeFrom(const LaneBoundary_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary_TypeAndConfidence* other);
  protected:
  explicit LaneBoundary_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundary_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    LaneBoundary_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type LINE =
    LaneBoundary_TypeAndConfidence_Type_LINE;
  static const Type LINE_SINGLE =
    LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE;
  static const Type LINE_SINGLE_SOLID =
    LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_SOLID;
  static const Type LINE_SINGLE_DASHED =
    LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED;
  static const Type LINE_SINGLE_DASHED_SHORT =
    LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_SHORT;
  static const Type LINE_SINGLE_DASHED_LONG =
    LaneBoundary_TypeAndConfidence_Type_LINE_SINGLE_DASHED_LONG;
  static const Type LINE_DOUBLE =
    LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE;
  static const Type LINE_DOUBLE_SOLID =
    LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID;
  static const Type LINE_DOUBLE_DASHED =
    LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED;
  static const Type LINE_DOUBLE_SOLID_DASHED =
    LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_SOLID_DASHED;
  static const Type LINE_DOUBLE_DASHED_SOLID =
    LaneBoundary_TypeAndConfidence_Type_LINE_DOUBLE_DASHED_SOLID;
  static const Type SHADED_AREA_MARKING =
    LaneBoundary_TypeAndConfidence_Type_SHADED_AREA_MARKING;
  static const Type BLOCKS_DASHED =
    LaneBoundary_TypeAndConfidence_Type_BLOCKS_DASHED;
  static const Type CROSSING_ALERT =
    LaneBoundary_TypeAndConfidence_Type_CROSSING_ALERT;
  static const Type CURB =
    LaneBoundary_TypeAndConfidence_Type_CURB;
  static const Type CURB_TRAVERSABLE =
    LaneBoundary_TypeAndConfidence_Type_CURB_TRAVERSABLE;
  static const Type CURB_NON_TRAVERSABLE =
    LaneBoundary_TypeAndConfidence_Type_CURB_NON_TRAVERSABLE;
  static const Type PHYSICAL_DIVIDER =
    LaneBoundary_TypeAndConfidence_Type_PHYSICAL_DIVIDER;
  static const Type WALL =
    LaneBoundary_TypeAndConfidence_Type_WALL;
  static const Type WALL_FLAT =
    LaneBoundary_TypeAndConfidence_Type_WALL_FLAT;
  static const Type WALL_CURVED =
    LaneBoundary_TypeAndConfidence_Type_WALL_CURVED;
  static const Type BARRIER =
    LaneBoundary_TypeAndConfidence_Type_BARRIER;
  static const Type BARRIER_JERSEY =
    LaneBoundary_TypeAndConfidence_Type_BARRIER_JERSEY;
  static const Type BARRIER_SOUND =
    LaneBoundary_TypeAndConfidence_Type_BARRIER_SOUND;
  static const Type BARRIER_CABLE =
    LaneBoundary_TypeAndConfidence_Type_BARRIER_CABLE;
  static const Type GUARDRAIL =
    LaneBoundary_TypeAndConfidence_Type_GUARDRAIL;
  static const Type FENCE =
    LaneBoundary_TypeAndConfidence_Type_FENCE;
  static const Type ROAD_EDGE =
    LaneBoundary_TypeAndConfidence_Type_ROAD_EDGE;
  static const Type CLIFF =
    LaneBoundary_TypeAndConfidence_Type_CLIFF;
  static const Type DITCH =
    LaneBoundary_TypeAndConfidence_Type_DITCH;
  static const Type ASPHALT_JOINT =
    LaneBoundary_TypeAndConfidence_Type_ASPHALT_JOINT;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneBoundary_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    LaneBoundary_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneBoundary_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneBoundary_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneBoundary_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneBoundary_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundary_DashStatistics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics) */ {
 public:
  LaneBoundary_DashStatistics();
  virtual ~LaneBoundary_DashStatistics();

  LaneBoundary_DashStatistics(const LaneBoundary_DashStatistics& from);

  inline LaneBoundary_DashStatistics& operator=(const LaneBoundary_DashStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundary_DashStatistics(LaneBoundary_DashStatistics&& from) noexcept
    : LaneBoundary_DashStatistics() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_DashStatistics& operator=(LaneBoundary_DashStatistics&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary_DashStatistics& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary_DashStatistics* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_DashStatistics*>(
               &_LaneBoundary_DashStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(LaneBoundary_DashStatistics* other);
  void Swap(LaneBoundary_DashStatistics* other);
  friend void swap(LaneBoundary_DashStatistics& a, LaneBoundary_DashStatistics& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary_DashStatistics* New() const final {
    return CreateMaybeMessage<LaneBoundary_DashStatistics>(NULL);
  }

  LaneBoundary_DashStatistics* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary_DashStatistics>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundary_DashStatistics& from);
  void MergeFrom(const LaneBoundary_DashStatistics& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary_DashStatistics* other);
  protected:
  explicit LaneBoundary_DashStatistics(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_length_and_accuracy() const;
  void clear_length_and_accuracy();
  static const int kLengthAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_length_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& length_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_length_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_length_and_accuracy();
  void set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* length_and_accuracy);
  void unsafe_arena_set_allocated_length_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* length_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_length_and_accuracy();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_and_accuracy() const;
  void clear_distance_and_accuracy();
  static const int kDistanceAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_distance_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_distance_and_accuracy();
  void set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_and_accuracy);
  void unsafe_arena_set_allocated_distance_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_distance_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* length_and_accuracy_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets_TypeAndOffset : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset) */ {
 public:
  LaneBoundary_MarkingOffsets_TypeAndOffset();
  virtual ~LaneBoundary_MarkingOffsets_TypeAndOffset();

  LaneBoundary_MarkingOffsets_TypeAndOffset(const LaneBoundary_MarkingOffsets_TypeAndOffset& from);

  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(const LaneBoundary_MarkingOffsets_TypeAndOffset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundary_MarkingOffsets_TypeAndOffset(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept
    : LaneBoundary_MarkingOffsets_TypeAndOffset() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_MarkingOffsets_TypeAndOffset& operator=(LaneBoundary_MarkingOffsets_TypeAndOffset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary_MarkingOffsets_TypeAndOffset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary_MarkingOffsets_TypeAndOffset* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_MarkingOffsets_TypeAndOffset*>(
               &_LaneBoundary_MarkingOffsets_TypeAndOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* other);
  void Swap(LaneBoundary_MarkingOffsets_TypeAndOffset* other);
  friend void swap(LaneBoundary_MarkingOffsets_TypeAndOffset& a, LaneBoundary_MarkingOffsets_TypeAndOffset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary_MarkingOffsets_TypeAndOffset* New() const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets_TypeAndOffset>(NULL);
  }

  LaneBoundary_MarkingOffsets_TypeAndOffset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets_TypeAndOffset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  void MergeFrom(const LaneBoundary_MarkingOffsets_TypeAndOffset& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary_MarkingOffsets_TypeAndOffset* other);
  protected:
  explicit LaneBoundary_MarkingOffsets_TypeAndOffset(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundary_MarkingOffsets_TypeAndOffset_Type Type;
  static const Type UNKNOWN_TYPE =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_UNKNOWN_TYPE;
  static const Type START_OF_MARKING =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_START_OF_MARKING;
  static const Type END_OF_MARKING =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_END_OF_MARKING;
  static const Type ON_MARKING =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_ON_MARKING;
  static const Type NO_MARKING =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_NO_MARKING;
  static inline bool Type_IsValid(int value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MIN;
  static const Type Type_MAX =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneBoundary_MarkingOffsets_TypeAndOffset_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_offset_and_accuracy() const;
  void clear_offset_and_accuracy();
  static const int kOffsetAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_offset_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& offset_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_offset_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_offset_and_accuracy();
  void set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* offset_and_accuracy);
  void unsafe_arena_set_allocated_offset_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* offset_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_offset_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* offset_and_accuracy_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundary_MarkingOffsets : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets) */ {
 public:
  LaneBoundary_MarkingOffsets();
  virtual ~LaneBoundary_MarkingOffsets();

  LaneBoundary_MarkingOffsets(const LaneBoundary_MarkingOffsets& from);

  inline LaneBoundary_MarkingOffsets& operator=(const LaneBoundary_MarkingOffsets& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundary_MarkingOffsets(LaneBoundary_MarkingOffsets&& from) noexcept
    : LaneBoundary_MarkingOffsets() {
    *this = ::std::move(from);
  }

  inline LaneBoundary_MarkingOffsets& operator=(LaneBoundary_MarkingOffsets&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary_MarkingOffsets& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary_MarkingOffsets* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary_MarkingOffsets*>(
               &_LaneBoundary_MarkingOffsets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(LaneBoundary_MarkingOffsets* other);
  void Swap(LaneBoundary_MarkingOffsets* other);
  friend void swap(LaneBoundary_MarkingOffsets& a, LaneBoundary_MarkingOffsets& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary_MarkingOffsets* New() const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets>(NULL);
  }

  LaneBoundary_MarkingOffsets* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary_MarkingOffsets>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundary_MarkingOffsets& from);
  void MergeFrom(const LaneBoundary_MarkingOffsets& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary_MarkingOffsets* other);
  protected:
  explicit LaneBoundary_MarkingOffsets(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundary_MarkingOffsets_TypeAndOffset TypeAndOffset;

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
  int type_and_offset_size() const;
  void clear_type_and_offset();
  static const int kTypeAndOffsetFieldNumber = 2;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* mutable_type_and_offset(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >*
      mutable_type_and_offset();
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& type_and_offset(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* add_type_and_offset();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >&
      type_and_offset() const;

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset > type_and_offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundary) */ {
 public:
  LaneBoundary();
  virtual ~LaneBoundary();

  LaneBoundary(const LaneBoundary& from);

  inline LaneBoundary& operator=(const LaneBoundary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundary(LaneBoundary&& from) noexcept
    : LaneBoundary() {
    *this = ::std::move(from);
  }

  inline LaneBoundary& operator=(LaneBoundary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundary& default_instance();

  enum GeometryCase {
    kPolylineAndAccuracy = 9,
    GEOMETRY_NOT_SET = 0,
  };

  enum MarkingsCase {
    kDashStatistics = 13,
    kMarkingOffsets = 14,
    MARKINGS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundary* internal_default_instance() {
    return reinterpret_cast<const LaneBoundary*>(
               &_LaneBoundary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(LaneBoundary* other);
  void Swap(LaneBoundary* other);
  friend void swap(LaneBoundary& a, LaneBoundary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundary* New() const final {
    return CreateMaybeMessage<LaneBoundary>(NULL);
  }

  LaneBoundary* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundary>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundary& from);
  void MergeFrom(const LaneBoundary& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundary* other);
  protected:
  explicit LaneBoundary(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundary_TypeAndConfidence TypeAndConfidence;
  typedef LaneBoundary_DashStatistics DashStatistics;
  typedef LaneBoundary_MarkingOffsets MarkingOffsets;

  typedef LaneBoundary_PositionReference PositionReference;
  static const PositionReference UNKNOWN_POSITION_REFERENCE =
    LaneBoundary_PositionReference_UNKNOWN_POSITION_REFERENCE;
  static const PositionReference LEFT_MARKING_BOUNDARY =
    LaneBoundary_PositionReference_LEFT_MARKING_BOUNDARY;
  static const PositionReference CENTER_LINE =
    LaneBoundary_PositionReference_CENTER_LINE;
  static const PositionReference RIGHT_MARKING_BOUNDARY =
    LaneBoundary_PositionReference_RIGHT_MARKING_BOUNDARY;
  static inline bool PositionReference_IsValid(int value) {
    return LaneBoundary_PositionReference_IsValid(value);
  }
  static const PositionReference PositionReference_MIN =
    LaneBoundary_PositionReference_PositionReference_MIN;
  static const PositionReference PositionReference_MAX =
    LaneBoundary_PositionReference_PositionReference_MAX;
  static const int PositionReference_ARRAYSIZE =
    LaneBoundary_PositionReference_PositionReference_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PositionReference_descriptor() {
    return LaneBoundary_PositionReference_descriptor();
  }
  static inline const ::std::string& PositionReference_Name(PositionReference value) {
    return LaneBoundary_PositionReference_Name(value);
  }
  static inline bool PositionReference_Parse(const ::std::string& name,
      PositionReference* value) {
    return LaneBoundary_PositionReference_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .google.protobuf.Int64Value lane_boundary_id = 2;
  bool has_lane_boundary_id() const;
  void clear_lane_boundary_id();
  static const int kLaneBoundaryIdFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_lane_boundary_id() const;
  public:
  const ::google::protobuf::Int64Value& lane_boundary_id() const;
  ::google::protobuf::Int64Value* release_lane_boundary_id();
  ::google::protobuf::Int64Value* mutable_lane_boundary_id();
  void set_allocated_lane_boundary_id(::google::protobuf::Int64Value* lane_boundary_id);
  void unsafe_arena_set_allocated_lane_boundary_id(
      ::google::protobuf::Int64Value* lane_boundary_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_lane_boundary_id();

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence);
  void unsafe_arena_set_allocated_existence_confidence(
      ::sensoris::protobuf::types::base::Confidence* existence_confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 5;
  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
  bool has_material_and_confidence() const;
  void clear_material_and_confidence();
  static const int kMaterialAndConfidenceFieldNumber = 6;
  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& _internal_material_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* release_material_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* mutable_material_and_confidence();
  void set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* material_and_confidence);
  void unsafe_arena_set_allocated_material_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* material_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* unsafe_arena_release_material_and_confidence();

  // .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
  bool has_color_and_confidence() const;
  void clear_color_and_confidence();
  static const int kColorAndConfidenceFieldNumber = 7;
  private:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& _internal_color_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* release_color_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* mutable_color_and_confidence();
  void set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* color_and_confidence);
  void unsafe_arena_set_allocated_color_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* color_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* unsafe_arena_release_color_and_confidence();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy();
  static const int kWidthAndAccuracyFieldNumber = 10;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  void unsafe_arena_set_allocated_width_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_height_and_accuracy() const;
  void clear_height_and_accuracy();
  static const int kHeightAndAccuracyFieldNumber = 11;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_height_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& height_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_height_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_height_and_accuracy();
  void set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* height_and_accuracy);
  void unsafe_arena_set_allocated_height_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* height_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_height_and_accuracy();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_distance_between_double_and_accuracy() const;
  void clear_distance_between_double_and_accuracy();
  static const int kDistanceBetweenDoubleAndAccuracyFieldNumber = 12;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_distance_between_double_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& distance_between_double_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_distance_between_double_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_distance_between_double_and_accuracy();
  void set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_between_double_and_accuracy);
  void unsafe_arena_set_allocated_distance_between_double_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_between_double_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_distance_between_double_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
  void clear_position_reference();
  static const int kPositionReferenceFieldNumber = 8;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference position_reference() const;
  void set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value);

  // .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
  bool has_polyline_and_accuracy() const;
  void clear_polyline_and_accuracy();
  static const int kPolylineAndAccuracyFieldNumber = 9;
  private:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& _internal_polyline_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& polyline_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* release_polyline_and_accuracy();
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* mutable_polyline_and_accuracy();
  void set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* polyline_and_accuracy);
  void unsafe_arena_set_allocated_polyline_and_accuracy(
      ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* polyline_and_accuracy);
  ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* unsafe_arena_release_polyline_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
  bool has_dash_statistics() const;
  void clear_dash_statistics();
  static const int kDashStatisticsFieldNumber = 13;
  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& _internal_dash_statistics() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& dash_statistics() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* release_dash_statistics();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* mutable_dash_statistics();
  void set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* dash_statistics);
  void unsafe_arena_set_allocated_dash_statistics(
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* dash_statistics);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* unsafe_arena_release_dash_statistics();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
  bool has_marking_offsets() const;
  void clear_marking_offsets();
  static const int kMarkingOffsetsFieldNumber = 14;
  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& _internal_marking_offsets() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& marking_offsets() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* release_marking_offsets();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* mutable_marking_offsets();
  void set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* marking_offsets);
  void unsafe_arena_set_allocated_marking_offsets(
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* marking_offsets);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* unsafe_arena_release_marking_offsets();

  void clear_geometry();
  GeometryCase geometry_case() const;
  void clear_markings();
  MarkingsCase markings_case() const;
  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundary)
 private:
  void set_has_polyline_and_accuracy();
  void set_has_dash_statistics();
  void set_has_marking_offsets();

  inline bool has_geometry() const;
  inline void clear_has_geometry();

  inline bool has_markings() const;
  inline void clear_has_markings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::google::protobuf::Int64Value* lane_boundary_id_;
  ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* material_and_confidence_;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* color_and_confidence_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* height_and_accuracy_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_between_double_and_accuracy_;
  int position_reference_;
  union GeometryUnion {
    GeometryUnion() {}
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* polyline_and_accuracy_;
  } geometry_;
  union MarkingsUnion {
    MarkingsUnion() {}
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* dash_statistics_;
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* marking_offsets_;
  } markings_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundaryMergeSplit_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence) */ {
 public:
  LaneBoundaryMergeSplit_TypeAndConfidence();
  virtual ~LaneBoundaryMergeSplit_TypeAndConfidence();

  LaneBoundaryMergeSplit_TypeAndConfidence(const LaneBoundaryMergeSplit_TypeAndConfidence& from);

  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(const LaneBoundaryMergeSplit_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundaryMergeSplit_TypeAndConfidence(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept
    : LaneBoundaryMergeSplit_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryMergeSplit_TypeAndConfidence& operator=(LaneBoundaryMergeSplit_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundaryMergeSplit_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundaryMergeSplit_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryMergeSplit_TypeAndConfidence*>(
               &_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(LaneBoundaryMergeSplit_TypeAndConfidence* other);
  void Swap(LaneBoundaryMergeSplit_TypeAndConfidence* other);
  friend void swap(LaneBoundaryMergeSplit_TypeAndConfidence& a, LaneBoundaryMergeSplit_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundaryMergeSplit_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit_TypeAndConfidence>(NULL);
  }

  LaneBoundaryMergeSplit_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  void MergeFrom(const LaneBoundaryMergeSplit_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundaryMergeSplit_TypeAndConfidence* other);
  protected:
  explicit LaneBoundaryMergeSplit_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundaryMergeSplit_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type MERGE =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_MERGE;
  static const Type SPLIT =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_SPLIT;
  static inline bool Type_IsValid(int value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneBoundaryMergeSplit_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneBoundaryMergeSplit_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneBoundaryMergeSplit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit) */ {
 public:
  LaneBoundaryMergeSplit();
  virtual ~LaneBoundaryMergeSplit();

  LaneBoundaryMergeSplit(const LaneBoundaryMergeSplit& from);

  inline LaneBoundaryMergeSplit& operator=(const LaneBoundaryMergeSplit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundaryMergeSplit(LaneBoundaryMergeSplit&& from) noexcept
    : LaneBoundaryMergeSplit() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryMergeSplit& operator=(LaneBoundaryMergeSplit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundaryMergeSplit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundaryMergeSplit* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryMergeSplit*>(
               &_LaneBoundaryMergeSplit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void UnsafeArenaSwap(LaneBoundaryMergeSplit* other);
  void Swap(LaneBoundaryMergeSplit* other);
  friend void swap(LaneBoundaryMergeSplit& a, LaneBoundaryMergeSplit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundaryMergeSplit* New() const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit>(NULL);
  }

  LaneBoundaryMergeSplit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundaryMergeSplit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundaryMergeSplit& from);
  void MergeFrom(const LaneBoundaryMergeSplit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundaryMergeSplit* other);
  protected:
  explicit LaneBoundaryMergeSplit(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundaryMergeSplit_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence);
  void unsafe_arena_set_allocated_existence_confidence(
      ::sensoris::protobuf::types::base::Confidence* existence_confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void UnsafeArenaSwap(Lane* other);
  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  protected:
  explicit Lane(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .google.protobuf.Int64Value relative_lane_id = 2;
  bool has_relative_lane_id() const;
  void clear_relative_lane_id();
  static const int kRelativeLaneIdFieldNumber = 2;
  private:
  const ::google::protobuf::Int64Value& _internal_relative_lane_id() const;
  public:
  const ::google::protobuf::Int64Value& relative_lane_id() const;
  ::google::protobuf::Int64Value* release_relative_lane_id();
  ::google::protobuf::Int64Value* mutable_relative_lane_id();
  void set_allocated_relative_lane_id(::google::protobuf::Int64Value* relative_lane_id);
  void unsafe_arena_set_allocated_relative_lane_id(
      ::google::protobuf::Int64Value* relative_lane_id);
  ::google::protobuf::Int64Value* unsafe_arena_release_relative_lane_id();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy();
  static const int kWidthAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  void unsafe_arena_set_allocated_width_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature();
  static const int kInclinationAndCurvatureFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  void unsafe_arena_set_allocated_inclination_and_curvature(
      ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Lane)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::google::protobuf::Int64Value* relative_lane_id_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Road : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.Road) */ {
 public:
  Road();
  virtual ~Road();

  Road(const Road& from);

  inline Road& operator=(const Road& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Road(Road&& from) noexcept
    : Road() {
    *this = ::std::move(from);
  }

  inline Road& operator=(Road&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Road& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Road* internal_default_instance() {
    return reinterpret_cast<const Road*>(
               &_Road_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void UnsafeArenaSwap(Road* other);
  void Swap(Road* other);
  friend void swap(Road& a, Road& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Road* New() const final {
    return CreateMaybeMessage<Road>(NULL);
  }

  Road* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Road>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Road& from);
  void MergeFrom(const Road& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Road* other);
  protected:
  explicit Road(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
  bool has_width_and_accuracy() const;
  void clear_width_and_accuracy();
  static const int kWidthAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_width_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& width_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_width_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_width_and_accuracy();
  void set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  void unsafe_arena_set_allocated_width_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_width_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature();
  static const int kInclinationAndCurvatureFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  void unsafe_arena_set_allocated_inclination_and_curvature(
      ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.Road)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy_;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SurfaceMarking_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence) */ {
 public:
  SurfaceMarking_TypeAndConfidence();
  virtual ~SurfaceMarking_TypeAndConfidence();

  SurfaceMarking_TypeAndConfidence(const SurfaceMarking_TypeAndConfidence& from);

  inline SurfaceMarking_TypeAndConfidence& operator=(const SurfaceMarking_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceMarking_TypeAndConfidence(SurfaceMarking_TypeAndConfidence&& from) noexcept
    : SurfaceMarking_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline SurfaceMarking_TypeAndConfidence& operator=(SurfaceMarking_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceMarking_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceMarking_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const SurfaceMarking_TypeAndConfidence*>(
               &_SurfaceMarking_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void UnsafeArenaSwap(SurfaceMarking_TypeAndConfidence* other);
  void Swap(SurfaceMarking_TypeAndConfidence* other);
  friend void swap(SurfaceMarking_TypeAndConfidence& a, SurfaceMarking_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceMarking_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<SurfaceMarking_TypeAndConfidence>(NULL);
  }

  SurfaceMarking_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceMarking_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceMarking_TypeAndConfidence& from);
  void MergeFrom(const SurfaceMarking_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceMarking_TypeAndConfidence* other);
  protected:
  explicit SurfaceMarking_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SurfaceMarking_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    SurfaceMarking_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type SIGN =
    SurfaceMarking_TypeAndConfidence_Type_SIGN;
  static const Type TEXT =
    SurfaceMarking_TypeAndConfidence_Type_TEXT;
  static const Type ICON =
    SurfaceMarking_TypeAndConfidence_Type_ICON;
  static const Type PATTERN =
    SurfaceMarking_TypeAndConfidence_Type_PATTERN;
  static const Type PATTERN_CROSSWALK =
    SurfaceMarking_TypeAndConfidence_Type_PATTERN_CROSSWALK;
  static const Type LINE_ELEMENT =
    SurfaceMarking_TypeAndConfidence_Type_LINE_ELEMENT;
  static const Type STOP_LINE =
    SurfaceMarking_TypeAndConfidence_Type_STOP_LINE;
  static inline bool Type_IsValid(int value) {
    return SurfaceMarking_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SurfaceMarking_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    SurfaceMarking_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SurfaceMarking_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return SurfaceMarking_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return SurfaceMarking_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return SurfaceMarking_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SurfaceMarking : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceMarking) */ {
 public:
  SurfaceMarking();
  virtual ~SurfaceMarking();

  SurfaceMarking(const SurfaceMarking& from);

  inline SurfaceMarking& operator=(const SurfaceMarking& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceMarking(SurfaceMarking&& from) noexcept
    : SurfaceMarking() {
    *this = ::std::move(from);
  }

  inline SurfaceMarking& operator=(SurfaceMarking&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceMarking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceMarking* internal_default_instance() {
    return reinterpret_cast<const SurfaceMarking*>(
               &_SurfaceMarking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void UnsafeArenaSwap(SurfaceMarking* other);
  void Swap(SurfaceMarking* other);
  friend void swap(SurfaceMarking& a, SurfaceMarking& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceMarking* New() const final {
    return CreateMaybeMessage<SurfaceMarking>(NULL);
  }

  SurfaceMarking* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceMarking>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceMarking& from);
  void MergeFrom(const SurfaceMarking& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceMarking* other);
  protected:
  explicit SurfaceMarking(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SurfaceMarking_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
  int color_and_confidence_size() const;
  void clear_color_and_confidence();
  static const int kColorAndConfidenceFieldNumber = 6;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* mutable_color_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >*
      mutable_color_and_confidence();
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& color_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* add_color_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >&
      color_and_confidence() const;

  // repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
  int material_and_confidence_size() const;
  void clear_material_and_confidence();
  static const int kMaterialAndConfidenceFieldNumber = 7;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >*
      mutable_material_and_confidence();
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >&
      material_and_confidence() const;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence);
  void unsafe_arena_set_allocated_existence_confidence(
      ::sensoris::protobuf::types::base::Confidence* existence_confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .google.protobuf.StringValue text = 5;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 5;
  private:
  const ::google::protobuf::StringValue& _internal_text() const;
  public:
  const ::google::protobuf::StringValue& text() const;
  ::google::protobuf::StringValue* release_text();
  ::google::protobuf::StringValue* mutable_text();
  void set_allocated_text(::google::protobuf::StringValue* text);
  void unsafe_arena_set_allocated_text(
      ::google::protobuf::StringValue* text);
  ::google::protobuf::StringValue* unsafe_arena_release_text();

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
  bool has_rectangular_box_and_accuracy() const;
  void clear_rectangular_box_and_accuracy();
  static const int kRectangularBoxAndAccuracyFieldNumber = 8;
  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& _internal_rectangular_box_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& rectangular_box_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* release_rectangular_box_and_accuracy();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* mutable_rectangular_box_and_accuracy();
  void set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy);
  void unsafe_arena_set_allocated_rectangular_box_and_accuracy(
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* unsafe_arena_release_rectangular_box_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceMarking)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence > color_and_confidence_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence > material_and_confidence_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* type_and_confidence_;
  ::google::protobuf::StringValue* text_;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SurfaceAttribution : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.SurfaceAttribution) */ {
 public:
  SurfaceAttribution();
  virtual ~SurfaceAttribution();

  SurfaceAttribution(const SurfaceAttribution& from);

  inline SurfaceAttribution& operator=(const SurfaceAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceAttribution(SurfaceAttribution&& from) noexcept
    : SurfaceAttribution() {
    *this = ::std::move(from);
  }

  inline SurfaceAttribution& operator=(SurfaceAttribution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceAttribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceAttribution* internal_default_instance() {
    return reinterpret_cast<const SurfaceAttribution*>(
               &_SurfaceAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void UnsafeArenaSwap(SurfaceAttribution* other);
  void Swap(SurfaceAttribution* other);
  friend void swap(SurfaceAttribution& a, SurfaceAttribution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceAttribution* New() const final {
    return CreateMaybeMessage<SurfaceAttribution>(NULL);
  }

  SurfaceAttribution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceAttribution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceAttribution& from);
  void MergeFrom(const SurfaceAttribution& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceAttribution* other);
  protected:
  explicit SurfaceAttribution(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
  int material_and_confidence_size() const;
  void clear_material_and_confidence();
  static const int kMaterialAndConfidenceFieldNumber = 4;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* mutable_material_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >*
      mutable_material_and_confidence();
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& material_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* add_material_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >&
      material_and_confidence() const;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
  bool has_inclination_and_curvature() const;
  void clear_inclination_and_curvature();
  static const int kInclinationAndCurvatureFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& _internal_inclination_and_curvature() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& inclination_and_curvature() const;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* release_inclination_and_curvature();
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* mutable_inclination_and_curvature();
  void set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  void unsafe_arena_set_allocated_inclination_and_curvature(
      ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature);
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* unsafe_arena_release_inclination_and_curvature();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_road_roughness_and_accuracy() const;
  void clear_road_roughness_and_accuracy();
  static const int kRoadRoughnessAndAccuracyFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_road_roughness_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& road_roughness_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_road_roughness_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_road_roughness_and_accuracy();
  void set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* road_roughness_and_accuracy);
  void unsafe_arena_set_allocated_road_roughness_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* road_roughness_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_road_roughness_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.SurfaceAttribution)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence > material_and_confidence_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* road_roughness_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadAttribution_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence) */ {
 public:
  RoadAttribution_TypeAndConfidence();
  virtual ~RoadAttribution_TypeAndConfidence();

  RoadAttribution_TypeAndConfidence(const RoadAttribution_TypeAndConfidence& from);

  inline RoadAttribution_TypeAndConfidence& operator=(const RoadAttribution_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadAttribution_TypeAndConfidence(RoadAttribution_TypeAndConfidence&& from) noexcept
    : RoadAttribution_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadAttribution_TypeAndConfidence& operator=(RoadAttribution_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadAttribution_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadAttribution_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution_TypeAndConfidence*>(
               &_RoadAttribution_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void UnsafeArenaSwap(RoadAttribution_TypeAndConfidence* other);
  void Swap(RoadAttribution_TypeAndConfidence* other);
  friend void swap(RoadAttribution_TypeAndConfidence& a, RoadAttribution_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadAttribution_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<RoadAttribution_TypeAndConfidence>(NULL);
  }

  RoadAttribution_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadAttribution_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadAttribution_TypeAndConfidence& from);
  void MergeFrom(const RoadAttribution_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadAttribution_TypeAndConfidence* other);
  protected:
  explicit RoadAttribution_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadAttribution_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    RoadAttribution_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type MOTORWAY =
    RoadAttribution_TypeAndConfidence_Type_MOTORWAY;
  static const Type ONE_WAY_TRAFFIC =
    RoadAttribution_TypeAndConfidence_Type_ONE_WAY_TRAFFIC;
  static const Type TWO_WAY_TRAFFIC =
    RoadAttribution_TypeAndConfidence_Type_TWO_WAY_TRAFFIC;
  static const Type OFFROAD =
    RoadAttribution_TypeAndConfidence_Type_OFFROAD;
  static const Type TUNNEL =
    RoadAttribution_TypeAndConfidence_Type_TUNNEL;
  static const Type BRIDGE =
    RoadAttribution_TypeAndConfidence_Type_BRIDGE;
  static const Type ARTIFICIAL_ILLUMINATION =
    RoadAttribution_TypeAndConfidence_Type_ARTIFICIAL_ILLUMINATION;
  static const Type ROAD_WORKS_NARROW_LANES =
    RoadAttribution_TypeAndConfidence_Type_ROAD_WORKS_NARROW_LANES;
  static const Type LANE_RIGHT =
    RoadAttribution_TypeAndConfidence_Type_LANE_RIGHT;
  static const Type LANE_LEFT =
    RoadAttribution_TypeAndConfidence_Type_LANE_LEFT;
  static const Type LANE_SPLIT_MIDDLE =
    RoadAttribution_TypeAndConfidence_Type_LANE_SPLIT_MIDDLE;
  static const Type LANE_MERGE_MIDDLE =
    RoadAttribution_TypeAndConfidence_Type_LANE_MERGE_MIDDLE;
  static const Type CROSSWALK =
    RoadAttribution_TypeAndConfidence_Type_CROSSWALK;
  static const Type CENTER_TURN_LANE =
    RoadAttribution_TypeAndConfidence_Type_CENTER_TURN_LANE;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoadAttribution_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    RoadAttribution_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoadAttribution_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoadAttribution_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoadAttribution_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoadAttribution_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadAttribution_ChangeTypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence) */ {
 public:
  RoadAttribution_ChangeTypeAndConfidence();
  virtual ~RoadAttribution_ChangeTypeAndConfidence();

  RoadAttribution_ChangeTypeAndConfidence(const RoadAttribution_ChangeTypeAndConfidence& from);

  inline RoadAttribution_ChangeTypeAndConfidence& operator=(const RoadAttribution_ChangeTypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadAttribution_ChangeTypeAndConfidence(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept
    : RoadAttribution_ChangeTypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadAttribution_ChangeTypeAndConfidence& operator=(RoadAttribution_ChangeTypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadAttribution_ChangeTypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadAttribution_ChangeTypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution_ChangeTypeAndConfidence*>(
               &_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void UnsafeArenaSwap(RoadAttribution_ChangeTypeAndConfidence* other);
  void Swap(RoadAttribution_ChangeTypeAndConfidence* other);
  friend void swap(RoadAttribution_ChangeTypeAndConfidence& a, RoadAttribution_ChangeTypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadAttribution_ChangeTypeAndConfidence* New() const final {
    return CreateMaybeMessage<RoadAttribution_ChangeTypeAndConfidence>(NULL);
  }

  RoadAttribution_ChangeTypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadAttribution_ChangeTypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadAttribution_ChangeTypeAndConfidence& from);
  void MergeFrom(const RoadAttribution_ChangeTypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadAttribution_ChangeTypeAndConfidence* other);
  protected:
  explicit RoadAttribution_ChangeTypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadAttribution_ChangeTypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    RoadAttribution_ChangeTypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type DETECTED =
    RoadAttribution_ChangeTypeAndConfidence_Type_DETECTED;
  static const Type START =
    RoadAttribution_ChangeTypeAndConfidence_Type_START;
  static const Type END =
    RoadAttribution_ChangeTypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoadAttribution_ChangeTypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    RoadAttribution_ChangeTypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoadAttribution_ChangeTypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoadAttribution_ChangeTypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadAttribution : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttribution) */ {
 public:
  RoadAttribution();
  virtual ~RoadAttribution();

  RoadAttribution(const RoadAttribution& from);

  inline RoadAttribution& operator=(const RoadAttribution& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadAttribution(RoadAttribution&& from) noexcept
    : RoadAttribution() {
    *this = ::std::move(from);
  }

  inline RoadAttribution& operator=(RoadAttribution&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadAttribution& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadAttribution* internal_default_instance() {
    return reinterpret_cast<const RoadAttribution*>(
               &_RoadAttribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void UnsafeArenaSwap(RoadAttribution* other);
  void Swap(RoadAttribution* other);
  friend void swap(RoadAttribution& a, RoadAttribution& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadAttribution* New() const final {
    return CreateMaybeMessage<RoadAttribution>(NULL);
  }

  RoadAttribution* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadAttribution>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadAttribution& from);
  void MergeFrom(const RoadAttribution& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadAttribution* other);
  protected:
  explicit RoadAttribution(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadAttribution_TypeAndConfidence TypeAndConfidence;
  typedef RoadAttribution_ChangeTypeAndConfidence ChangeTypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
  bool has_change_type_and_confidence() const;
  void clear_change_type_and_confidence();
  static const int kChangeTypeAndConfidenceFieldNumber = 5;
  private:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& _internal_change_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& change_type_and_confidence() const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* release_change_type_and_confidence();
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* mutable_change_type_and_confidence();
  void set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* change_type_and_confidence);
  void unsafe_arena_set_allocated_change_type_and_confidence(
      ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* change_type_and_confidence);
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* unsafe_arena_release_change_type_and_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttribution)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* change_type_and_confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneCountAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence) */ {
 public:
  LaneCountAndConfidence();
  virtual ~LaneCountAndConfidence();

  LaneCountAndConfidence(const LaneCountAndConfidence& from);

  inline LaneCountAndConfidence& operator=(const LaneCountAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneCountAndConfidence(LaneCountAndConfidence&& from) noexcept
    : LaneCountAndConfidence() {
    *this = ::std::move(from);
  }

  inline LaneCountAndConfidence& operator=(LaneCountAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneCountAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneCountAndConfidence* internal_default_instance() {
    return reinterpret_cast<const LaneCountAndConfidence*>(
               &_LaneCountAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void UnsafeArenaSwap(LaneCountAndConfidence* other);
  void Swap(LaneCountAndConfidence* other);
  friend void swap(LaneCountAndConfidence& a, LaneCountAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneCountAndConfidence* New() const final {
    return CreateMaybeMessage<LaneCountAndConfidence>(NULL);
  }

  LaneCountAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneCountAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneCountAndConfidence& from);
  void MergeFrom(const LaneCountAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneCountAndConfidence* other);
  protected:
  explicit LaneCountAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneCountAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    LaneCountAndConfidence_Type_UNKNOWN_TYPE;
  static const Type TOTAL =
    LaneCountAndConfidence_Type_TOTAL;
  static const Type LEFT_INCLUDING_EGO_LANE =
    LaneCountAndConfidence_Type_LEFT_INCLUDING_EGO_LANE;
  static const Type RIGHT =
    LaneCountAndConfidence_Type_RIGHT;
  static inline bool Type_IsValid(int value) {
    return LaneCountAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    LaneCountAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    LaneCountAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    LaneCountAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return LaneCountAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return LaneCountAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return LaneCountAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
  bool has_count_and_confidence() const;
  void clear_count_and_confidence();
  static const int kCountAndConfidenceFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_count_and_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::CountAndConfidence& count_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* release_count_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* mutable_count_and_confidence();
  void set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* count_and_confidence);
  void unsafe_arena_set_allocated_count_and_confidence(
      ::sensoris::protobuf::types::base::CountAndConfidence* count_and_confidence);
  ::sensoris::protobuf::types::base::CountAndConfidence* unsafe_arena_release_count_and_confidence();

  // .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  ::sensoris::protobuf::types::base::CountAndConfidence* count_and_confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadAttributionCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory) */ {
 public:
  RoadAttributionCategory();
  virtual ~RoadAttributionCategory();

  RoadAttributionCategory(const RoadAttributionCategory& from);

  inline RoadAttributionCategory& operator=(const RoadAttributionCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadAttributionCategory(RoadAttributionCategory&& from) noexcept
    : RoadAttributionCategory() {
    *this = ::std::move(from);
  }

  inline RoadAttributionCategory& operator=(RoadAttributionCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadAttributionCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadAttributionCategory* internal_default_instance() {
    return reinterpret_cast<const RoadAttributionCategory*>(
               &_RoadAttributionCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void UnsafeArenaSwap(RoadAttributionCategory* other);
  void Swap(RoadAttributionCategory* other);
  friend void swap(RoadAttributionCategory& a, RoadAttributionCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadAttributionCategory* New() const final {
    return CreateMaybeMessage<RoadAttributionCategory>(NULL);
  }

  RoadAttributionCategory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadAttributionCategory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadAttributionCategory& from);
  void MergeFrom(const RoadAttributionCategory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadAttributionCategory* other);
  protected:
  explicit RoadAttributionCategory(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
  int lane_boundary_size() const;
  void clear_lane_boundary();
  static const int kLaneBoundaryFieldNumber = 2;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* mutable_lane_boundary(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >*
      mutable_lane_boundary();
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& lane_boundary(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary* add_lane_boundary();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >&
      lane_boundary() const;

  // repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
  int lane_boundary_merge_split_size() const;
  void clear_lane_boundary_merge_split();
  static const int kLaneBoundaryMergeSplitFieldNumber = 3;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* mutable_lane_boundary_merge_split(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >*
      mutable_lane_boundary_merge_split();
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& lane_boundary_merge_split(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* add_lane_boundary_merge_split();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >&
      lane_boundary_merge_split() const;

  // repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
  int lane_size() const;
  void clear_lane();
  static const int kLaneFieldNumber = 4;
  ::sensoris::protobuf::categories::roadattribution::Lane* mutable_lane(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >*
      mutable_lane();
  const ::sensoris::protobuf::categories::roadattribution::Lane& lane(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Lane* add_lane();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >&
      lane() const;

  // repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
  int road_size() const;
  void clear_road();
  static const int kRoadFieldNumber = 5;
  ::sensoris::protobuf::categories::roadattribution::Road* mutable_road(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >*
      mutable_road();
  const ::sensoris::protobuf::categories::roadattribution::Road& road(int index) const;
  ::sensoris::protobuf::categories::roadattribution::Road* add_road();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >&
      road() const;

  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
  int surface_marking_size() const;
  void clear_surface_marking();
  static const int kSurfaceMarkingFieldNumber = 6;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* mutable_surface_marking(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >*
      mutable_surface_marking();
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& surface_marking(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* add_surface_marking();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >&
      surface_marking() const;

  // repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
  int surface_attribution_size() const;
  void clear_surface_attribution();
  static const int kSurfaceAttributionFieldNumber = 7;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* mutable_surface_attribution(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >*
      mutable_surface_attribution();
  const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& surface_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* add_surface_attribution();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >&
      surface_attribution() const;

  // repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
  int road_attribution_size() const;
  void clear_road_attribution();
  static const int kRoadAttributionFieldNumber = 8;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* mutable_road_attribution(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >*
      mutable_road_attribution();
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& road_attribution(int index) const;
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution* add_road_attribution();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >&
      road_attribution() const;

  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
  int detected_lane_count_and_confidence_size() const;
  void clear_detected_lane_count_and_confidence();
  static const int kDetectedLaneCountAndConfidenceFieldNumber = 9;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* mutable_detected_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
      mutable_detected_lane_count_and_confidence();
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& detected_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* add_detected_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
      detected_lane_count_and_confidence() const;

  // repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
  int estimated_lane_count_and_confidence_size() const;
  void clear_estimated_lane_count_and_confidence();
  static const int kEstimatedLaneCountAndConfidenceFieldNumber = 10;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* mutable_estimated_lane_count_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
      mutable_estimated_lane_count_and_confidence();
  const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& estimated_lane_count_and_confidence(int index) const;
  ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* add_estimated_lane_count_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
      estimated_lane_count_and_confidence() const;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary > lane_boundary_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit > lane_boundary_merge_split_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane > lane_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road > road_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking > surface_marking_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution > surface_attribution_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution > road_attribution_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > detected_lane_count_and_confidence_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence > estimated_lane_count_and_confidence_;
  ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MarkingColorAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.Type type = 1;
inline void MarkingColorAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type MarkingColorAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type >(type_);
}
inline void MarkingColorAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingColorAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingColorAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingColorAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
  return confidence_;
}
inline void MarkingColorAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence.confidence)
}

// -------------------------------------------------------------------

// MarkingMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.Type type = 1;
inline void MarkingMaterialAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type MarkingMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type >(type_);
}
inline void MarkingMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool MarkingMaterialAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& MarkingMaterialAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* MarkingMaterialAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
  return confidence_;
}
inline void MarkingMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMaterialAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.Type type = 1;
inline void SurfaceMaterialAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type SurfaceMaterialAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type >(type_);
}
inline void SurfaceMaterialAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMaterialAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMaterialAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMaterialAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
  return confidence_;
}
inline void SurfaceMaterialAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence.confidence)
}

// -------------------------------------------------------------------

// InclinationAndCurvature

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy longitudinal_inclination_and_accuracy = 1 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_longitudinal_inclination_and_accuracy() const {
  return this != internal_default_instance() && longitudinal_inclination_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_longitudinal_inclination_and_accuracy() const {
  return *longitudinal_inclination_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::longitudinal_inclination_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = longitudinal_inclination_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_longitudinal_inclination_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = longitudinal_inclination_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  longitudinal_inclination_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_longitudinal_inclination_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = longitudinal_inclination_and_accuracy_;
  longitudinal_inclination_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_longitudinal_inclination_and_accuracy() {
  
  if (longitudinal_inclination_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    longitudinal_inclination_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
  return longitudinal_inclination_and_accuracy_;
}
inline void InclinationAndCurvature::set_allocated_longitudinal_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* longitudinal_inclination_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(longitudinal_inclination_and_accuracy_);
  }
  if (longitudinal_inclination_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(longitudinal_inclination_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      longitudinal_inclination_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longitudinal_inclination_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  longitudinal_inclination_and_accuracy_ = longitudinal_inclination_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.longitudinal_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy lateral_inclination_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool InclinationAndCurvature::has_lateral_inclination_and_accuracy() const {
  return this != internal_default_instance() && lateral_inclination_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_lateral_inclination_and_accuracy() const {
  return *lateral_inclination_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::lateral_inclination_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = lateral_inclination_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_lateral_inclination_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = lateral_inclination_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  lateral_inclination_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_lateral_inclination_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = lateral_inclination_and_accuracy_;
  lateral_inclination_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_lateral_inclination_and_accuracy() {
  
  if (lateral_inclination_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    lateral_inclination_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
  return lateral_inclination_and_accuracy_;
}
inline void InclinationAndCurvature::set_allocated_lateral_inclination_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* lateral_inclination_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lateral_inclination_and_accuracy_);
  }
  if (lateral_inclination_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lateral_inclination_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      lateral_inclination_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lateral_inclination_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  lateral_inclination_and_accuracy_ = lateral_inclination_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.lateral_inclination_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy horizontal_curvature_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 3];
inline bool InclinationAndCurvature::has_horizontal_curvature_and_accuracy() const {
  return this != internal_default_instance() && horizontal_curvature_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::_internal_horizontal_curvature_and_accuracy() const {
  return *horizontal_curvature_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& InclinationAndCurvature::horizontal_curvature_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = horizontal_curvature_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::release_horizontal_curvature_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = horizontal_curvature_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  horizontal_curvature_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::unsafe_arena_release_horizontal_curvature_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = horizontal_curvature_and_accuracy_;
  horizontal_curvature_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* InclinationAndCurvature::mutable_horizontal_curvature_and_accuracy() {
  
  if (horizontal_curvature_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    horizontal_curvature_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
  return horizontal_curvature_and_accuracy_;
}
inline void InclinationAndCurvature::set_allocated_horizontal_curvature_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* horizontal_curvature_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(horizontal_curvature_and_accuracy_);
  }
  if (horizontal_curvature_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(horizontal_curvature_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      horizontal_curvature_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, horizontal_curvature_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  horizontal_curvature_and_accuracy_ = horizontal_curvature_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.InclinationAndCurvature.horizontal_curvature_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.Type type = 1;
inline void LaneBoundary_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type LaneBoundary_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type >(type_);
}
inline void LaneBoundary_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundary_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
  return confidence_;
}
inline void LaneBoundary_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundary_DashStatistics

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy length_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_length_and_accuracy() const {
  return this != internal_default_instance() && length_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_length_and_accuracy() const {
  return *length_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::length_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = length_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::release_length_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = length_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  length_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::unsafe_arena_release_length_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = length_and_accuracy_;
  length_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::mutable_length_and_accuracy() {
  
  if (length_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    length_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
  return length_and_accuracy_;
}
inline void LaneBoundary_DashStatistics::set_allocated_length_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* length_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(length_and_accuracy_);
  }
  if (length_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(length_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      length_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, length_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  length_and_accuracy_ = length_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.length_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_DashStatistics::has_distance_and_accuracy() const {
  return this != internal_default_instance() && distance_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::_internal_distance_and_accuracy() const {
  return *distance_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_DashStatistics::distance_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = distance_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::release_distance_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = distance_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  distance_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::unsafe_arena_release_distance_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = distance_and_accuracy_;
  distance_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_DashStatistics::mutable_distance_and_accuracy() {
  
  if (distance_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    distance_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
  return distance_and_accuracy_;
}
inline void LaneBoundary_DashStatistics::set_allocated_distance_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(distance_and_accuracy_);
  }
  if (distance_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(distance_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      distance_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distance_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  distance_and_accuracy_ = distance_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics.distance_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets_TypeAndOffset

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.Type type = 1;
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type LaneBoundary_MarkingOffsets_TypeAndOffset::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type >(type_);
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.type)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy offset_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary_MarkingOffsets_TypeAndOffset::has_offset_and_accuracy() const {
  return this != internal_default_instance() && offset_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::_internal_offset_and_accuracy() const {
  return *offset_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary_MarkingOffsets_TypeAndOffset::offset_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = offset_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::release_offset_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = offset_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  offset_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::unsafe_arena_release_offset_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = offset_and_accuracy_;
  offset_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary_MarkingOffsets_TypeAndOffset::mutable_offset_and_accuracy() {
  
  if (offset_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    offset_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
  return offset_and_accuracy_;
}
inline void LaneBoundary_MarkingOffsets_TypeAndOffset::set_allocated_offset_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* offset_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(offset_and_accuracy_);
  }
  if (offset_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(offset_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      offset_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, offset_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  offset_and_accuracy_ = offset_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset.offset_and_accuracy)
}

// -------------------------------------------------------------------

// LaneBoundary_MarkingOffsets

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.TypeAndOffset type_and_offset = 2;
inline int LaneBoundary_MarkingOffsets::type_and_offset_size() const {
  return type_and_offset_.size();
}
inline void LaneBoundary_MarkingOffsets::clear_type_and_offset() {
  type_and_offset_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* LaneBoundary_MarkingOffsets::mutable_type_and_offset(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return type_and_offset_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >*
LaneBoundary_MarkingOffsets::mutable_type_and_offset() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return &type_and_offset_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset& LaneBoundary_MarkingOffsets::type_and_offset(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return type_and_offset_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset* LaneBoundary_MarkingOffsets::add_type_and_offset() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return type_and_offset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset >&
LaneBoundary_MarkingOffsets::type_and_offset() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets.type_and_offset)
  return type_and_offset_;
}

// -------------------------------------------------------------------

// LaneBoundary

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundary::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundary::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundary::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
  return envelope_;
}
inline void LaneBoundary::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.envelope)
}

// .google.protobuf.Int64Value lane_boundary_id = 2;
inline bool LaneBoundary::has_lane_boundary_id() const {
  return this != internal_default_instance() && lane_boundary_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& LaneBoundary::_internal_lane_boundary_id() const {
  return *lane_boundary_id_;
}
inline const ::google::protobuf::Int64Value& LaneBoundary::lane_boundary_id() const {
  const ::google::protobuf::Int64Value* p = lane_boundary_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* LaneBoundary::release_lane_boundary_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  
  ::google::protobuf::Int64Value* temp = lane_boundary_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  lane_boundary_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* LaneBoundary::unsafe_arena_release_lane_boundary_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  
  ::google::protobuf::Int64Value* temp = lane_boundary_id_;
  lane_boundary_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* LaneBoundary::mutable_lane_boundary_id() {
  
  if (lane_boundary_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    lane_boundary_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
  return lane_boundary_id_;
}
inline void LaneBoundary::set_allocated_lane_boundary_id(::google::protobuf::Int64Value* lane_boundary_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lane_boundary_id_);
  }
  if (lane_boundary_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lane_boundary_id)->GetArena();
    if (message_arena != submessage_arena) {
      lane_boundary_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_boundary_id, submessage_arena);
    }
    
  } else {
    
  }
  lane_boundary_id_ = lane_boundary_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.lane_boundary_id)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 3;
inline bool LaneBoundary::has_existence_confidence() const {
  return this != internal_default_instance() && existence_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::_internal_existence_confidence() const {
  return *existence_confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundary::existence_confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = existence_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::release_existence_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::unsafe_arena_release_existence_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundary::mutable_existence_confidence() {
  
  if (existence_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    existence_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
  return existence_confidence_;
}
inline void LaneBoundary::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(existence_confidence_);
  }
  if (existence_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(existence_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      existence_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, existence_confidence, submessage_arena);
    }
    
  } else {
    
  }
  existence_confidence_ = existence_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 4;
inline bool LaneBoundary::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundary::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundary::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
  return detection_status_;
}
inline void LaneBoundary::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.TypeAndConfidence type_and_confidence = 5;
inline bool LaneBoundary::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void LaneBoundary::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence& LaneBoundary::type_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_LaneBoundary_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* LaneBoundary::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
  return type_and_confidence_;
}
inline void LaneBoundary::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 6;
inline bool LaneBoundary::has_material_and_confidence() const {
  return this != internal_default_instance() && material_and_confidence_ != NULL;
}
inline void LaneBoundary::clear_material_and_confidence() {
  if (GetArenaNoVirtual() == NULL && material_and_confidence_ != NULL) {
    delete material_and_confidence_;
  }
  material_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::_internal_material_and_confidence() const {
  return *material_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& LaneBoundary::material_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* p = material_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_MarkingMaterialAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::release_material_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* temp = material_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  material_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::unsafe_arena_release_material_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* temp = material_and_confidence_;
  material_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* LaneBoundary::mutable_material_and_confidence() {
  
  if (material_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence>(GetArenaNoVirtual());
    material_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
  return material_and_confidence_;
}
inline void LaneBoundary::set_allocated_material_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* material_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete material_and_confidence_;
  }
  if (material_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(material_and_confidence);
    if (message_arena != submessage_arena) {
      material_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, material_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  material_and_confidence_ = material_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.material_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 7;
inline bool LaneBoundary::has_color_and_confidence() const {
  return this != internal_default_instance() && color_and_confidence_ != NULL;
}
inline void LaneBoundary::clear_color_and_confidence() {
  if (GetArenaNoVirtual() == NULL && color_and_confidence_ != NULL) {
    delete color_and_confidence_;
  }
  color_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::_internal_color_and_confidence() const {
  return *color_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& LaneBoundary::color_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* p = color_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_MarkingColorAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::release_color_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* temp = color_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  color_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::unsafe_arena_release_color_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* temp = color_and_confidence_;
  color_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* LaneBoundary::mutable_color_and_confidence() {
  
  if (color_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence>(GetArenaNoVirtual());
    color_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
  return color_and_confidence_;
}
inline void LaneBoundary::set_allocated_color_and_confidence(::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* color_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_and_confidence_;
  }
  if (color_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(color_and_confidence);
    if (message_arena != submessage_arena) {
      color_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  color_and_confidence_ = color_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.color_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.PositionReference position_reference = 8;
inline void LaneBoundary::clear_position_reference() {
  position_reference_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference LaneBoundary::position_reference() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference >(position_reference_);
}
inline void LaneBoundary::set_position_reference(::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference value) {
  
  position_reference_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundary.position_reference)
}

// .sensoris.protobuf.types.spatial.PolylineAndAccuracy polyline_and_accuracy = 9;
inline bool LaneBoundary::has_polyline_and_accuracy() const {
  return geometry_case() == kPolylineAndAccuracy;
}
inline void LaneBoundary::set_has_polyline_and_accuracy() {
  _oneof_case_[0] = kPolylineAndAccuracy;
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::_internal_polyline_and_accuracy() const {
  return *geometry_.polyline_and_accuracy_;
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (has_polyline_and_accuracy()) {
    clear_has_geometry();
      ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* temp = geometry_.polyline_and_accuracy_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    geometry_.polyline_and_accuracy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::types::spatial::PolylineAndAccuracy& LaneBoundary::polyline_and_accuracy() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return has_polyline_and_accuracy()
      ? *geometry_.polyline_and_accuracy_
      : *reinterpret_cast< ::sensoris::protobuf::types::spatial::PolylineAndAccuracy*>(&::sensoris::protobuf::types::spatial::_PolylineAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::unsafe_arena_release_polyline_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  if (has_polyline_and_accuracy()) {
    clear_has_geometry();
    ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* temp = geometry_.polyline_and_accuracy_;
    geometry_.polyline_and_accuracy_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_polyline_and_accuracy(::sensoris::protobuf::types::spatial::PolylineAndAccuracy* polyline_and_accuracy) {
  clear_geometry();
  if (polyline_and_accuracy) {
    set_has_polyline_and_accuracy();
    geometry_.polyline_and_accuracy_ = polyline_and_accuracy;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
}
inline ::sensoris::protobuf::types::spatial::PolylineAndAccuracy* LaneBoundary::mutable_polyline_and_accuracy() {
  if (!has_polyline_and_accuracy()) {
    clear_geometry();
    set_has_polyline_and_accuracy();
    geometry_.polyline_and_accuracy_ = CreateMaybeMessage< ::sensoris::protobuf::types::spatial::PolylineAndAccuracy >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.polyline_and_accuracy)
  return geometry_.polyline_and_accuracy_;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 10 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_width_and_accuracy() const {
  return this != internal_default_instance() && width_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_width_and_accuracy() const {
  return *width_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::width_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = width_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_width_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_width_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_width_and_accuracy() {
  
  if (width_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    width_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
  return width_and_accuracy_;
}
inline void LaneBoundary::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(width_and_accuracy_);
  }
  if (width_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(width_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      width_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, width_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  width_and_accuracy_ = width_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.width_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy height_and_accuracy = 11 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_height_and_accuracy() const {
  return this != internal_default_instance() && height_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_height_and_accuracy() const {
  return *height_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::height_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = height_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_height_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = height_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  height_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_height_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = height_and_accuracy_;
  height_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_height_and_accuracy() {
  
  if (height_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    height_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
  return height_and_accuracy_;
}
inline void LaneBoundary::set_allocated_height_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* height_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(height_and_accuracy_);
  }
  if (height_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(height_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      height_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, height_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  height_and_accuracy_ = height_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.height_and_accuracy)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy distance_between_double_and_accuracy = 12 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool LaneBoundary::has_distance_between_double_and_accuracy() const {
  return this != internal_default_instance() && distance_between_double_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::_internal_distance_between_double_and_accuracy() const {
  return *distance_between_double_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& LaneBoundary::distance_between_double_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = distance_between_double_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::release_distance_between_double_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = distance_between_double_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  distance_between_double_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::unsafe_arena_release_distance_between_double_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = distance_between_double_and_accuracy_;
  distance_between_double_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* LaneBoundary::mutable_distance_between_double_and_accuracy() {
  
  if (distance_between_double_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    distance_between_double_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
  return distance_between_double_and_accuracy_;
}
inline void LaneBoundary::set_allocated_distance_between_double_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* distance_between_double_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(distance_between_double_and_accuracy_);
  }
  if (distance_between_double_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(distance_between_double_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      distance_between_double_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, distance_between_double_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  distance_between_double_and_accuracy_ = distance_between_double_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.distance_between_double_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.DashStatistics dash_statistics = 13;
inline bool LaneBoundary::has_dash_statistics() const {
  return markings_case() == kDashStatistics;
}
inline void LaneBoundary::set_has_dash_statistics() {
  _oneof_case_[1] = kDashStatistics;
}
inline void LaneBoundary::clear_dash_statistics() {
  if (has_dash_statistics()) {
    if (GetArenaNoVirtual() == NULL) {
      delete markings_.dash_statistics_;
    }
    clear_has_markings();
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::_internal_dash_statistics() const {
  return *markings_.dash_statistics_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::release_dash_statistics() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (has_dash_statistics()) {
    clear_has_markings();
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* temp = markings_.dash_statistics_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    markings_.dash_statistics_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics& LaneBoundary::dash_statistics() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return has_dash_statistics()
      ? *markings_.dash_statistics_
      : *reinterpret_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics*>(&::sensoris::protobuf::categories::roadattribution::_LaneBoundary_DashStatistics_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::unsafe_arena_release_dash_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  if (has_dash_statistics()) {
    clear_has_markings();
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* temp = markings_.dash_statistics_;
    markings_.dash_statistics_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_dash_statistics(::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* dash_statistics) {
  clear_markings();
  if (dash_statistics) {
    set_has_dash_statistics();
    markings_.dash_statistics_ = dash_statistics;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics* LaneBoundary::mutable_dash_statistics() {
  if (!has_dash_statistics()) {
    clear_markings();
    set_has_dash_statistics();
    markings_.dash_statistics_ = CreateMaybeMessage< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_DashStatistics >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.dash_statistics)
  return markings_.dash_statistics_;
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundary.MarkingOffsets marking_offsets = 14;
inline bool LaneBoundary::has_marking_offsets() const {
  return markings_case() == kMarkingOffsets;
}
inline void LaneBoundary::set_has_marking_offsets() {
  _oneof_case_[1] = kMarkingOffsets;
}
inline void LaneBoundary::clear_marking_offsets() {
  if (has_marking_offsets()) {
    if (GetArenaNoVirtual() == NULL) {
      delete markings_.marking_offsets_;
    }
    clear_has_markings();
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::_internal_marking_offsets() const {
  return *markings_.marking_offsets_;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::release_marking_offsets() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (has_marking_offsets()) {
    clear_has_markings();
      ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* temp = markings_.marking_offsets_;
    if (GetArenaNoVirtual() != NULL) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    markings_.marking_offsets_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets& LaneBoundary::marking_offsets() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return has_marking_offsets()
      ? *markings_.marking_offsets_
      : *reinterpret_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets*>(&::sensoris::protobuf::categories::roadattribution::_LaneBoundary_MarkingOffsets_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::unsafe_arena_release_marking_offsets() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  if (has_marking_offsets()) {
    clear_has_markings();
    ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* temp = markings_.marking_offsets_;
    markings_.marking_offsets_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LaneBoundary::unsafe_arena_set_allocated_marking_offsets(::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* marking_offsets) {
  clear_markings();
  if (marking_offsets) {
    set_has_marking_offsets();
    markings_.marking_offsets_ = marking_offsets;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets* LaneBoundary::mutable_marking_offsets() {
  if (!has_marking_offsets()) {
    clear_markings();
    set_has_marking_offsets();
    markings_.marking_offsets_ = CreateMaybeMessage< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundary.marking_offsets)
  return markings_.marking_offsets_;
}

inline bool LaneBoundary::has_geometry() const {
  return geometry_case() != GEOMETRY_NOT_SET;
}
inline void LaneBoundary::clear_has_geometry() {
  _oneof_case_[0] = GEOMETRY_NOT_SET;
}
inline bool LaneBoundary::has_markings() const {
  return markings_case() != MARKINGS_NOT_SET;
}
inline void LaneBoundary::clear_has_markings() {
  _oneof_case_[1] = MARKINGS_NOT_SET;
}
inline LaneBoundary::GeometryCase LaneBoundary::geometry_case() const {
  return LaneBoundary::GeometryCase(_oneof_case_[0]);
}
inline LaneBoundary::MarkingsCase LaneBoundary::markings_case() const {
  return LaneBoundary::MarkingsCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// LaneBoundaryMergeSplit_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.Type type = 1;
inline void LaneBoundaryMergeSplit_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type LaneBoundaryMergeSplit_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type >(type_);
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool LaneBoundaryMergeSplit_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
  return confidence_;
}
inline void LaneBoundaryMergeSplit_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// LaneBoundaryMergeSplit

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneBoundaryMergeSplit::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneBoundaryMergeSplit::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneBoundaryMergeSplit::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
  return envelope_;
}
inline void LaneBoundaryMergeSplit::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool LaneBoundaryMergeSplit::has_existence_confidence() const {
  return this != internal_default_instance() && existence_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::_internal_existence_confidence() const {
  return *existence_confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& LaneBoundaryMergeSplit::existence_confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = existence_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::release_existence_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::unsafe_arena_release_existence_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* LaneBoundaryMergeSplit::mutable_existence_confidence() {
  
  if (existence_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    existence_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
  return existence_confidence_;
}
inline void LaneBoundaryMergeSplit::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(existence_confidence_);
  }
  if (existence_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(existence_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      existence_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, existence_confidence, submessage_arena);
    }
    
  } else {
    
  }
  existence_confidence_ = existence_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool LaneBoundaryMergeSplit::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& LaneBoundaryMergeSplit::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* LaneBoundaryMergeSplit::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
  return detection_status_;
}
inline void LaneBoundaryMergeSplit::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.TypeAndConfidence type_and_confidence = 4;
inline bool LaneBoundaryMergeSplit::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void LaneBoundaryMergeSplit::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence& LaneBoundaryMergeSplit::type_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_LaneBoundaryMergeSplit_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* LaneBoundaryMergeSplit::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
  return type_and_confidence_;
}
inline void LaneBoundaryMergeSplit::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.type_and_confidence)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 5;
inline bool LaneBoundaryMergeSplit::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneBoundaryMergeSplit::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneBoundaryMergeSplit::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
  return position_and_accuracy_;
}
inline void LaneBoundaryMergeSplit::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_and_accuracy_);
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(position_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit.position_and_accuracy)
}

// -------------------------------------------------------------------

// Lane

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Lane::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Lane::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Lane::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.envelope)
  return envelope_;
}
inline void Lane::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.envelope)
}

// .google.protobuf.Int64Value relative_lane_id = 2;
inline bool Lane::has_relative_lane_id() const {
  return this != internal_default_instance() && relative_lane_id_ != NULL;
}
inline const ::google::protobuf::Int64Value& Lane::_internal_relative_lane_id() const {
  return *relative_lane_id_;
}
inline const ::google::protobuf::Int64Value& Lane::relative_lane_id() const {
  const ::google::protobuf::Int64Value* p = relative_lane_id_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* Lane::release_relative_lane_id() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  
  ::google::protobuf::Int64Value* temp = relative_lane_id_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  relative_lane_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* Lane::unsafe_arena_release_relative_lane_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  
  ::google::protobuf::Int64Value* temp = relative_lane_id_;
  relative_lane_id_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* Lane::mutable_relative_lane_id() {
  
  if (relative_lane_id_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    relative_lane_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
  return relative_lane_id_;
}
inline void Lane::set_allocated_relative_lane_id(::google::protobuf::Int64Value* relative_lane_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(relative_lane_id_);
  }
  if (relative_lane_id) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(relative_lane_id)->GetArena();
    if (message_arena != submessage_arena) {
      relative_lane_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_lane_id, submessage_arena);
    }
    
  } else {
    
  }
  relative_lane_id_ = relative_lane_id;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.relative_lane_id)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool Lane::has_width_and_accuracy() const {
  return this != internal_default_instance() && width_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::_internal_width_and_accuracy() const {
  return *width_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Lane::width_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = width_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::release_width_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::unsafe_arena_release_width_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Lane::mutable_width_and_accuracy() {
  
  if (width_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    width_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
  return width_and_accuracy_;
}
inline void Lane::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(width_and_accuracy_);
  }
  if (width_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(width_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      width_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, width_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  width_and_accuracy_ = width_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 4;
inline bool Lane::has_inclination_and_curvature() const {
  return this != internal_default_instance() && inclination_and_curvature_ != NULL;
}
inline void Lane::clear_inclination_and_curvature() {
  if (GetArenaNoVirtual() == NULL && inclination_and_curvature_ != NULL) {
    delete inclination_and_curvature_;
  }
  inclination_and_curvature_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::_internal_inclination_and_curvature() const {
  return *inclination_and_curvature_;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Lane::inclination_and_curvature() const {
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = inclination_and_curvature_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(
      &::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::unsafe_arena_release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Lane::mutable_inclination_and_curvature() {
  
  if (inclination_and_curvature_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArenaNoVirtual());
    inclination_and_curvature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
  return inclination_and_curvature_;
}
inline void Lane::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inclination_and_curvature_;
  }
  if (inclination_and_curvature) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(inclination_and_curvature);
    if (message_arena != submessage_arena) {
      inclination_and_curvature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inclination_and_curvature, submessage_arena);
    }
    
  } else {
    
  }
  inclination_and_curvature_ = inclination_and_curvature;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Lane.inclination_and_curvature)
}

// -------------------------------------------------------------------

// Road

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Road::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Road::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Road.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Road::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.envelope)
  return envelope_;
}
inline void Road::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.envelope)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy width_and_accuracy = 2;
inline bool Road::has_width_and_accuracy() const {
  return this != internal_default_instance() && width_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::_internal_width_and_accuracy() const {
  return *width_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& Road::width_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = width_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::release_width_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::unsafe_arena_release_width_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = width_and_accuracy_;
  width_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* Road::mutable_width_and_accuracy() {
  
  if (width_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    width_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
  return width_and_accuracy_;
}
inline void Road::set_allocated_width_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* width_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(width_and_accuracy_);
  }
  if (width_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(width_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      width_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, width_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  width_and_accuracy_ = width_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.width_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool Road::has_inclination_and_curvature() const {
  return this != internal_default_instance() && inclination_and_curvature_ != NULL;
}
inline void Road::clear_inclination_and_curvature() {
  if (GetArenaNoVirtual() == NULL && inclination_and_curvature_ != NULL) {
    delete inclination_and_curvature_;
  }
  inclination_and_curvature_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::_internal_inclination_and_curvature() const {
  return *inclination_and_curvature_;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& Road::inclination_and_curvature() const {
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = inclination_and_curvature_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(
      &::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::unsafe_arena_release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* Road::mutable_inclination_and_curvature() {
  
  if (inclination_and_curvature_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArenaNoVirtual());
    inclination_and_curvature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
  return inclination_and_curvature_;
}
inline void Road::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inclination_and_curvature_;
  }
  if (inclination_and_curvature) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(inclination_and_curvature);
    if (message_arena != submessage_arena) {
      inclination_and_curvature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inclination_and_curvature, submessage_arena);
    }
    
  } else {
    
  }
  inclination_and_curvature_ = inclination_and_curvature;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.Road.inclination_and_curvature)
}

// -------------------------------------------------------------------

// SurfaceMarking_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.Type type = 1;
inline void SurfaceMarking_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type SurfaceMarking_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type >(type_);
}
inline void SurfaceMarking_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool SurfaceMarking_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
  return confidence_;
}
inline void SurfaceMarking_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// SurfaceMarking

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceMarking::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceMarking::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceMarking::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
  return envelope_;
}
inline void SurfaceMarking::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool SurfaceMarking::has_existence_confidence() const {
  return this != internal_default_instance() && existence_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::_internal_existence_confidence() const {
  return *existence_confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& SurfaceMarking::existence_confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = existence_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::release_existence_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::unsafe_arena_release_existence_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* SurfaceMarking::mutable_existence_confidence() {
  
  if (existence_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    existence_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
  return existence_confidence_;
}
inline void SurfaceMarking::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(existence_confidence_);
  }
  if (existence_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(existence_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      existence_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, existence_confidence, submessage_arena);
    }
    
  } else {
    
  }
  existence_confidence_ = existence_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool SurfaceMarking::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& SurfaceMarking::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* SurfaceMarking::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
  return detection_status_;
}
inline void SurfaceMarking::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.detection_status)
}

// .sensoris.protobuf.categories.roadattribution.SurfaceMarking.TypeAndConfidence type_and_confidence = 4;
inline bool SurfaceMarking::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void SurfaceMarking::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence& SurfaceMarking::type_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_SurfaceMarking_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* SurfaceMarking::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
  return type_and_confidence_;
}
inline void SurfaceMarking::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.type_and_confidence)
}

// .google.protobuf.StringValue text = 5;
inline bool SurfaceMarking::has_text() const {
  return this != internal_default_instance() && text_ != NULL;
}
inline const ::google::protobuf::StringValue& SurfaceMarking::_internal_text() const {
  return *text_;
}
inline const ::google::protobuf::StringValue& SurfaceMarking::text() const {
  const ::google::protobuf::StringValue* p = text_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* SurfaceMarking::release_text() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  
  ::google::protobuf::StringValue* temp = text_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* SurfaceMarking::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  
  ::google::protobuf::StringValue* temp = text_;
  text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* SurfaceMarking::mutable_text() {
  
  if (text_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
  return text_;
}
inline void SurfaceMarking::set_allocated_text(::google::protobuf::StringValue* text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(text_);
  }
  if (text) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(text)->GetArena();
    if (message_arena != submessage_arena) {
      text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    
  } else {
    
  }
  text_ = text;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.text)
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingColorAndConfidence color_and_confidence = 6;
inline int SurfaceMarking::color_and_confidence_size() const {
  return color_and_confidence_.size();
}
inline void SurfaceMarking::clear_color_and_confidence() {
  color_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* SurfaceMarking::mutable_color_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return color_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >*
SurfaceMarking::mutable_color_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return &color_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence& SurfaceMarking::color_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return color_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence* SurfaceMarking::add_color_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return color_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence >&
SurfaceMarking::color_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.color_and_confidence)
  return color_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.MarkingMaterialAndConfidence material_and_confidence = 7;
inline int SurfaceMarking::material_and_confidence_size() const {
  return material_and_confidence_.size();
}
inline void SurfaceMarking::clear_material_and_confidence() {
  material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* SurfaceMarking::mutable_material_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return material_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >*
SurfaceMarking::mutable_material_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return &material_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence& SurfaceMarking::material_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return material_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence* SurfaceMarking::add_material_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return material_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence >&
SurfaceMarking::material_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceMarking.material_and_confidence)
  return material_and_confidence_;
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 8;
inline bool SurfaceMarking::has_rectangular_box_and_accuracy() const {
  return this != internal_default_instance() && rectangular_box_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::_internal_rectangular_box_and_accuracy() const {
  return *rectangular_box_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& SurfaceMarking::rectangular_box_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* p = rectangular_box_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::release_rectangular_box_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = rectangular_box_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  rectangular_box_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::unsafe_arena_release_rectangular_box_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = rectangular_box_and_accuracy_;
  rectangular_box_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* SurfaceMarking::mutable_rectangular_box_and_accuracy() {
  
  if (rectangular_box_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(GetArenaNoVirtual());
    rectangular_box_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
  return rectangular_box_and_accuracy_;
}
inline void SurfaceMarking::set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rectangular_box_and_accuracy_);
  }
  if (rectangular_box_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(rectangular_box_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      rectangular_box_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rectangular_box_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  rectangular_box_and_accuracy_ = rectangular_box_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceMarking.rectangular_box_and_accuracy)
}

// -------------------------------------------------------------------

// SurfaceAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool SurfaceAttribution::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& SurfaceAttribution::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* SurfaceAttribution::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
  return envelope_;
}
inline void SurfaceAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool SurfaceAttribution::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& SurfaceAttribution::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* SurfaceAttribution::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
  return position_and_accuracy_;
}
inline void SurfaceAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_and_accuracy_);
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(position_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.InclinationAndCurvature inclination_and_curvature = 3;
inline bool SurfaceAttribution::has_inclination_and_curvature() const {
  return this != internal_default_instance() && inclination_and_curvature_ != NULL;
}
inline void SurfaceAttribution::clear_inclination_and_curvature() {
  if (GetArenaNoVirtual() == NULL && inclination_and_curvature_ != NULL) {
    delete inclination_and_curvature_;
  }
  inclination_and_curvature_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::_internal_inclination_and_curvature() const {
  return *inclination_and_curvature_;
}
inline const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature& SurfaceAttribution::inclination_and_curvature() const {
  const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* p = inclination_and_curvature_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature*>(
      &::sensoris::protobuf::categories::roadattribution::_InclinationAndCurvature_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::unsafe_arena_release_inclination_and_curvature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  
  ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* temp = inclination_and_curvature_;
  inclination_and_curvature_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* SurfaceAttribution::mutable_inclination_and_curvature() {
  
  if (inclination_and_curvature_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature>(GetArenaNoVirtual());
    inclination_and_curvature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
  return inclination_and_curvature_;
}
inline void SurfaceAttribution::set_allocated_inclination_and_curvature(::sensoris::protobuf::categories::roadattribution::InclinationAndCurvature* inclination_and_curvature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete inclination_and_curvature_;
  }
  if (inclination_and_curvature) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(inclination_and_curvature);
    if (message_arena != submessage_arena) {
      inclination_and_curvature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inclination_and_curvature, submessage_arena);
    }
    
  } else {
    
  }
  inclination_and_curvature_ = inclination_and_curvature;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.inclination_and_curvature)
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMaterialAndConfidence material_and_confidence = 4;
inline int SurfaceAttribution::material_and_confidence_size() const {
  return material_and_confidence_.size();
}
inline void SurfaceAttribution::clear_material_and_confidence() {
  material_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* SurfaceAttribution::mutable_material_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return material_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >*
SurfaceAttribution::mutable_material_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return &material_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence& SurfaceAttribution::material_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return material_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence* SurfaceAttribution::add_material_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return material_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence >&
SurfaceAttribution::material_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.material_and_confidence)
  return material_and_confidence_;
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy road_roughness_and_accuracy = 5 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool SurfaceAttribution::has_road_roughness_and_accuracy() const {
  return this != internal_default_instance() && road_roughness_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::_internal_road_roughness_and_accuracy() const {
  return *road_roughness_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& SurfaceAttribution::road_roughness_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = road_roughness_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::release_road_roughness_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = road_roughness_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  road_roughness_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::unsafe_arena_release_road_roughness_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = road_roughness_and_accuracy_;
  road_roughness_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* SurfaceAttribution::mutable_road_roughness_and_accuracy() {
  
  if (road_roughness_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    road_roughness_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
  return road_roughness_and_accuracy_;
}
inline void SurfaceAttribution::set_allocated_road_roughness_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* road_roughness_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(road_roughness_and_accuracy_);
  }
  if (road_roughness_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(road_roughness_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      road_roughness_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, road_roughness_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  road_roughness_and_accuracy_ = road_roughness_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.SurfaceAttribution.road_roughness_and_accuracy)
}

// -------------------------------------------------------------------

// RoadAttribution_TypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.Type type = 1;
inline void RoadAttribution_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type RoadAttribution_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type >(type_);
}
inline void RoadAttribution_TypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
  return confidence_;
}
inline void RoadAttribution_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution_ChangeTypeAndConfidence

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.Type type = 1;
inline void RoadAttribution_ChangeTypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type RoadAttribution_ChangeTypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type >(type_);
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadAttribution_ChangeTypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadAttribution_ChangeTypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadAttribution_ChangeTypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
  return confidence_;
}
inline void RoadAttribution_ChangeTypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadAttribution

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadAttribution::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadAttribution::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadAttribution::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
  return envelope_;
}
inline void RoadAttribution::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadAttribution::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadAttribution::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadAttribution::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
  return detection_status_;
}
inline void RoadAttribution::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.detection_status)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
inline bool RoadAttribution::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& RoadAttribution::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* RoadAttribution::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
  return position_and_accuracy_;
}
inline void RoadAttribution::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_and_accuracy_);
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(position_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.TypeAndConfidence type_and_confidence = 4;
inline bool RoadAttribution::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void RoadAttribution::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence& RoadAttribution::type_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_RoadAttribution_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* RoadAttribution::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
  return type_and_confidence_;
}
inline void RoadAttribution::set_allocated_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.type_and_confidence)
}

// .sensoris.protobuf.categories.roadattribution.RoadAttribution.ChangeTypeAndConfidence change_type_and_confidence = 5;
inline bool RoadAttribution::has_change_type_and_confidence() const {
  return this != internal_default_instance() && change_type_and_confidence_ != NULL;
}
inline void RoadAttribution::clear_change_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && change_type_and_confidence_ != NULL) {
    delete change_type_and_confidence_;
  }
  change_type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::_internal_change_type_and_confidence() const {
  return *change_type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence& RoadAttribution::change_type_and_confidence() const {
  const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* p = change_type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence*>(
      &::sensoris::protobuf::categories::roadattribution::_RoadAttribution_ChangeTypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::release_change_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* temp = change_type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  change_type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::unsafe_arena_release_change_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  
  ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* temp = change_type_and_confidence_;
  change_type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* RoadAttribution::mutable_change_type_and_confidence() {
  
  if (change_type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence>(GetArenaNoVirtual());
    change_type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
  return change_type_and_confidence_;
}
inline void RoadAttribution::set_allocated_change_type_and_confidence(::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence* change_type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete change_type_and_confidence_;
  }
  if (change_type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(change_type_and_confidence);
    if (message_arena != submessage_arena) {
      change_type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, change_type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  change_type_and_confidence_ = change_type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttribution.change_type_and_confidence)
}

// -------------------------------------------------------------------

// LaneCountAndConfidence

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool LaneCountAndConfidence::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& LaneCountAndConfidence::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* LaneCountAndConfidence::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
  return envelope_;
}
inline void LaneCountAndConfidence::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool LaneCountAndConfidence::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& LaneCountAndConfidence::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* LaneCountAndConfidence::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
  return position_and_accuracy_;
}
inline void LaneCountAndConfidence::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_and_accuracy_);
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(position_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.position_and_accuracy)
}

// .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.Type type = 3;
inline void LaneCountAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type LaneCountAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type >(type_);
}
inline void LaneCountAndConfidence::set_type(::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.type)
}

// .sensoris.protobuf.types.base.CountAndConfidence count_and_confidence = 4;
inline bool LaneCountAndConfidence::has_count_and_confidence() const {
  return this != internal_default_instance() && count_and_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::_internal_count_and_confidence() const {
  return *count_and_confidence_;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& LaneCountAndConfidence::count_and_confidence() const {
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = count_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence*>(
      &::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::release_count_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = count_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  count_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::unsafe_arena_release_count_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = count_and_confidence_;
  count_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* LaneCountAndConfidence::mutable_count_and_confidence() {
  
  if (count_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CountAndConfidence>(GetArenaNoVirtual());
    count_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
  return count_and_confidence_;
}
inline void LaneCountAndConfidence::set_allocated_count_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* count_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(count_and_confidence_);
  }
  if (count_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(count_and_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      count_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, count_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  count_and_confidence_ = count_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence.count_and_confidence)
}

// -------------------------------------------------------------------

// RoadAttributionCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool RoadAttributionCategory::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& RoadAttributionCategory::envelope() const {
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      &::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* RoadAttributionCategory::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
  return envelope_;
}
inline void RoadAttributionCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.envelope)
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundary lane_boundary = 2;
inline int RoadAttributionCategory::lane_boundary_size() const {
  return lane_boundary_.size();
}
inline void RoadAttributionCategory::clear_lane_boundary() {
  lane_boundary_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* RoadAttributionCategory::mutable_lane_boundary(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return lane_boundary_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >*
RoadAttributionCategory::mutable_lane_boundary() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return &lane_boundary_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundary& RoadAttributionCategory::lane_boundary(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return lane_boundary_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundary* RoadAttributionCategory::add_lane_boundary() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return lane_boundary_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundary >&
RoadAttributionCategory::lane_boundary() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary)
  return lane_boundary_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneBoundaryMergeSplit lane_boundary_merge_split = 3;
inline int RoadAttributionCategory::lane_boundary_merge_split_size() const {
  return lane_boundary_merge_split_.size();
}
inline void RoadAttributionCategory::clear_lane_boundary_merge_split() {
  lane_boundary_merge_split_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* RoadAttributionCategory::mutable_lane_boundary_merge_split(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return lane_boundary_merge_split_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >*
RoadAttributionCategory::mutable_lane_boundary_merge_split() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return &lane_boundary_merge_split_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit& RoadAttributionCategory::lane_boundary_merge_split(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return lane_boundary_merge_split_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit* RoadAttributionCategory::add_lane_boundary_merge_split() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return lane_boundary_merge_split_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit >&
RoadAttributionCategory::lane_boundary_merge_split() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane_boundary_merge_split)
  return lane_boundary_merge_split_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Lane lane = 4;
inline int RoadAttributionCategory::lane_size() const {
  return lane_.size();
}
inline void RoadAttributionCategory::clear_lane() {
  lane_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* RoadAttributionCategory::mutable_lane(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return lane_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >*
RoadAttributionCategory::mutable_lane() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return &lane_;
}
inline const ::sensoris::protobuf::categories::roadattribution::Lane& RoadAttributionCategory::lane(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return lane_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Lane* RoadAttributionCategory::add_lane() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return lane_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Lane >&
RoadAttributionCategory::lane() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.lane)
  return lane_;
}

// repeated .sensoris.protobuf.categories.roadattribution.Road road = 5;
inline int RoadAttributionCategory::road_size() const {
  return road_.size();
}
inline void RoadAttributionCategory::clear_road() {
  road_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::Road* RoadAttributionCategory::mutable_road(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return road_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >*
RoadAttributionCategory::mutable_road() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return &road_;
}
inline const ::sensoris::protobuf::categories::roadattribution::Road& RoadAttributionCategory::road(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return road_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::Road* RoadAttributionCategory::add_road() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return road_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::Road >&
RoadAttributionCategory::road() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road)
  return road_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceMarking surface_marking = 6;
inline int RoadAttributionCategory::surface_marking_size() const {
  return surface_marking_.size();
}
inline void RoadAttributionCategory::clear_surface_marking() {
  surface_marking_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* RoadAttributionCategory::mutable_surface_marking(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return surface_marking_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >*
RoadAttributionCategory::mutable_surface_marking() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return &surface_marking_;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceMarking& RoadAttributionCategory::surface_marking(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return surface_marking_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceMarking* RoadAttributionCategory::add_surface_marking() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return surface_marking_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking >&
RoadAttributionCategory::surface_marking() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_marking)
  return surface_marking_;
}

// repeated .sensoris.protobuf.categories.roadattribution.SurfaceAttribution surface_attribution = 7;
inline int RoadAttributionCategory::surface_attribution_size() const {
  return surface_attribution_.size();
}
inline void RoadAttributionCategory::clear_surface_attribution() {
  surface_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* RoadAttributionCategory::mutable_surface_attribution(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return surface_attribution_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >*
RoadAttributionCategory::mutable_surface_attribution() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return &surface_attribution_;
}
inline const ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution& RoadAttributionCategory::surface_attribution(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return surface_attribution_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution* RoadAttributionCategory::add_surface_attribution() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return surface_attribution_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::SurfaceAttribution >&
RoadAttributionCategory::surface_attribution() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.surface_attribution)
  return surface_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.RoadAttribution road_attribution = 8;
inline int RoadAttributionCategory::road_attribution_size() const {
  return road_attribution_.size();
}
inline void RoadAttributionCategory::clear_road_attribution() {
  road_attribution_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* RoadAttributionCategory::mutable_road_attribution(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return road_attribution_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >*
RoadAttributionCategory::mutable_road_attribution() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return &road_attribution_;
}
inline const ::sensoris::protobuf::categories::roadattribution::RoadAttribution& RoadAttributionCategory::road_attribution(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return road_attribution_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::RoadAttribution* RoadAttributionCategory::add_road_attribution() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return road_attribution_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::RoadAttribution >&
RoadAttributionCategory::road_attribution() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.road_attribution)
  return road_attribution_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence detected_lane_count_and_confidence = 9;
inline int RoadAttributionCategory::detected_lane_count_and_confidence_size() const {
  return detected_lane_count_and_confidence_.size();
}
inline void RoadAttributionCategory::clear_detected_lane_count_and_confidence() {
  detected_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::mutable_detected_lane_count_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return detected_lane_count_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
RoadAttributionCategory::mutable_detected_lane_count_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return &detected_lane_count_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::detected_lane_count_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return detected_lane_count_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::add_detected_lane_count_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return detected_lane_count_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
RoadAttributionCategory::detected_lane_count_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.detected_lane_count_and_confidence)
  return detected_lane_count_and_confidence_;
}

// repeated .sensoris.protobuf.categories.roadattribution.LaneCountAndConfidence estimated_lane_count_and_confidence = 10;
inline int RoadAttributionCategory::estimated_lane_count_and_confidence_size() const {
  return estimated_lane_count_and_confidence_.size();
}
inline void RoadAttributionCategory::clear_estimated_lane_count_and_confidence() {
  estimated_lane_count_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::mutable_estimated_lane_count_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return estimated_lane_count_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >*
RoadAttributionCategory::mutable_estimated_lane_count_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return &estimated_lane_count_and_confidence_;
}
inline const ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence& RoadAttributionCategory::estimated_lane_count_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return estimated_lane_count_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence* RoadAttributionCategory::add_estimated_lane_count_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return estimated_lane_count_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence >&
RoadAttributionCategory::estimated_lane_count_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.roadattribution.RoadAttributionCategory.estimated_lane_count_and_confidence)
  return estimated_lane_count_and_confidence_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace roadattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingColorAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::MarkingMaterialAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMaterialAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_MarkingOffsets_TypeAndOffset_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundary_PositionReference_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneBoundaryMergeSplit_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::SurfaceMarking_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::RoadAttribution_ChangeTypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::roadattribution::LaneCountAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2froad_5fattribution_2eproto

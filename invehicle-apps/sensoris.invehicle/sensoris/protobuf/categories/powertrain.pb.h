// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/powertrain.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sensoris/protobuf/types/base.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto 

namespace protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace powertrain {
class CruiseControlStatus;
class CruiseControlStatusDefaultTypeInternal;
extern CruiseControlStatusDefaultTypeInternal _CruiseControlStatus_default_instance_;
class EngineStatus;
class EngineStatusDefaultTypeInternal;
extern EngineStatusDefaultTypeInternal _EngineStatus_default_instance_;
class PowertrainCategory;
class PowertrainCategoryDefaultTypeInternal;
extern PowertrainCategoryDefaultTypeInternal _PowertrainCategory_default_instance_;
class TransmissionStatus;
class TransmissionStatusDefaultTypeInternal;
extern TransmissionStatusDefaultTypeInternal _TransmissionStatus_default_instance_;
}  // namespace powertrain
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::categories::powertrain::CruiseControlStatus* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::powertrain::CruiseControlStatus>(Arena*);
template<> ::sensoris::protobuf::categories::powertrain::EngineStatus* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::powertrain::EngineStatus>(Arena*);
template<> ::sensoris::protobuf::categories::powertrain::PowertrainCategory* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::powertrain::PowertrainCategory>(Arena*);
template<> ::sensoris::protobuf::categories::powertrain::TransmissionStatus* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::powertrain::TransmissionStatus>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace categories {
namespace powertrain {

enum EngineStatus_IgnitionStatus {
  EngineStatus_IgnitionStatus_UNKNOWN_IGNITION_STATUS = 0,
  EngineStatus_IgnitionStatus_IGNITION_LOCK = 1,
  EngineStatus_IgnitionStatus_IGNITION_OFF = 2,
  EngineStatus_IgnitionStatus_IGNITION_ACCESSORIES = 3,
  EngineStatus_IgnitionStatus_IGNITION_ON = 4,
  EngineStatus_IgnitionStatus_IGNITION_START = 5,
  EngineStatus_IgnitionStatus_EngineStatus_IgnitionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EngineStatus_IgnitionStatus_EngineStatus_IgnitionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EngineStatus_IgnitionStatus_IsValid(int value);
const EngineStatus_IgnitionStatus EngineStatus_IgnitionStatus_IgnitionStatus_MIN = EngineStatus_IgnitionStatus_UNKNOWN_IGNITION_STATUS;
const EngineStatus_IgnitionStatus EngineStatus_IgnitionStatus_IgnitionStatus_MAX = EngineStatus_IgnitionStatus_IGNITION_START;
const int EngineStatus_IgnitionStatus_IgnitionStatus_ARRAYSIZE = EngineStatus_IgnitionStatus_IgnitionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* EngineStatus_IgnitionStatus_descriptor();
inline const ::std::string& EngineStatus_IgnitionStatus_Name(EngineStatus_IgnitionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EngineStatus_IgnitionStatus_descriptor(), value);
}
inline bool EngineStatus_IgnitionStatus_Parse(
    const ::std::string& name, EngineStatus_IgnitionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EngineStatus_IgnitionStatus>(
    EngineStatus_IgnitionStatus_descriptor(), name, value);
}
enum EngineStatus_PowertrainStatus {
  EngineStatus_PowertrainStatus_UNKNOWN_POWERTRAIN_STATUS = 0,
  EngineStatus_PowertrainStatus_POWERTRAIN_OFF = 1,
  EngineStatus_PowertrainStatus_POWERTRAIN_ECO_MODE = 2,
  EngineStatus_PowertrainStatus_POWERTRAIN_READY = 3,
  EngineStatus_PowertrainStatus_EngineStatus_PowertrainStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EngineStatus_PowertrainStatus_EngineStatus_PowertrainStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EngineStatus_PowertrainStatus_IsValid(int value);
const EngineStatus_PowertrainStatus EngineStatus_PowertrainStatus_PowertrainStatus_MIN = EngineStatus_PowertrainStatus_UNKNOWN_POWERTRAIN_STATUS;
const EngineStatus_PowertrainStatus EngineStatus_PowertrainStatus_PowertrainStatus_MAX = EngineStatus_PowertrainStatus_POWERTRAIN_READY;
const int EngineStatus_PowertrainStatus_PowertrainStatus_ARRAYSIZE = EngineStatus_PowertrainStatus_PowertrainStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* EngineStatus_PowertrainStatus_descriptor();
inline const ::std::string& EngineStatus_PowertrainStatus_Name(EngineStatus_PowertrainStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    EngineStatus_PowertrainStatus_descriptor(), value);
}
inline bool EngineStatus_PowertrainStatus_Parse(
    const ::std::string& name, EngineStatus_PowertrainStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EngineStatus_PowertrainStatus>(
    EngineStatus_PowertrainStatus_descriptor(), name, value);
}
enum TransmissionStatus_GearMode {
  TransmissionStatus_GearMode_UNKNOWN_GEAR_MODE = 0,
  TransmissionStatus_GearMode_DRIVE = 1,
  TransmissionStatus_GearMode_MANUAL = 2,
  TransmissionStatus_GearMode_REVERSE = 3,
  TransmissionStatus_GearMode_PARK = 4,
  TransmissionStatus_GearMode_NEUTRAL = 5,
  TransmissionStatus_GearMode_TransmissionStatus_GearMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransmissionStatus_GearMode_TransmissionStatus_GearMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransmissionStatus_GearMode_IsValid(int value);
const TransmissionStatus_GearMode TransmissionStatus_GearMode_GearMode_MIN = TransmissionStatus_GearMode_UNKNOWN_GEAR_MODE;
const TransmissionStatus_GearMode TransmissionStatus_GearMode_GearMode_MAX = TransmissionStatus_GearMode_NEUTRAL;
const int TransmissionStatus_GearMode_GearMode_ARRAYSIZE = TransmissionStatus_GearMode_GearMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransmissionStatus_GearMode_descriptor();
inline const ::std::string& TransmissionStatus_GearMode_Name(TransmissionStatus_GearMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransmissionStatus_GearMode_descriptor(), value);
}
inline bool TransmissionStatus_GearMode_Parse(
    const ::std::string& name, TransmissionStatus_GearMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransmissionStatus_GearMode>(
    TransmissionStatus_GearMode_descriptor(), name, value);
}
enum TransmissionStatus_DriveMode {
  TransmissionStatus_DriveMode_UNKNOWN_DRIVE_MODE = 0,
  TransmissionStatus_DriveMode_ECO = 1,
  TransmissionStatus_DriveMode_COMFORT = 2,
  TransmissionStatus_DriveMode_SPORT = 3,
  TransmissionStatus_DriveMode_SUPER_SPORT = 4,
  TransmissionStatus_DriveMode_TransmissionStatus_DriveMode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransmissionStatus_DriveMode_TransmissionStatus_DriveMode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransmissionStatus_DriveMode_IsValid(int value);
const TransmissionStatus_DriveMode TransmissionStatus_DriveMode_DriveMode_MIN = TransmissionStatus_DriveMode_UNKNOWN_DRIVE_MODE;
const TransmissionStatus_DriveMode TransmissionStatus_DriveMode_DriveMode_MAX = TransmissionStatus_DriveMode_SUPER_SPORT;
const int TransmissionStatus_DriveMode_DriveMode_ARRAYSIZE = TransmissionStatus_DriveMode_DriveMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransmissionStatus_DriveMode_descriptor();
inline const ::std::string& TransmissionStatus_DriveMode_Name(TransmissionStatus_DriveMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransmissionStatus_DriveMode_descriptor(), value);
}
inline bool TransmissionStatus_DriveMode_Parse(
    const ::std::string& name, TransmissionStatus_DriveMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransmissionStatus_DriveMode>(
    TransmissionStatus_DriveMode_descriptor(), name, value);
}
enum CruiseControlStatus_Type {
  CruiseControlStatus_Type_UNKNOWN_TYPE = 0,
  CruiseControlStatus_Type_SPEED = 1,
  CruiseControlStatus_Type_SPEED_AND_DISTANCE = 2,
  CruiseControlStatus_Type_CruiseControlStatus_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CruiseControlStatus_Type_CruiseControlStatus_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CruiseControlStatus_Type_IsValid(int value);
const CruiseControlStatus_Type CruiseControlStatus_Type_Type_MIN = CruiseControlStatus_Type_UNKNOWN_TYPE;
const CruiseControlStatus_Type CruiseControlStatus_Type_Type_MAX = CruiseControlStatus_Type_SPEED_AND_DISTANCE;
const int CruiseControlStatus_Type_Type_ARRAYSIZE = CruiseControlStatus_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* CruiseControlStatus_Type_descriptor();
inline const ::std::string& CruiseControlStatus_Type_Name(CruiseControlStatus_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    CruiseControlStatus_Type_descriptor(), value);
}
inline bool CruiseControlStatus_Type_Parse(
    const ::std::string& name, CruiseControlStatus_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CruiseControlStatus_Type>(
    CruiseControlStatus_Type_descriptor(), name, value);
}
// ===================================================================

class EngineStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.powertrain.EngineStatus) */ {
 public:
  EngineStatus();
  virtual ~EngineStatus();

  EngineStatus(const EngineStatus& from);

  inline EngineStatus& operator=(const EngineStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EngineStatus(EngineStatus&& from) noexcept
    : EngineStatus() {
    *this = ::std::move(from);
  }

  inline EngineStatus& operator=(EngineStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const EngineStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EngineStatus* internal_default_instance() {
    return reinterpret_cast<const EngineStatus*>(
               &_EngineStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(EngineStatus* other);
  void Swap(EngineStatus* other);
  friend void swap(EngineStatus& a, EngineStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EngineStatus* New() const final {
    return CreateMaybeMessage<EngineStatus>(NULL);
  }

  EngineStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EngineStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EngineStatus& from);
  void MergeFrom(const EngineStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EngineStatus* other);
  protected:
  explicit EngineStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EngineStatus_IgnitionStatus IgnitionStatus;
  static const IgnitionStatus UNKNOWN_IGNITION_STATUS =
    EngineStatus_IgnitionStatus_UNKNOWN_IGNITION_STATUS;
  static const IgnitionStatus IGNITION_LOCK =
    EngineStatus_IgnitionStatus_IGNITION_LOCK;
  static const IgnitionStatus IGNITION_OFF =
    EngineStatus_IgnitionStatus_IGNITION_OFF;
  static const IgnitionStatus IGNITION_ACCESSORIES =
    EngineStatus_IgnitionStatus_IGNITION_ACCESSORIES;
  static const IgnitionStatus IGNITION_ON =
    EngineStatus_IgnitionStatus_IGNITION_ON;
  static const IgnitionStatus IGNITION_START =
    EngineStatus_IgnitionStatus_IGNITION_START;
  static inline bool IgnitionStatus_IsValid(int value) {
    return EngineStatus_IgnitionStatus_IsValid(value);
  }
  static const IgnitionStatus IgnitionStatus_MIN =
    EngineStatus_IgnitionStatus_IgnitionStatus_MIN;
  static const IgnitionStatus IgnitionStatus_MAX =
    EngineStatus_IgnitionStatus_IgnitionStatus_MAX;
  static const int IgnitionStatus_ARRAYSIZE =
    EngineStatus_IgnitionStatus_IgnitionStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IgnitionStatus_descriptor() {
    return EngineStatus_IgnitionStatus_descriptor();
  }
  static inline const ::std::string& IgnitionStatus_Name(IgnitionStatus value) {
    return EngineStatus_IgnitionStatus_Name(value);
  }
  static inline bool IgnitionStatus_Parse(const ::std::string& name,
      IgnitionStatus* value) {
    return EngineStatus_IgnitionStatus_Parse(name, value);
  }

  typedef EngineStatus_PowertrainStatus PowertrainStatus;
  static const PowertrainStatus UNKNOWN_POWERTRAIN_STATUS =
    EngineStatus_PowertrainStatus_UNKNOWN_POWERTRAIN_STATUS;
  static const PowertrainStatus POWERTRAIN_OFF =
    EngineStatus_PowertrainStatus_POWERTRAIN_OFF;
  static const PowertrainStatus POWERTRAIN_ECO_MODE =
    EngineStatus_PowertrainStatus_POWERTRAIN_ECO_MODE;
  static const PowertrainStatus POWERTRAIN_READY =
    EngineStatus_PowertrainStatus_POWERTRAIN_READY;
  static inline bool PowertrainStatus_IsValid(int value) {
    return EngineStatus_PowertrainStatus_IsValid(value);
  }
  static const PowertrainStatus PowertrainStatus_MIN =
    EngineStatus_PowertrainStatus_PowertrainStatus_MIN;
  static const PowertrainStatus PowertrainStatus_MAX =
    EngineStatus_PowertrainStatus_PowertrainStatus_MAX;
  static const int PowertrainStatus_ARRAYSIZE =
    EngineStatus_PowertrainStatus_PowertrainStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PowertrainStatus_descriptor() {
    return EngineStatus_PowertrainStatus_descriptor();
  }
  static inline const ::std::string& PowertrainStatus_Name(PowertrainStatus value) {
    return EngineStatus_PowertrainStatus_Name(value);
  }
  static inline bool PowertrainStatus_Parse(const ::std::string& name,
      PowertrainStatus* value) {
    return EngineStatus_PowertrainStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.categories.powertrain.EngineStatus.IgnitionStatus ignition_status = 2;
  void clear_ignition_status();
  static const int kIgnitionStatusFieldNumber = 2;
  ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus ignition_status() const;
  void set_ignition_status(::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus value);

  // .sensoris.protobuf.categories.powertrain.EngineStatus.PowertrainStatus powertrain_status = 3;
  void clear_powertrain_status();
  static const int kPowertrainStatusFieldNumber = 3;
  ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus powertrain_status() const;
  void set_powertrain_status(::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.powertrain.EngineStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  int ignition_status_;
  int powertrain_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TransmissionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.powertrain.TransmissionStatus) */ {
 public:
  TransmissionStatus();
  virtual ~TransmissionStatus();

  TransmissionStatus(const TransmissionStatus& from);

  inline TransmissionStatus& operator=(const TransmissionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TransmissionStatus(TransmissionStatus&& from) noexcept
    : TransmissionStatus() {
    *this = ::std::move(from);
  }

  inline TransmissionStatus& operator=(TransmissionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TransmissionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransmissionStatus* internal_default_instance() {
    return reinterpret_cast<const TransmissionStatus*>(
               &_TransmissionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TransmissionStatus* other);
  void Swap(TransmissionStatus* other);
  friend void swap(TransmissionStatus& a, TransmissionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TransmissionStatus* New() const final {
    return CreateMaybeMessage<TransmissionStatus>(NULL);
  }

  TransmissionStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TransmissionStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TransmissionStatus& from);
  void MergeFrom(const TransmissionStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransmissionStatus* other);
  protected:
  explicit TransmissionStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TransmissionStatus_GearMode GearMode;
  static const GearMode UNKNOWN_GEAR_MODE =
    TransmissionStatus_GearMode_UNKNOWN_GEAR_MODE;
  static const GearMode DRIVE =
    TransmissionStatus_GearMode_DRIVE;
  static const GearMode MANUAL =
    TransmissionStatus_GearMode_MANUAL;
  static const GearMode REVERSE =
    TransmissionStatus_GearMode_REVERSE;
  static const GearMode PARK =
    TransmissionStatus_GearMode_PARK;
  static const GearMode NEUTRAL =
    TransmissionStatus_GearMode_NEUTRAL;
  static inline bool GearMode_IsValid(int value) {
    return TransmissionStatus_GearMode_IsValid(value);
  }
  static const GearMode GearMode_MIN =
    TransmissionStatus_GearMode_GearMode_MIN;
  static const GearMode GearMode_MAX =
    TransmissionStatus_GearMode_GearMode_MAX;
  static const int GearMode_ARRAYSIZE =
    TransmissionStatus_GearMode_GearMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GearMode_descriptor() {
    return TransmissionStatus_GearMode_descriptor();
  }
  static inline const ::std::string& GearMode_Name(GearMode value) {
    return TransmissionStatus_GearMode_Name(value);
  }
  static inline bool GearMode_Parse(const ::std::string& name,
      GearMode* value) {
    return TransmissionStatus_GearMode_Parse(name, value);
  }

  typedef TransmissionStatus_DriveMode DriveMode;
  static const DriveMode UNKNOWN_DRIVE_MODE =
    TransmissionStatus_DriveMode_UNKNOWN_DRIVE_MODE;
  static const DriveMode ECO =
    TransmissionStatus_DriveMode_ECO;
  static const DriveMode COMFORT =
    TransmissionStatus_DriveMode_COMFORT;
  static const DriveMode SPORT =
    TransmissionStatus_DriveMode_SPORT;
  static const DriveMode SUPER_SPORT =
    TransmissionStatus_DriveMode_SUPER_SPORT;
  static inline bool DriveMode_IsValid(int value) {
    return TransmissionStatus_DriveMode_IsValid(value);
  }
  static const DriveMode DriveMode_MIN =
    TransmissionStatus_DriveMode_DriveMode_MIN;
  static const DriveMode DriveMode_MAX =
    TransmissionStatus_DriveMode_DriveMode_MAX;
  static const int DriveMode_ARRAYSIZE =
    TransmissionStatus_DriveMode_DriveMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DriveMode_descriptor() {
    return TransmissionStatus_DriveMode_descriptor();
  }
  static inline const ::std::string& DriveMode_Name(DriveMode value) {
    return TransmissionStatus_DriveMode_Name(value);
  }
  static inline bool DriveMode_Parse(const ::std::string& name,
      DriveMode* value) {
    return TransmissionStatus_DriveMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Int64Value current_gear = 4;
  bool has_current_gear() const;
  void clear_current_gear();
  static const int kCurrentGearFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_current_gear() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& current_gear() const;
  ::sensoris::protobuf::types::base::Int64Value* release_current_gear();
  ::sensoris::protobuf::types::base::Int64Value* mutable_current_gear();
  void set_allocated_current_gear(::sensoris::protobuf::types::base::Int64Value* current_gear);
  void unsafe_arena_set_allocated_current_gear(
      ::sensoris::protobuf::types::base::Int64Value* current_gear);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_current_gear();

  // .sensoris.protobuf.categories.powertrain.TransmissionStatus.GearMode gear_mode = 2;
  void clear_gear_mode();
  static const int kGearModeFieldNumber = 2;
  ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode gear_mode() const;
  void set_gear_mode(::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode value);

  // .sensoris.protobuf.categories.powertrain.TransmissionStatus.DriveMode drive_mode = 3;
  void clear_drive_mode();
  static const int kDriveModeFieldNumber = 3;
  ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode drive_mode() const;
  void set_drive_mode(::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.powertrain.TransmissionStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Int64Value* current_gear_;
  int gear_mode_;
  int drive_mode_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CruiseControlStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.powertrain.CruiseControlStatus) */ {
 public:
  CruiseControlStatus();
  virtual ~CruiseControlStatus();

  CruiseControlStatus(const CruiseControlStatus& from);

  inline CruiseControlStatus& operator=(const CruiseControlStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CruiseControlStatus(CruiseControlStatus&& from) noexcept
    : CruiseControlStatus() {
    *this = ::std::move(from);
  }

  inline CruiseControlStatus& operator=(CruiseControlStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const CruiseControlStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CruiseControlStatus* internal_default_instance() {
    return reinterpret_cast<const CruiseControlStatus*>(
               &_CruiseControlStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(CruiseControlStatus* other);
  void Swap(CruiseControlStatus* other);
  friend void swap(CruiseControlStatus& a, CruiseControlStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CruiseControlStatus* New() const final {
    return CreateMaybeMessage<CruiseControlStatus>(NULL);
  }

  CruiseControlStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CruiseControlStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CruiseControlStatus& from);
  void MergeFrom(const CruiseControlStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CruiseControlStatus* other);
  protected:
  explicit CruiseControlStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CruiseControlStatus_Type Type;
  static const Type UNKNOWN_TYPE =
    CruiseControlStatus_Type_UNKNOWN_TYPE;
  static const Type SPEED =
    CruiseControlStatus_Type_SPEED;
  static const Type SPEED_AND_DISTANCE =
    CruiseControlStatus_Type_SPEED_AND_DISTANCE;
  static inline bool Type_IsValid(int value) {
    return CruiseControlStatus_Type_IsValid(value);
  }
  static const Type Type_MIN =
    CruiseControlStatus_Type_Type_MIN;
  static const Type Type_MAX =
    CruiseControlStatus_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    CruiseControlStatus_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return CruiseControlStatus_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return CruiseControlStatus_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return CruiseControlStatus_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Int64Value selected_speed = 4 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_selected_speed() const;
  void clear_selected_speed();
  static const int kSelectedSpeedFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_selected_speed() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& selected_speed() const;
  ::sensoris::protobuf::types::base::Int64Value* release_selected_speed();
  ::sensoris::protobuf::types::base::Int64Value* mutable_selected_speed();
  void set_allocated_selected_speed(::sensoris::protobuf::types::base::Int64Value* selected_speed);
  void unsafe_arena_set_allocated_selected_speed(
      ::sensoris::protobuf::types::base::Int64Value* selected_speed);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_selected_speed();

  // .sensoris.protobuf.types.base.Int64Value selected_time_to_lead_vehicle = 5 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_selected_time_to_lead_vehicle() const;
  void clear_selected_time_to_lead_vehicle();
  static const int kSelectedTimeToLeadVehicleFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_selected_time_to_lead_vehicle() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& selected_time_to_lead_vehicle() const;
  ::sensoris::protobuf::types::base::Int64Value* release_selected_time_to_lead_vehicle();
  ::sensoris::protobuf::types::base::Int64Value* mutable_selected_time_to_lead_vehicle();
  void set_allocated_selected_time_to_lead_vehicle(::sensoris::protobuf::types::base::Int64Value* selected_time_to_lead_vehicle);
  void unsafe_arena_set_allocated_selected_time_to_lead_vehicle(
      ::sensoris::protobuf::types::base::Int64Value* selected_time_to_lead_vehicle);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_selected_time_to_lead_vehicle();

  // .sensoris.protobuf.categories.powertrain.CruiseControlStatus.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type type() const;
  void set_type(::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type value);

  // .sensoris.protobuf.types.base.SystemStatus status = 3;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::sensoris::protobuf::types::base::SystemStatus status() const;
  void set_status(::sensoris::protobuf::types::base::SystemStatus value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.powertrain.CruiseControlStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Int64Value* selected_speed_;
  ::sensoris::protobuf::types::base::Int64Value* selected_time_to_lead_vehicle_;
  int type_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PowertrainCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.powertrain.PowertrainCategory) */ {
 public:
  PowertrainCategory();
  virtual ~PowertrainCategory();

  PowertrainCategory(const PowertrainCategory& from);

  inline PowertrainCategory& operator=(const PowertrainCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PowertrainCategory(PowertrainCategory&& from) noexcept
    : PowertrainCategory() {
    *this = ::std::move(from);
  }

  inline PowertrainCategory& operator=(PowertrainCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const PowertrainCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PowertrainCategory* internal_default_instance() {
    return reinterpret_cast<const PowertrainCategory*>(
               &_PowertrainCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(PowertrainCategory* other);
  void Swap(PowertrainCategory* other);
  friend void swap(PowertrainCategory& a, PowertrainCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PowertrainCategory* New() const final {
    return CreateMaybeMessage<PowertrainCategory>(NULL);
  }

  PowertrainCategory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PowertrainCategory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PowertrainCategory& from);
  void MergeFrom(const PowertrainCategory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PowertrainCategory* other);
  protected:
  explicit PowertrainCategory(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.powertrain.EngineStatus engine_status = 2;
  int engine_status_size() const;
  void clear_engine_status();
  static const int kEngineStatusFieldNumber = 2;
  ::sensoris::protobuf::categories::powertrain::EngineStatus* mutable_engine_status(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::EngineStatus >*
      mutable_engine_status();
  const ::sensoris::protobuf::categories::powertrain::EngineStatus& engine_status(int index) const;
  ::sensoris::protobuf::categories::powertrain::EngineStatus* add_engine_status();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::EngineStatus >&
      engine_status() const;

  // repeated .sensoris.protobuf.categories.powertrain.TransmissionStatus transmission_status = 3;
  int transmission_status_size() const;
  void clear_transmission_status();
  static const int kTransmissionStatusFieldNumber = 3;
  ::sensoris::protobuf::categories::powertrain::TransmissionStatus* mutable_transmission_status(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::TransmissionStatus >*
      mutable_transmission_status();
  const ::sensoris::protobuf::categories::powertrain::TransmissionStatus& transmission_status(int index) const;
  ::sensoris::protobuf::categories::powertrain::TransmissionStatus* add_transmission_status();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::TransmissionStatus >&
      transmission_status() const;

  // repeated .sensoris.protobuf.categories.powertrain.CruiseControlStatus cruise_control_status = 4;
  int cruise_control_status_size() const;
  void clear_cruise_control_status();
  static const int kCruiseControlStatusFieldNumber = 4;
  ::sensoris::protobuf::categories::powertrain::CruiseControlStatus* mutable_cruise_control_status(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus >*
      mutable_cruise_control_status();
  const ::sensoris::protobuf::categories::powertrain::CruiseControlStatus& cruise_control_status(int index) const;
  ::sensoris::protobuf::categories::powertrain::CruiseControlStatus* add_cruise_control_status();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus >&
      cruise_control_status() const;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.powertrain.PowertrainCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::EngineStatus > engine_status_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::TransmissionStatus > transmission_status_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus > cruise_control_status_;
  ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EngineStatus

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool EngineStatus::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& EngineStatus::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& EngineStatus::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.EngineStatus.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* EngineStatus::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.EngineStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* EngineStatus::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.EngineStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* EngineStatus::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.EngineStatus.envelope)
  return envelope_;
}
inline void EngineStatus::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.EngineStatus.envelope)
}

// .sensoris.protobuf.categories.powertrain.EngineStatus.IgnitionStatus ignition_status = 2;
inline void EngineStatus::clear_ignition_status() {
  ignition_status_ = 0;
}
inline ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus EngineStatus::ignition_status() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.EngineStatus.ignition_status)
  return static_cast< ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus >(ignition_status_);
}
inline void EngineStatus::set_ignition_status(::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus value) {
  
  ignition_status_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.EngineStatus.ignition_status)
}

// .sensoris.protobuf.categories.powertrain.EngineStatus.PowertrainStatus powertrain_status = 3;
inline void EngineStatus::clear_powertrain_status() {
  powertrain_status_ = 0;
}
inline ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus EngineStatus::powertrain_status() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.EngineStatus.powertrain_status)
  return static_cast< ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus >(powertrain_status_);
}
inline void EngineStatus::set_powertrain_status(::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus value) {
  
  powertrain_status_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.EngineStatus.powertrain_status)
}

// -------------------------------------------------------------------

// TransmissionStatus

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TransmissionStatus::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TransmissionStatus::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TransmissionStatus::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.TransmissionStatus.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TransmissionStatus::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.TransmissionStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TransmissionStatus::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.TransmissionStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TransmissionStatus::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.TransmissionStatus.envelope)
  return envelope_;
}
inline void TransmissionStatus::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.TransmissionStatus.envelope)
}

// .sensoris.protobuf.categories.powertrain.TransmissionStatus.GearMode gear_mode = 2;
inline void TransmissionStatus::clear_gear_mode() {
  gear_mode_ = 0;
}
inline ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode TransmissionStatus::gear_mode() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.TransmissionStatus.gear_mode)
  return static_cast< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode >(gear_mode_);
}
inline void TransmissionStatus::set_gear_mode(::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode value) {
  
  gear_mode_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.TransmissionStatus.gear_mode)
}

// .sensoris.protobuf.categories.powertrain.TransmissionStatus.DriveMode drive_mode = 3;
inline void TransmissionStatus::clear_drive_mode() {
  drive_mode_ = 0;
}
inline ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode TransmissionStatus::drive_mode() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.TransmissionStatus.drive_mode)
  return static_cast< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode >(drive_mode_);
}
inline void TransmissionStatus::set_drive_mode(::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode value) {
  
  drive_mode_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.TransmissionStatus.drive_mode)
}

// .sensoris.protobuf.types.base.Int64Value current_gear = 4;
inline bool TransmissionStatus::has_current_gear() const {
  return this != internal_default_instance() && current_gear_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& TransmissionStatus::_internal_current_gear() const {
  return *current_gear_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& TransmissionStatus::current_gear() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = current_gear_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.TransmissionStatus.current_gear)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* TransmissionStatus::release_current_gear() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.TransmissionStatus.current_gear)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = current_gear_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  current_gear_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* TransmissionStatus::unsafe_arena_release_current_gear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.TransmissionStatus.current_gear)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = current_gear_;
  current_gear_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* TransmissionStatus::mutable_current_gear() {
  
  if (current_gear_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    current_gear_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.TransmissionStatus.current_gear)
  return current_gear_;
}
inline void TransmissionStatus::set_allocated_current_gear(::sensoris::protobuf::types::base::Int64Value* current_gear) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(current_gear_);
  }
  if (current_gear) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(current_gear)->GetArena();
    if (message_arena != submessage_arena) {
      current_gear = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, current_gear, submessage_arena);
    }
    
  } else {
    
  }
  current_gear_ = current_gear;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.TransmissionStatus.current_gear)
}

// -------------------------------------------------------------------

// CruiseControlStatus

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool CruiseControlStatus::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& CruiseControlStatus::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& CruiseControlStatus::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.CruiseControlStatus.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* CruiseControlStatus::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* CruiseControlStatus::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* CruiseControlStatus::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.CruiseControlStatus.envelope)
  return envelope_;
}
inline void CruiseControlStatus::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.CruiseControlStatus.envelope)
}

// .sensoris.protobuf.categories.powertrain.CruiseControlStatus.Type type = 2;
inline void CruiseControlStatus::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type CruiseControlStatus::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.CruiseControlStatus.type)
  return static_cast< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type >(type_);
}
inline void CruiseControlStatus::set_type(::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.CruiseControlStatus.type)
}

// .sensoris.protobuf.types.base.SystemStatus status = 3;
inline void CruiseControlStatus::clear_status() {
  status_ = 0;
}
inline ::sensoris::protobuf::types::base::SystemStatus CruiseControlStatus::status() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.CruiseControlStatus.status)
  return static_cast< ::sensoris::protobuf::types::base::SystemStatus >(status_);
}
inline void CruiseControlStatus::set_status(::sensoris::protobuf::types::base::SystemStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.powertrain.CruiseControlStatus.status)
}

// .sensoris.protobuf.types.base.Int64Value selected_speed = 4 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool CruiseControlStatus::has_selected_speed() const {
  return this != internal_default_instance() && selected_speed_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& CruiseControlStatus::_internal_selected_speed() const {
  return *selected_speed_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& CruiseControlStatus::selected_speed() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = selected_speed_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_speed)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::release_selected_speed() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_speed)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = selected_speed_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  selected_speed_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::unsafe_arena_release_selected_speed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_speed)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = selected_speed_;
  selected_speed_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::mutable_selected_speed() {
  
  if (selected_speed_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    selected_speed_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_speed)
  return selected_speed_;
}
inline void CruiseControlStatus::set_allocated_selected_speed(::sensoris::protobuf::types::base::Int64Value* selected_speed) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(selected_speed_);
  }
  if (selected_speed) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(selected_speed)->GetArena();
    if (message_arena != submessage_arena) {
      selected_speed = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selected_speed, submessage_arena);
    }
    
  } else {
    
  }
  selected_speed_ = selected_speed;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_speed)
}

// .sensoris.protobuf.types.base.Int64Value selected_time_to_lead_vehicle = 5 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool CruiseControlStatus::has_selected_time_to_lead_vehicle() const {
  return this != internal_default_instance() && selected_time_to_lead_vehicle_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& CruiseControlStatus::_internal_selected_time_to_lead_vehicle() const {
  return *selected_time_to_lead_vehicle_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& CruiseControlStatus::selected_time_to_lead_vehicle() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = selected_time_to_lead_vehicle_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_time_to_lead_vehicle)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::release_selected_time_to_lead_vehicle() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_time_to_lead_vehicle)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = selected_time_to_lead_vehicle_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  selected_time_to_lead_vehicle_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::unsafe_arena_release_selected_time_to_lead_vehicle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_time_to_lead_vehicle)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = selected_time_to_lead_vehicle_;
  selected_time_to_lead_vehicle_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* CruiseControlStatus::mutable_selected_time_to_lead_vehicle() {
  
  if (selected_time_to_lead_vehicle_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    selected_time_to_lead_vehicle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_time_to_lead_vehicle)
  return selected_time_to_lead_vehicle_;
}
inline void CruiseControlStatus::set_allocated_selected_time_to_lead_vehicle(::sensoris::protobuf::types::base::Int64Value* selected_time_to_lead_vehicle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(selected_time_to_lead_vehicle_);
  }
  if (selected_time_to_lead_vehicle) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(selected_time_to_lead_vehicle)->GetArena();
    if (message_arena != submessage_arena) {
      selected_time_to_lead_vehicle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selected_time_to_lead_vehicle, submessage_arena);
    }
    
  } else {
    
  }
  selected_time_to_lead_vehicle_ = selected_time_to_lead_vehicle;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.CruiseControlStatus.selected_time_to_lead_vehicle)
}

// -------------------------------------------------------------------

// PowertrainCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool PowertrainCategory::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& PowertrainCategory::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& PowertrainCategory::envelope() const {
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.PowertrainCategory.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      &::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PowertrainCategory::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.powertrain.PowertrainCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PowertrainCategory::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.powertrain.PowertrainCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* PowertrainCategory::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.PowertrainCategory.envelope)
  return envelope_;
}
inline void PowertrainCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.powertrain.PowertrainCategory.envelope)
}

// repeated .sensoris.protobuf.categories.powertrain.EngineStatus engine_status = 2;
inline int PowertrainCategory::engine_status_size() const {
  return engine_status_.size();
}
inline void PowertrainCategory::clear_engine_status() {
  engine_status_.Clear();
}
inline ::sensoris::protobuf::categories::powertrain::EngineStatus* PowertrainCategory::mutable_engine_status(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.PowertrainCategory.engine_status)
  return engine_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::EngineStatus >*
PowertrainCategory::mutable_engine_status() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.engine_status)
  return &engine_status_;
}
inline const ::sensoris::protobuf::categories::powertrain::EngineStatus& PowertrainCategory::engine_status(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.PowertrainCategory.engine_status)
  return engine_status_.Get(index);
}
inline ::sensoris::protobuf::categories::powertrain::EngineStatus* PowertrainCategory::add_engine_status() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.powertrain.PowertrainCategory.engine_status)
  return engine_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::EngineStatus >&
PowertrainCategory::engine_status() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.engine_status)
  return engine_status_;
}

// repeated .sensoris.protobuf.categories.powertrain.TransmissionStatus transmission_status = 3;
inline int PowertrainCategory::transmission_status_size() const {
  return transmission_status_.size();
}
inline void PowertrainCategory::clear_transmission_status() {
  transmission_status_.Clear();
}
inline ::sensoris::protobuf::categories::powertrain::TransmissionStatus* PowertrainCategory::mutable_transmission_status(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.PowertrainCategory.transmission_status)
  return transmission_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::TransmissionStatus >*
PowertrainCategory::mutable_transmission_status() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.transmission_status)
  return &transmission_status_;
}
inline const ::sensoris::protobuf::categories::powertrain::TransmissionStatus& PowertrainCategory::transmission_status(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.PowertrainCategory.transmission_status)
  return transmission_status_.Get(index);
}
inline ::sensoris::protobuf::categories::powertrain::TransmissionStatus* PowertrainCategory::add_transmission_status() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.powertrain.PowertrainCategory.transmission_status)
  return transmission_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::TransmissionStatus >&
PowertrainCategory::transmission_status() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.transmission_status)
  return transmission_status_;
}

// repeated .sensoris.protobuf.categories.powertrain.CruiseControlStatus cruise_control_status = 4;
inline int PowertrainCategory::cruise_control_status_size() const {
  return cruise_control_status_.size();
}
inline void PowertrainCategory::clear_cruise_control_status() {
  cruise_control_status_.Clear();
}
inline ::sensoris::protobuf::categories::powertrain::CruiseControlStatus* PowertrainCategory::mutable_cruise_control_status(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.powertrain.PowertrainCategory.cruise_control_status)
  return cruise_control_status_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus >*
PowertrainCategory::mutable_cruise_control_status() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.cruise_control_status)
  return &cruise_control_status_;
}
inline const ::sensoris::protobuf::categories::powertrain::CruiseControlStatus& PowertrainCategory::cruise_control_status(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.powertrain.PowertrainCategory.cruise_control_status)
  return cruise_control_status_.Get(index);
}
inline ::sensoris::protobuf::categories::powertrain::CruiseControlStatus* PowertrainCategory::add_cruise_control_status() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.powertrain.PowertrainCategory.cruise_control_status)
  return cruise_control_status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus >&
PowertrainCategory::cruise_control_status() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.powertrain.PowertrainCategory.cruise_control_status)
  return cruise_control_status_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace powertrain
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus>() {
  return ::sensoris::protobuf::categories::powertrain::EngineStatus_IgnitionStatus_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus>() {
  return ::sensoris::protobuf::categories::powertrain::EngineStatus_PowertrainStatus_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode>() {
  return ::sensoris::protobuf::categories::powertrain::TransmissionStatus_GearMode_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode>() {
  return ::sensoris::protobuf::categories::powertrain::TransmissionStatus_DriveMode_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type>() {
  return ::sensoris::protobuf::categories::powertrain::CruiseControlStatus_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2fpowertrain_2eproto

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/intersection_attribution.proto

#include "sensoris/protobuf/categories/intersection_attribution.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_ColorAndConfidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_ShapeAndConfidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_StatusAndConfidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignal_OrientationAndConfidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<6> scc_info_TrafficSignal;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto ::google::protobuf::internal::SCCInfo<6> scc_info_TrafficSignalBulb;
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto
namespace protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Confidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_CategoryEnvelope;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto ::google::protobuf::internal::SCCInfo<1> scc_info_EventDetectionStatus;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_CountAndConfidence;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_EventEnvelope;
}  // namespace protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto
namespace protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto ::google::protobuf::internal::SCCInfo<3> scc_info_RectangularBoxAndAccuracy;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto ::google::protobuf::internal::SCCInfo<7> scc_info_PositionAndAccuracy;
}  // namespace protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace intersectionattribution {
class TrafficSignalBulb_StatusAndConfidenceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignalBulb_StatusAndConfidence>
      _instance;
} _TrafficSignalBulb_StatusAndConfidence_default_instance_;
class TrafficSignalBulb_ColorAndConfidenceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignalBulb_ColorAndConfidence>
      _instance;
} _TrafficSignalBulb_ColorAndConfidence_default_instance_;
class TrafficSignalBulb_ShapeAndConfidenceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignalBulb_ShapeAndConfidence>
      _instance;
} _TrafficSignalBulb_ShapeAndConfidence_default_instance_;
class TrafficSignalBulbDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignalBulb>
      _instance;
} _TrafficSignalBulb_default_instance_;
class TrafficSignal_OrientationAndConfidenceDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignal_OrientationAndConfidence>
      _instance;
} _TrafficSignal_OrientationAndConfidence_default_instance_;
class TrafficSignalDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<TrafficSignal>
      _instance;
} _TrafficSignal_default_instance_;
class IntersectionAttributionCategoryDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IntersectionAttributionCategory>
      _instance;
} _IntersectionAttributionCategory_default_instance_;
}  // namespace intersectionattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto {
static void InitDefaultsTrafficSignalBulb_StatusAndConfidence() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_StatusAndConfidence_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_StatusAndConfidence =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTrafficSignalBulb_StatusAndConfidence}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,}};

static void InitDefaultsTrafficSignalBulb_ColorAndConfidence() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ColorAndConfidence_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_ColorAndConfidence =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTrafficSignalBulb_ColorAndConfidence}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,}};

static void InitDefaultsTrafficSignalBulb_ShapeAndConfidence() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ShapeAndConfidence_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignalBulb_ShapeAndConfidence =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTrafficSignalBulb_ShapeAndConfidence}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,}};

static void InitDefaultsTrafficSignalBulb() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<6> scc_info_TrafficSignalBulb =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsTrafficSignalBulb}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_EventEnvelope.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::scc_info_PositionAndAccuracy.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_StatusAndConfidence.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ColorAndConfidence.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ShapeAndConfidence.base,}};

static void InitDefaultsTrafficSignal_OrientationAndConfidence() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_OrientationAndConfidence_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_TrafficSignal_OrientationAndConfidence =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsTrafficSignal_OrientationAndConfidence}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,}};

static void InitDefaultsTrafficSignal() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<6> scc_info_TrafficSignal =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsTrafficSignal}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_EventEnvelope.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_Confidence.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_EventDetectionStatus.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::scc_info_RectangularBoxAndAccuracy.base,
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_CountAndConfidence.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal_OrientationAndConfidence.base,}};

static void InitDefaultsIntersectionAttributionCategory() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::sensoris::protobuf::categories::intersectionattribution::_IntersectionAttributionCategory_default_instance_;
    new (ptr) ::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_IntersectionAttributionCategory =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsIntersectionAttributionCategory}, {
      &protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::scc_info_CategoryEnvelope.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb.base,
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignalBulb_StatusAndConfidence.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignalBulb_ColorAndConfidence.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignalBulb_ShapeAndConfidence.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignalBulb.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignal_OrientationAndConfidence.base);
  ::google::protobuf::internal::InitSCC(&scc_info_TrafficSignal.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IntersectionAttributionCategory.base);
}

::google::protobuf::Metadata file_level_metadata[7];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[4];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence, confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence, confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence, confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, envelope_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, existence_confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, position_and_accuracy_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, status_and_confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, color_and_confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb, shape_and_confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence, type_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence, confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, envelope_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, existence_confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, detection_status_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, rectangular_box_and_accuracy_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, bulb_count_and_confidence_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal, orientation_and_confidence_),
  ~0u,  // no _has_bits_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory, envelope_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory, traffic_signal_bulb_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory, traffic_signal_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence)},
  { 7, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence)},
  { 14, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence)},
  { 21, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb)},
  { 32, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence)},
  { 39, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::TrafficSignal)},
  { 50, -1, sizeof(::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_StatusAndConfidence_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ColorAndConfidence_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ShapeAndConfidence_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_OrientationAndConfidence_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::sensoris::protobuf::categories::intersectionattribution::_IntersectionAttributionCategory_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  AssignDescriptors(
      "sensoris/protobuf/categories/intersection_attribution.proto", schemas, file_default_instances, TableStruct::offsets,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 7);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n;sensoris/protobuf/categories/intersect"
      "ion_attribution.proto\0224sensoris.protobuf"
      ".categories.intersectionattribution\032\"sen"
      "soris/protobuf/types/base.proto\032%sensori"
      "s/protobuf/types/spatial.proto\"\267\013\n\021Traff"
      "icSignalBulb\022=\n\010envelope\030\001 \001(\0132+.sensori"
      "s.protobuf.types.base.EventEnvelope\022F\n\024e"
      "xistence_confidence\030\002 \001(\0132(.sensoris.pro"
      "tobuf.types.base.Confidence\022S\n\025position_"
      "and_accuracy\030\003 \001(\01324.sensoris.protobuf.t"
      "ypes.spatial.PositionAndAccuracy\022z\n\025stat"
      "us_and_confidence\030\004 \001(\0132[.sensoris.proto"
      "buf.categories.intersectionattribution.T"
      "rafficSignalBulb.StatusAndConfidence\022x\n\024"
      "color_and_confidence\030\005 \001(\0132Z.sensoris.pr"
      "otobuf.categories.intersectionattributio"
      "n.TrafficSignalBulb.ColorAndConfidence\022x"
      "\n\024shape_and_confidence\030\006 \001(\0132Z.sensoris."
      "protobuf.categories.intersectionattribut"
      "ion.TrafficSignalBulb.ShapeAndConfidence"
      "\032\374\001\n\023StatusAndConfidence\022n\n\004type\030\001 \001(\0162`"
      ".sensoris.protobuf.categories.intersecti"
      "onattribution.TrafficSignalBulb.StatusAn"
      "dConfidence.Type\022<\n\nconfidence\030\002 \001(\0132(.s"
      "ensoris.protobuf.types.base.Confidence\"7"
      "\n\004Type\022\020\n\014UNKNOWN_TYPE\020\000\022\007\n\003OFF\020\001\022\006\n\002ON\020"
      "\002\022\014\n\010BLINKING\020\003\032\373\001\n\022ColorAndConfidence\022m"
      "\n\004type\030\001 \001(\0162_.sensoris.protobuf.categor"
      "ies.intersectionattribution.TrafficSigna"
      "lBulb.ColorAndConfidence.Type\022<\n\nconfide"
      "nce\030\002 \001(\0132(.sensoris.protobuf.types.base"
      ".Confidence\"8\n\004Type\022\020\n\014UNKNOWN_TYPE\020\000\022\t\n"
      "\005GREEN\020\001\022\n\n\006YELLOW\020\002\022\007\n\003RED\020\003\032\330\002\n\022ShapeA"
      "ndConfidence\022m\n\004type\030\001 \001(\0162_.sensoris.pr"
      "otobuf.categories.intersectionattributio"
      "n.TrafficSignalBulb.ShapeAndConfidence.T"
      "ype\022<\n\nconfidence\030\002 \001(\0132(.sensoris.proto"
      "buf.types.base.Confidence\"\224\001\n\004Type\022\020\n\014UN"
      "KNOWN_TYPE\020\000\022\n\n\006CIRCLE\020\001\022\022\n\016ARROW_STRAIG"
      "HT\020\002\022\016\n\nARROW_LEFT\020\003\022\017\n\013ARROW_RIGHT\020\004\022\033\n"
      "\027ARROW_STRAIGHT_AND_LEFT\020\005\022\034\n\030ARROW_STRA"
      "IGHT_AND_RIGHT\020\006\"\270\006\n\rTrafficSignal\022=\n\010en"
      "velope\030\001 \001(\0132+.sensoris.protobuf.types.b"
      "ase.EventEnvelope\022F\n\024existence_confidenc"
      "e\030\002 \001(\0132(.sensoris.protobuf.types.base.C"
      "onfidence\022L\n\020detection_status\030\003 \001(\01322.se"
      "nsoris.protobuf.types.base.EventDetectio"
      "nStatus\022`\n\034rectangular_box_and_accuracy\030"
      "\004 \001(\0132:.sensoris.protobuf.types.spatial."
      "RectangularBoxAndAccuracy\022S\n\031bulb_count_"
      "and_confidence\030\005 \001(\01320.sensoris.protobuf"
      ".types.base.CountAndConfidence\022\200\001\n\032orien"
      "tation_and_confidence\030\006 \001(\0132\\.sensoris.p"
      "rotobuf.categories.intersectionattributi"
      "on.TrafficSignal.OrientationAndConfidenc"
      "e\032\227\002\n\030OrientationAndConfidence\022o\n\004type\030\001"
      " \001(\0162a.sensoris.protobuf.categories.inte"
      "rsectionattribution.TrafficSignal.Orient"
      "ationAndConfidence.Type\022<\n\nconfidence\030\002 "
      "\001(\0132(.sensoris.protobuf.types.base.Confi"
      "dence\"L\n\004Type\022\020\n\014UNKNOWN_TYPE\020\000\022\t\n\005OTHER"
      "\020\001\022\016\n\nHORIZONTAL\020\002\022\014\n\010VERTICAL\020\003\022\t\n\005MIXE"
      "D\020\004\"\246\002\n\037IntersectionAttributionCategory\022"
      "@\n\010envelope\030\001 \001(\0132..sensoris.protobuf.ty"
      "pes.base.CategoryEnvelope\022d\n\023traffic_sig"
      "nal_bulb\030\002 \003(\0132G.sensoris.protobuf.categ"
      "ories.intersectionattribution.TrafficSig"
      "nalBulb\022[\n\016traffic_signal\030\003 \003(\0132C.sensor"
      "is.protobuf.categories.intersectionattri"
      "bution.TrafficSignalB_\n/org.sensoris.cat"
      "egories.intersectionattributionB\'Sensori"
      "sIntersectionAttributionCategoryP\001\370\001\001b\006p"
      "roto3"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 2885);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "sensoris/protobuf/categories/intersection_attribution.proto", &protobuf_RegisterTypes);
  ::protobuf_sensoris_2fprotobuf_2ftypes_2fbase_2eproto::AddDescriptors();
  ::protobuf_sensoris_2fprotobuf_2ftypes_2fspatial_2eproto::AddDescriptors();
}

void AddDescriptors() {
  static ::google::protobuf::internal::once_flag once;
  ::google::protobuf::internal::call_once(once, AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace intersectionattribution {
const ::google::protobuf::EnumDescriptor* TrafficSignalBulb_StatusAndConfidence_Type_descriptor() {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_enum_descriptors[0];
}
bool TrafficSignalBulb_StatusAndConfidence_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::UNKNOWN_TYPE;
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::OFF;
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::ON;
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::BLINKING;
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::Type_MIN;
const TrafficSignalBulb_StatusAndConfidence_Type TrafficSignalBulb_StatusAndConfidence::Type_MAX;
const int TrafficSignalBulb_StatusAndConfidence::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TrafficSignalBulb_ColorAndConfidence_Type_descriptor() {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_enum_descriptors[1];
}
bool TrafficSignalBulb_ColorAndConfidence_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::UNKNOWN_TYPE;
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::GREEN;
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::YELLOW;
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::RED;
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::Type_MIN;
const TrafficSignalBulb_ColorAndConfidence_Type TrafficSignalBulb_ColorAndConfidence::Type_MAX;
const int TrafficSignalBulb_ColorAndConfidence::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TrafficSignalBulb_ShapeAndConfidence_Type_descriptor() {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_enum_descriptors[2];
}
bool TrafficSignalBulb_ShapeAndConfidence_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::UNKNOWN_TYPE;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::CIRCLE;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::ARROW_STRAIGHT;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::ARROW_LEFT;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::ARROW_RIGHT;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::ARROW_STRAIGHT_AND_LEFT;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::ARROW_STRAIGHT_AND_RIGHT;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::Type_MIN;
const TrafficSignalBulb_ShapeAndConfidence_Type TrafficSignalBulb_ShapeAndConfidence::Type_MAX;
const int TrafficSignalBulb_ShapeAndConfidence::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TrafficSignal_OrientationAndConfidence_Type_descriptor() {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_enum_descriptors[3];
}
bool TrafficSignal_OrientationAndConfidence_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::UNKNOWN_TYPE;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::OTHER;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::HORIZONTAL;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::VERTICAL;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::MIXED;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::Type_MIN;
const TrafficSignal_OrientationAndConfidence_Type TrafficSignal_OrientationAndConfidence::Type_MAX;
const int TrafficSignal_OrientationAndConfidence::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

// ===================================================================

void TrafficSignalBulb_StatusAndConfidence::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_StatusAndConfidence_default_instance_._instance.get_mutable()->confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
}
void TrafficSignalBulb_StatusAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete confidence_;
  }
  confidence_ = confidence;
  if (confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence.confidence)
}
void TrafficSignalBulb_StatusAndConfidence::clear_confidence() {
  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignalBulb_StatusAndConfidence::kTypeFieldNumber;
const int TrafficSignalBulb_StatusAndConfidence::kConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignalBulb_StatusAndConfidence::TrafficSignalBulb_StatusAndConfidence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_StatusAndConfidence.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
}
TrafficSignalBulb_StatusAndConfidence::TrafficSignalBulb_StatusAndConfidence(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_StatusAndConfidence.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
}
TrafficSignalBulb_StatusAndConfidence::TrafficSignalBulb_StatusAndConfidence(const TrafficSignalBulb_StatusAndConfidence& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_confidence()) {
    confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.confidence_);
  } else {
    confidence_ = NULL;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
}

void TrafficSignalBulb_StatusAndConfidence::SharedCtor() {
  ::memset(&confidence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&confidence_)) + sizeof(type_));
}

TrafficSignalBulb_StatusAndConfidence::~TrafficSignalBulb_StatusAndConfidence() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  SharedDtor();
}

void TrafficSignalBulb_StatusAndConfidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete confidence_;
}

void TrafficSignalBulb_StatusAndConfidence::ArenaDtor(void* object) {
  TrafficSignalBulb_StatusAndConfidence* _this = reinterpret_cast< TrafficSignalBulb_StatusAndConfidence* >(object);
  (void)_this;
}
void TrafficSignalBulb_StatusAndConfidence::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignalBulb_StatusAndConfidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignalBulb_StatusAndConfidence::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignalBulb_StatusAndConfidence& TrafficSignalBulb_StatusAndConfidence::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_StatusAndConfidence.base);
  return *internal_default_instance();
}


void TrafficSignalBulb_StatusAndConfidence::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
  type_ = 0;
  _internal_metadata_.Clear();
}

bool TrafficSignalBulb_StatusAndConfidence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  return false;
#undef DO_
}

void TrafficSignalBulb_StatusAndConfidence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
}

::google::protobuf::uint8* TrafficSignalBulb_StatusAndConfidence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  return target;
}

size_t TrafficSignalBulb_StatusAndConfidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignalBulb_StatusAndConfidence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignalBulb_StatusAndConfidence* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignalBulb_StatusAndConfidence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
    MergeFrom(*source);
  }
}

void TrafficSignalBulb_StatusAndConfidence::MergeFrom(const TrafficSignalBulb_StatusAndConfidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_confidence()) {
    mutable_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.confidence());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void TrafficSignalBulb_StatusAndConfidence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignalBulb_StatusAndConfidence::CopyFrom(const TrafficSignalBulb_StatusAndConfidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignalBulb_StatusAndConfidence::IsInitialized() const {
  return true;
}

void TrafficSignalBulb_StatusAndConfidence::Swap(TrafficSignalBulb_StatusAndConfidence* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignalBulb_StatusAndConfidence* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignalBulb_StatusAndConfidence::UnsafeArenaSwap(TrafficSignalBulb_StatusAndConfidence* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignalBulb_StatusAndConfidence::InternalSwap(TrafficSignalBulb_StatusAndConfidence* other) {
  using std::swap;
  swap(confidence_, other->confidence_);
  swap(type_, other->type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignalBulb_StatusAndConfidence::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TrafficSignalBulb_ColorAndConfidence::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ColorAndConfidence_default_instance_._instance.get_mutable()->confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
}
void TrafficSignalBulb_ColorAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete confidence_;
  }
  confidence_ = confidence;
  if (confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence.confidence)
}
void TrafficSignalBulb_ColorAndConfidence::clear_confidence() {
  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignalBulb_ColorAndConfidence::kTypeFieldNumber;
const int TrafficSignalBulb_ColorAndConfidence::kConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignalBulb_ColorAndConfidence::TrafficSignalBulb_ColorAndConfidence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ColorAndConfidence.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
}
TrafficSignalBulb_ColorAndConfidence::TrafficSignalBulb_ColorAndConfidence(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ColorAndConfidence.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
}
TrafficSignalBulb_ColorAndConfidence::TrafficSignalBulb_ColorAndConfidence(const TrafficSignalBulb_ColorAndConfidence& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_confidence()) {
    confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.confidence_);
  } else {
    confidence_ = NULL;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
}

void TrafficSignalBulb_ColorAndConfidence::SharedCtor() {
  ::memset(&confidence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&confidence_)) + sizeof(type_));
}

TrafficSignalBulb_ColorAndConfidence::~TrafficSignalBulb_ColorAndConfidence() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  SharedDtor();
}

void TrafficSignalBulb_ColorAndConfidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete confidence_;
}

void TrafficSignalBulb_ColorAndConfidence::ArenaDtor(void* object) {
  TrafficSignalBulb_ColorAndConfidence* _this = reinterpret_cast< TrafficSignalBulb_ColorAndConfidence* >(object);
  (void)_this;
}
void TrafficSignalBulb_ColorAndConfidence::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignalBulb_ColorAndConfidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignalBulb_ColorAndConfidence::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignalBulb_ColorAndConfidence& TrafficSignalBulb_ColorAndConfidence::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ColorAndConfidence.base);
  return *internal_default_instance();
}


void TrafficSignalBulb_ColorAndConfidence::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
  type_ = 0;
  _internal_metadata_.Clear();
}

bool TrafficSignalBulb_ColorAndConfidence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  return false;
#undef DO_
}

void TrafficSignalBulb_ColorAndConfidence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
}

::google::protobuf::uint8* TrafficSignalBulb_ColorAndConfidence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  return target;
}

size_t TrafficSignalBulb_ColorAndConfidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignalBulb_ColorAndConfidence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignalBulb_ColorAndConfidence* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignalBulb_ColorAndConfidence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
    MergeFrom(*source);
  }
}

void TrafficSignalBulb_ColorAndConfidence::MergeFrom(const TrafficSignalBulb_ColorAndConfidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_confidence()) {
    mutable_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.confidence());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void TrafficSignalBulb_ColorAndConfidence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignalBulb_ColorAndConfidence::CopyFrom(const TrafficSignalBulb_ColorAndConfidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignalBulb_ColorAndConfidence::IsInitialized() const {
  return true;
}

void TrafficSignalBulb_ColorAndConfidence::Swap(TrafficSignalBulb_ColorAndConfidence* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignalBulb_ColorAndConfidence* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignalBulb_ColorAndConfidence::UnsafeArenaSwap(TrafficSignalBulb_ColorAndConfidence* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignalBulb_ColorAndConfidence::InternalSwap(TrafficSignalBulb_ColorAndConfidence* other) {
  using std::swap;
  swap(confidence_, other->confidence_);
  swap(type_, other->type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignalBulb_ColorAndConfidence::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TrafficSignalBulb_ShapeAndConfidence::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_ShapeAndConfidence_default_instance_._instance.get_mutable()->confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
}
void TrafficSignalBulb_ShapeAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete confidence_;
  }
  confidence_ = confidence;
  if (confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence.confidence)
}
void TrafficSignalBulb_ShapeAndConfidence::clear_confidence() {
  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignalBulb_ShapeAndConfidence::kTypeFieldNumber;
const int TrafficSignalBulb_ShapeAndConfidence::kConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignalBulb_ShapeAndConfidence::TrafficSignalBulb_ShapeAndConfidence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ShapeAndConfidence.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
}
TrafficSignalBulb_ShapeAndConfidence::TrafficSignalBulb_ShapeAndConfidence(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ShapeAndConfidence.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
}
TrafficSignalBulb_ShapeAndConfidence::TrafficSignalBulb_ShapeAndConfidence(const TrafficSignalBulb_ShapeAndConfidence& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_confidence()) {
    confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.confidence_);
  } else {
    confidence_ = NULL;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
}

void TrafficSignalBulb_ShapeAndConfidence::SharedCtor() {
  ::memset(&confidence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&confidence_)) + sizeof(type_));
}

TrafficSignalBulb_ShapeAndConfidence::~TrafficSignalBulb_ShapeAndConfidence() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  SharedDtor();
}

void TrafficSignalBulb_ShapeAndConfidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete confidence_;
}

void TrafficSignalBulb_ShapeAndConfidence::ArenaDtor(void* object) {
  TrafficSignalBulb_ShapeAndConfidence* _this = reinterpret_cast< TrafficSignalBulb_ShapeAndConfidence* >(object);
  (void)_this;
}
void TrafficSignalBulb_ShapeAndConfidence::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignalBulb_ShapeAndConfidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignalBulb_ShapeAndConfidence::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignalBulb_ShapeAndConfidence& TrafficSignalBulb_ShapeAndConfidence::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb_ShapeAndConfidence.base);
  return *internal_default_instance();
}


void TrafficSignalBulb_ShapeAndConfidence::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
  type_ = 0;
  _internal_metadata_.Clear();
}

bool TrafficSignalBulb_ShapeAndConfidence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  return false;
#undef DO_
}

void TrafficSignalBulb_ShapeAndConfidence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
}

::google::protobuf::uint8* TrafficSignalBulb_ShapeAndConfidence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  return target;
}

size_t TrafficSignalBulb_ShapeAndConfidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignalBulb_ShapeAndConfidence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignalBulb_ShapeAndConfidence* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignalBulb_ShapeAndConfidence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
    MergeFrom(*source);
  }
}

void TrafficSignalBulb_ShapeAndConfidence::MergeFrom(const TrafficSignalBulb_ShapeAndConfidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_confidence()) {
    mutable_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.confidence());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void TrafficSignalBulb_ShapeAndConfidence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignalBulb_ShapeAndConfidence::CopyFrom(const TrafficSignalBulb_ShapeAndConfidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignalBulb_ShapeAndConfidence::IsInitialized() const {
  return true;
}

void TrafficSignalBulb_ShapeAndConfidence::Swap(TrafficSignalBulb_ShapeAndConfidence* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignalBulb_ShapeAndConfidence* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignalBulb_ShapeAndConfidence::UnsafeArenaSwap(TrafficSignalBulb_ShapeAndConfidence* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignalBulb_ShapeAndConfidence::InternalSwap(TrafficSignalBulb_ShapeAndConfidence* other) {
  using std::swap;
  swap(confidence_, other->confidence_);
  swap(type_, other->type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignalBulb_ShapeAndConfidence::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TrafficSignalBulb::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->envelope_ = const_cast< ::sensoris::protobuf::types::base::EventEnvelope*>(
      ::sensoris::protobuf::types::base::EventEnvelope::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->existence_confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->position_and_accuracy_ = const_cast< ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->status_and_confidence_ = const_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence*>(
      ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->color_and_confidence_ = const_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence*>(
      ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignalBulb_default_instance_._instance.get_mutable()->shape_and_confidence_ = const_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence*>(
      ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence::internal_default_instance());
}
void TrafficSignalBulb::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  if (GetArenaNoVirtual() == NULL) {
    delete envelope_;
  }
  envelope_ = envelope;
  if (envelope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.envelope)
}
void TrafficSignalBulb::clear_envelope() {
  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
}
void TrafficSignalBulb::unsafe_arena_set_allocated_existence_confidence(
    ::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = existence_confidence;
  if (existence_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.existence_confidence)
}
void TrafficSignalBulb::clear_existence_confidence() {
  if (GetArenaNoVirtual() == NULL && existence_confidence_ != NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = NULL;
}
void TrafficSignalBulb::unsafe_arena_set_allocated_position_and_accuracy(
    ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  if (GetArenaNoVirtual() == NULL) {
    delete position_and_accuracy_;
  }
  position_and_accuracy_ = position_and_accuracy;
  if (position_and_accuracy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.position_and_accuracy)
}
void TrafficSignalBulb::clear_position_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && position_and_accuracy_ != NULL) {
    delete position_and_accuracy_;
  }
  position_and_accuracy_ = NULL;
}
void TrafficSignalBulb::unsafe_arena_set_allocated_status_and_confidence(
    ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence* status_and_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete status_and_confidence_;
  }
  status_and_confidence_ = status_and_confidence;
  if (status_and_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.status_and_confidence)
}
void TrafficSignalBulb::unsafe_arena_set_allocated_color_and_confidence(
    ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence* color_and_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete color_and_confidence_;
  }
  color_and_confidence_ = color_and_confidence;
  if (color_and_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.color_and_confidence)
}
void TrafficSignalBulb::unsafe_arena_set_allocated_shape_and_confidence(
    ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence* shape_and_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete shape_and_confidence_;
  }
  shape_and_confidence_ = shape_and_confidence;
  if (shape_and_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.shape_and_confidence)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignalBulb::kEnvelopeFieldNumber;
const int TrafficSignalBulb::kExistenceConfidenceFieldNumber;
const int TrafficSignalBulb::kPositionAndAccuracyFieldNumber;
const int TrafficSignalBulb::kStatusAndConfidenceFieldNumber;
const int TrafficSignalBulb::kColorAndConfidenceFieldNumber;
const int TrafficSignalBulb::kShapeAndConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignalBulb::TrafficSignalBulb()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
}
TrafficSignalBulb::TrafficSignalBulb(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
}
TrafficSignalBulb::TrafficSignalBulb(const TrafficSignalBulb& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_envelope()) {
    envelope_ = new ::sensoris::protobuf::types::base::EventEnvelope(*from.envelope_);
  } else {
    envelope_ = NULL;
  }
  if (from.has_existence_confidence()) {
    existence_confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.existence_confidence_);
  } else {
    existence_confidence_ = NULL;
  }
  if (from.has_position_and_accuracy()) {
    position_and_accuracy_ = new ::sensoris::protobuf::types::spatial::PositionAndAccuracy(*from.position_and_accuracy_);
  } else {
    position_and_accuracy_ = NULL;
  }
  if (from.has_status_and_confidence()) {
    status_and_confidence_ = new ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence(*from.status_and_confidence_);
  } else {
    status_and_confidence_ = NULL;
  }
  if (from.has_color_and_confidence()) {
    color_and_confidence_ = new ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence(*from.color_and_confidence_);
  } else {
    color_and_confidence_ = NULL;
  }
  if (from.has_shape_and_confidence()) {
    shape_and_confidence_ = new ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence(*from.shape_and_confidence_);
  } else {
    shape_and_confidence_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
}

void TrafficSignalBulb::SharedCtor() {
  ::memset(&envelope_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&shape_and_confidence_) -
      reinterpret_cast<char*>(&envelope_)) + sizeof(shape_and_confidence_));
}

TrafficSignalBulb::~TrafficSignalBulb() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  SharedDtor();
}

void TrafficSignalBulb::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete envelope_;
  if (this != internal_default_instance()) delete existence_confidence_;
  if (this != internal_default_instance()) delete position_and_accuracy_;
  if (this != internal_default_instance()) delete status_and_confidence_;
  if (this != internal_default_instance()) delete color_and_confidence_;
  if (this != internal_default_instance()) delete shape_and_confidence_;
}

void TrafficSignalBulb::ArenaDtor(void* object) {
  TrafficSignalBulb* _this = reinterpret_cast< TrafficSignalBulb* >(object);
  (void)_this;
}
void TrafficSignalBulb::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignalBulb::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignalBulb::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignalBulb& TrafficSignalBulb::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignalBulb.base);
  return *internal_default_instance();
}


void TrafficSignalBulb::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
  if (GetArenaNoVirtual() == NULL && existence_confidence_ != NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = NULL;
  if (GetArenaNoVirtual() == NULL && position_and_accuracy_ != NULL) {
    delete position_and_accuracy_;
  }
  position_and_accuracy_ = NULL;
  if (GetArenaNoVirtual() == NULL && status_and_confidence_ != NULL) {
    delete status_and_confidence_;
  }
  status_and_confidence_ = NULL;
  if (GetArenaNoVirtual() == NULL && color_and_confidence_ != NULL) {
    delete color_and_confidence_;
  }
  color_and_confidence_ = NULL;
  if (GetArenaNoVirtual() == NULL && shape_and_confidence_ != NULL) {
    delete shape_and_confidence_;
  }
  shape_and_confidence_ = NULL;
  _internal_metadata_.Clear();
}

bool TrafficSignalBulb::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_envelope()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_existence_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position_and_accuracy()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence status_and_confidence = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_status_and_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence color_and_confidence = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_color_and_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence shape_and_confidence = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_shape_and_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  return false;
#undef DO_
}

void TrafficSignalBulb::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_envelope(), output);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_existence_confidence(), output);
  }

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  if (this->has_position_and_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_position_and_accuracy(), output);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence status_and_confidence = 4;
  if (this->has_status_and_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_status_and_confidence(), output);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence color_and_confidence = 5;
  if (this->has_color_and_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->_internal_color_and_confidence(), output);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence shape_and_confidence = 6;
  if (this->has_shape_and_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->_internal_shape_and_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
}

::google::protobuf::uint8* TrafficSignalBulb::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_envelope(), deterministic, target);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_existence_confidence(), deterministic, target);
  }

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  if (this->has_position_and_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_position_and_accuracy(), deterministic, target);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence status_and_confidence = 4;
  if (this->has_status_and_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_status_and_confidence(), deterministic, target);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence color_and_confidence = 5;
  if (this->has_color_and_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->_internal_color_and_confidence(), deterministic, target);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence shape_and_confidence = 6;
  if (this->has_shape_and_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->_internal_shape_and_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  return target;
}

size_t TrafficSignalBulb::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *envelope_);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *existence_confidence_);
  }

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 3;
  if (this->has_position_and_accuracy()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_and_accuracy_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.StatusAndConfidence status_and_confidence = 4;
  if (this->has_status_and_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *status_and_confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ColorAndConfidence color_and_confidence = 5;
  if (this->has_color_and_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *color_and_confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb.ShapeAndConfidence shape_and_confidence = 6;
  if (this->has_shape_and_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *shape_and_confidence_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignalBulb::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignalBulb* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignalBulb>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
    MergeFrom(*source);
  }
}

void TrafficSignalBulb::MergeFrom(const TrafficSignalBulb& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_envelope()) {
    mutable_envelope()->::sensoris::protobuf::types::base::EventEnvelope::MergeFrom(from.envelope());
  }
  if (from.has_existence_confidence()) {
    mutable_existence_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.existence_confidence());
  }
  if (from.has_position_and_accuracy()) {
    mutable_position_and_accuracy()->::sensoris::protobuf::types::spatial::PositionAndAccuracy::MergeFrom(from.position_and_accuracy());
  }
  if (from.has_status_and_confidence()) {
    mutable_status_and_confidence()->::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence::MergeFrom(from.status_and_confidence());
  }
  if (from.has_color_and_confidence()) {
    mutable_color_and_confidence()->::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence::MergeFrom(from.color_and_confidence());
  }
  if (from.has_shape_and_confidence()) {
    mutable_shape_and_confidence()->::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence::MergeFrom(from.shape_and_confidence());
  }
}

void TrafficSignalBulb::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignalBulb::CopyFrom(const TrafficSignalBulb& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignalBulb::IsInitialized() const {
  return true;
}

void TrafficSignalBulb::Swap(TrafficSignalBulb* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignalBulb* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignalBulb::UnsafeArenaSwap(TrafficSignalBulb* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignalBulb::InternalSwap(TrafficSignalBulb* other) {
  using std::swap;
  swap(envelope_, other->envelope_);
  swap(existence_confidence_, other->existence_confidence_);
  swap(position_and_accuracy_, other->position_and_accuracy_);
  swap(status_and_confidence_, other->status_and_confidence_);
  swap(color_and_confidence_, other->color_and_confidence_);
  swap(shape_and_confidence_, other->shape_and_confidence_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignalBulb::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TrafficSignal_OrientationAndConfidence::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_OrientationAndConfidence_default_instance_._instance.get_mutable()->confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
}
void TrafficSignal_OrientationAndConfidence::unsafe_arena_set_allocated_confidence(
    ::sensoris::protobuf::types::base::Confidence* confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete confidence_;
  }
  confidence_ = confidence;
  if (confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence.confidence)
}
void TrafficSignal_OrientationAndConfidence::clear_confidence() {
  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignal_OrientationAndConfidence::kTypeFieldNumber;
const int TrafficSignal_OrientationAndConfidence::kConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignal_OrientationAndConfidence::TrafficSignal_OrientationAndConfidence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal_OrientationAndConfidence.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
}
TrafficSignal_OrientationAndConfidence::TrafficSignal_OrientationAndConfidence(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal_OrientationAndConfidence.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
}
TrafficSignal_OrientationAndConfidence::TrafficSignal_OrientationAndConfidence(const TrafficSignal_OrientationAndConfidence& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_confidence()) {
    confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.confidence_);
  } else {
    confidence_ = NULL;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
}

void TrafficSignal_OrientationAndConfidence::SharedCtor() {
  ::memset(&confidence_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&confidence_)) + sizeof(type_));
}

TrafficSignal_OrientationAndConfidence::~TrafficSignal_OrientationAndConfidence() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  SharedDtor();
}

void TrafficSignal_OrientationAndConfidence::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete confidence_;
}

void TrafficSignal_OrientationAndConfidence::ArenaDtor(void* object) {
  TrafficSignal_OrientationAndConfidence* _this = reinterpret_cast< TrafficSignal_OrientationAndConfidence* >(object);
  (void)_this;
}
void TrafficSignal_OrientationAndConfidence::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignal_OrientationAndConfidence::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignal_OrientationAndConfidence::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignal_OrientationAndConfidence& TrafficSignal_OrientationAndConfidence::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal_OrientationAndConfidence.base);
  return *internal_default_instance();
}


void TrafficSignal_OrientationAndConfidence::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && confidence_ != NULL) {
    delete confidence_;
  }
  confidence_ = NULL;
  type_ = 0;
  _internal_metadata_.Clear();
}

bool TrafficSignal_OrientationAndConfidence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence.Type type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence_Type >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  return false;
#undef DO_
}

void TrafficSignal_OrientationAndConfidence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
}

::google::protobuf::uint8* TrafficSignal_OrientationAndConfidence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  return target;
}

size_t TrafficSignal_OrientationAndConfidence::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  if (this->has_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignal_OrientationAndConfidence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignal_OrientationAndConfidence* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignal_OrientationAndConfidence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
    MergeFrom(*source);
  }
}

void TrafficSignal_OrientationAndConfidence::MergeFrom(const TrafficSignal_OrientationAndConfidence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_confidence()) {
    mutable_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.confidence());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void TrafficSignal_OrientationAndConfidence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignal_OrientationAndConfidence::CopyFrom(const TrafficSignal_OrientationAndConfidence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignal_OrientationAndConfidence::IsInitialized() const {
  return true;
}

void TrafficSignal_OrientationAndConfidence::Swap(TrafficSignal_OrientationAndConfidence* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignal_OrientationAndConfidence* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignal_OrientationAndConfidence::UnsafeArenaSwap(TrafficSignal_OrientationAndConfidence* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignal_OrientationAndConfidence::InternalSwap(TrafficSignal_OrientationAndConfidence* other) {
  using std::swap;
  swap(confidence_, other->confidence_);
  swap(type_, other->type_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignal_OrientationAndConfidence::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void TrafficSignal::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->envelope_ = const_cast< ::sensoris::protobuf::types::base::EventEnvelope*>(
      ::sensoris::protobuf::types::base::EventEnvelope::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->existence_confidence_ = const_cast< ::sensoris::protobuf::types::base::Confidence*>(
      ::sensoris::protobuf::types::base::Confidence::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->detection_status_ = const_cast< ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      ::sensoris::protobuf::types::base::EventDetectionStatus::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->rectangular_box_and_accuracy_ = const_cast< ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->bulb_count_and_confidence_ = const_cast< ::sensoris::protobuf::types::base::CountAndConfidence*>(
      ::sensoris::protobuf::types::base::CountAndConfidence::internal_default_instance());
  ::sensoris::protobuf::categories::intersectionattribution::_TrafficSignal_default_instance_._instance.get_mutable()->orientation_and_confidence_ = const_cast< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence*>(
      ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence::internal_default_instance());
}
void TrafficSignal::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  if (GetArenaNoVirtual() == NULL) {
    delete envelope_;
  }
  envelope_ = envelope;
  if (envelope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.envelope)
}
void TrafficSignal::clear_envelope() {
  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
}
void TrafficSignal::unsafe_arena_set_allocated_existence_confidence(
    ::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = existence_confidence;
  if (existence_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.existence_confidence)
}
void TrafficSignal::clear_existence_confidence() {
  if (GetArenaNoVirtual() == NULL && existence_confidence_ != NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = NULL;
}
void TrafficSignal::unsafe_arena_set_allocated_detection_status(
    ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  if (GetArenaNoVirtual() == NULL) {
    delete detection_status_;
  }
  detection_status_ = detection_status;
  if (detection_status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.detection_status)
}
void TrafficSignal::clear_detection_status() {
  if (GetArenaNoVirtual() == NULL && detection_status_ != NULL) {
    delete detection_status_;
  }
  detection_status_ = NULL;
}
void TrafficSignal::unsafe_arena_set_allocated_rectangular_box_and_accuracy(
    ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy) {
  if (GetArenaNoVirtual() == NULL) {
    delete rectangular_box_and_accuracy_;
  }
  rectangular_box_and_accuracy_ = rectangular_box_and_accuracy;
  if (rectangular_box_and_accuracy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.rectangular_box_and_accuracy)
}
void TrafficSignal::clear_rectangular_box_and_accuracy() {
  if (GetArenaNoVirtual() == NULL && rectangular_box_and_accuracy_ != NULL) {
    delete rectangular_box_and_accuracy_;
  }
  rectangular_box_and_accuracy_ = NULL;
}
void TrafficSignal::unsafe_arena_set_allocated_bulb_count_and_confidence(
    ::sensoris::protobuf::types::base::CountAndConfidence* bulb_count_and_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete bulb_count_and_confidence_;
  }
  bulb_count_and_confidence_ = bulb_count_and_confidence;
  if (bulb_count_and_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.bulb_count_and_confidence)
}
void TrafficSignal::clear_bulb_count_and_confidence() {
  if (GetArenaNoVirtual() == NULL && bulb_count_and_confidence_ != NULL) {
    delete bulb_count_and_confidence_;
  }
  bulb_count_and_confidence_ = NULL;
}
void TrafficSignal::unsafe_arena_set_allocated_orientation_and_confidence(
    ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence* orientation_and_confidence) {
  if (GetArenaNoVirtual() == NULL) {
    delete orientation_and_confidence_;
  }
  orientation_and_confidence_ = orientation_and_confidence;
  if (orientation_and_confidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.TrafficSignal.orientation_and_confidence)
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficSignal::kEnvelopeFieldNumber;
const int TrafficSignal::kExistenceConfidenceFieldNumber;
const int TrafficSignal::kDetectionStatusFieldNumber;
const int TrafficSignal::kRectangularBoxAndAccuracyFieldNumber;
const int TrafficSignal::kBulbCountAndConfidenceFieldNumber;
const int TrafficSignal::kOrientationAndConfidenceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficSignal::TrafficSignal()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
}
TrafficSignal::TrafficSignal(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
}
TrafficSignal::TrafficSignal(const TrafficSignal& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_envelope()) {
    envelope_ = new ::sensoris::protobuf::types::base::EventEnvelope(*from.envelope_);
  } else {
    envelope_ = NULL;
  }
  if (from.has_existence_confidence()) {
    existence_confidence_ = new ::sensoris::protobuf::types::base::Confidence(*from.existence_confidence_);
  } else {
    existence_confidence_ = NULL;
  }
  if (from.has_detection_status()) {
    detection_status_ = new ::sensoris::protobuf::types::base::EventDetectionStatus(*from.detection_status_);
  } else {
    detection_status_ = NULL;
  }
  if (from.has_rectangular_box_and_accuracy()) {
    rectangular_box_and_accuracy_ = new ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy(*from.rectangular_box_and_accuracy_);
  } else {
    rectangular_box_and_accuracy_ = NULL;
  }
  if (from.has_bulb_count_and_confidence()) {
    bulb_count_and_confidence_ = new ::sensoris::protobuf::types::base::CountAndConfidence(*from.bulb_count_and_confidence_);
  } else {
    bulb_count_and_confidence_ = NULL;
  }
  if (from.has_orientation_and_confidence()) {
    orientation_and_confidence_ = new ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence(*from.orientation_and_confidence_);
  } else {
    orientation_and_confidence_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
}

void TrafficSignal::SharedCtor() {
  ::memset(&envelope_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&orientation_and_confidence_) -
      reinterpret_cast<char*>(&envelope_)) + sizeof(orientation_and_confidence_));
}

TrafficSignal::~TrafficSignal() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  SharedDtor();
}

void TrafficSignal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete envelope_;
  if (this != internal_default_instance()) delete existence_confidence_;
  if (this != internal_default_instance()) delete detection_status_;
  if (this != internal_default_instance()) delete rectangular_box_and_accuracy_;
  if (this != internal_default_instance()) delete bulb_count_and_confidence_;
  if (this != internal_default_instance()) delete orientation_and_confidence_;
}

void TrafficSignal::ArenaDtor(void* object) {
  TrafficSignal* _this = reinterpret_cast< TrafficSignal* >(object);
  (void)_this;
}
void TrafficSignal::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void TrafficSignal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* TrafficSignal::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const TrafficSignal& TrafficSignal::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_TrafficSignal.base);
  return *internal_default_instance();
}


void TrafficSignal::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
  if (GetArenaNoVirtual() == NULL && existence_confidence_ != NULL) {
    delete existence_confidence_;
  }
  existence_confidence_ = NULL;
  if (GetArenaNoVirtual() == NULL && detection_status_ != NULL) {
    delete detection_status_;
  }
  detection_status_ = NULL;
  if (GetArenaNoVirtual() == NULL && rectangular_box_and_accuracy_ != NULL) {
    delete rectangular_box_and_accuracy_;
  }
  rectangular_box_and_accuracy_ = NULL;
  if (GetArenaNoVirtual() == NULL && bulb_count_and_confidence_ != NULL) {
    delete bulb_count_and_confidence_;
  }
  bulb_count_and_confidence_ = NULL;
  if (GetArenaNoVirtual() == NULL && orientation_and_confidence_ != NULL) {
    delete orientation_and_confidence_;
  }
  orientation_and_confidence_ = NULL;
  _internal_metadata_.Clear();
}

bool TrafficSignal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_envelope()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_existence_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_detection_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_rectangular_box_and_accuracy()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.types.base.CountAndConfidence bulb_count_and_confidence = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_bulb_count_and_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence orientation_and_confidence = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_orientation_and_confidence()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  return false;
#undef DO_
}

void TrafficSignal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_envelope(), output);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->_internal_existence_confidence(), output);
  }

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  if (this->has_detection_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->_internal_detection_status(), output);
  }

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
  if (this->has_rectangular_box_and_accuracy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->_internal_rectangular_box_and_accuracy(), output);
  }

  // .sensoris.protobuf.types.base.CountAndConfidence bulb_count_and_confidence = 5;
  if (this->has_bulb_count_and_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->_internal_bulb_count_and_confidence(), output);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence orientation_and_confidence = 6;
  if (this->has_orientation_and_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->_internal_orientation_and_confidence(), output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
}

::google::protobuf::uint8* TrafficSignal::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_envelope(), deterministic, target);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->_internal_existence_confidence(), deterministic, target);
  }

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  if (this->has_detection_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->_internal_detection_status(), deterministic, target);
  }

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
  if (this->has_rectangular_box_and_accuracy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->_internal_rectangular_box_and_accuracy(), deterministic, target);
  }

  // .sensoris.protobuf.types.base.CountAndConfidence bulb_count_and_confidence = 5;
  if (this->has_bulb_count_and_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->_internal_bulb_count_and_confidence(), deterministic, target);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence orientation_and_confidence = 6;
  if (this->has_orientation_and_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, this->_internal_orientation_and_confidence(), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  return target;
}

size_t TrafficSignal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  if (this->has_envelope()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *envelope_);
  }

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  if (this->has_existence_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *existence_confidence_);
  }

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  if (this->has_detection_status()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *detection_status_);
  }

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
  if (this->has_rectangular_box_and_accuracy()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *rectangular_box_and_accuracy_);
  }

  // .sensoris.protobuf.types.base.CountAndConfidence bulb_count_and_confidence = 5;
  if (this->has_bulb_count_and_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *bulb_count_and_confidence_);
  }

  // .sensoris.protobuf.categories.intersectionattribution.TrafficSignal.OrientationAndConfidence orientation_and_confidence = 6;
  if (this->has_orientation_and_confidence()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *orientation_and_confidence_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrafficSignal::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  GOOGLE_DCHECK_NE(&from, this);
  const TrafficSignal* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficSignal>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
    MergeFrom(*source);
  }
}

void TrafficSignal::MergeFrom(const TrafficSignal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_envelope()) {
    mutable_envelope()->::sensoris::protobuf::types::base::EventEnvelope::MergeFrom(from.envelope());
  }
  if (from.has_existence_confidence()) {
    mutable_existence_confidence()->::sensoris::protobuf::types::base::Confidence::MergeFrom(from.existence_confidence());
  }
  if (from.has_detection_status()) {
    mutable_detection_status()->::sensoris::protobuf::types::base::EventDetectionStatus::MergeFrom(from.detection_status());
  }
  if (from.has_rectangular_box_and_accuracy()) {
    mutable_rectangular_box_and_accuracy()->::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy::MergeFrom(from.rectangular_box_and_accuracy());
  }
  if (from.has_bulb_count_and_confidence()) {
    mutable_bulb_count_and_confidence()->::sensoris::protobuf::types::base::CountAndConfidence::MergeFrom(from.bulb_count_and_confidence());
  }
  if (from.has_orientation_and_confidence()) {
    mutable_orientation_and_confidence()->::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence::MergeFrom(from.orientation_and_confidence());
  }
}

void TrafficSignal::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficSignal::CopyFrom(const TrafficSignal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.TrafficSignal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficSignal::IsInitialized() const {
  return true;
}

void TrafficSignal::Swap(TrafficSignal* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    TrafficSignal* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void TrafficSignal::UnsafeArenaSwap(TrafficSignal* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void TrafficSignal::InternalSwap(TrafficSignal* other) {
  using std::swap;
  swap(envelope_, other->envelope_);
  swap(existence_confidence_, other->existence_confidence_);
  swap(detection_status_, other->detection_status_);
  swap(rectangular_box_and_accuracy_, other->rectangular_box_and_accuracy_);
  swap(bulb_count_and_confidence_, other->bulb_count_and_confidence_);
  swap(orientation_and_confidence_, other->orientation_and_confidence_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata TrafficSignal::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void IntersectionAttributionCategory::InitAsDefaultInstance() {
  ::sensoris::protobuf::categories::intersectionattribution::_IntersectionAttributionCategory_default_instance_._instance.get_mutable()->envelope_ = const_cast< ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      ::sensoris::protobuf::types::base::CategoryEnvelope::internal_default_instance());
}
void IntersectionAttributionCategory::unsafe_arena_set_allocated_envelope(
    ::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  if (GetArenaNoVirtual() == NULL) {
    delete envelope_;
  }
  envelope_ = envelope;
  if (envelope) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory.envelope)
}
void IntersectionAttributionCategory::clear_envelope() {
  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IntersectionAttributionCategory::kEnvelopeFieldNumber;
const int IntersectionAttributionCategory::kTrafficSignalBulbFieldNumber;
const int IntersectionAttributionCategory::kTrafficSignalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IntersectionAttributionCategory::IntersectionAttributionCategory()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_IntersectionAttributionCategory.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
}
IntersectionAttributionCategory::IntersectionAttributionCategory(::google::protobuf::Arena* arena)
  : ::google::protobuf::Message(),
  _internal_metadata_(arena),
  traffic_signal_bulb_(arena),
  traffic_signal_(arena) {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_IntersectionAttributionCategory.base);
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
}
IntersectionAttributionCategory::IntersectionAttributionCategory(const IntersectionAttributionCategory& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      traffic_signal_bulb_(from.traffic_signal_bulb_),
      traffic_signal_(from.traffic_signal_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_envelope()) {
    envelope_ = new ::sensoris::protobuf::types::base::CategoryEnvelope(*from.envelope_);
  } else {
    envelope_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
}

void IntersectionAttributionCategory::SharedCtor() {
  envelope_ = NULL;
}

IntersectionAttributionCategory::~IntersectionAttributionCategory() {
  // @@protoc_insertion_point(destructor:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  SharedDtor();
}

void IntersectionAttributionCategory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaNoVirtual() == NULL);
  if (this != internal_default_instance()) delete envelope_;
}

void IntersectionAttributionCategory::ArenaDtor(void* object) {
  IntersectionAttributionCategory* _this = reinterpret_cast< IntersectionAttributionCategory* >(object);
  (void)_this;
}
void IntersectionAttributionCategory::RegisterArenaDtor(::google::protobuf::Arena* arena) {
}
void IntersectionAttributionCategory::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ::google::protobuf::Descriptor* IntersectionAttributionCategory::descriptor() {
  ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const IntersectionAttributionCategory& IntersectionAttributionCategory::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::scc_info_IntersectionAttributionCategory.base);
  return *internal_default_instance();
}


void IntersectionAttributionCategory::Clear() {
// @@protoc_insertion_point(message_clear_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  traffic_signal_bulb_.Clear();
  traffic_signal_.Clear();
  if (GetArenaNoVirtual() == NULL && envelope_ != NULL) {
    delete envelope_;
  }
  envelope_ = NULL;
  _internal_metadata_.Clear();
}

bool IntersectionAttributionCategory::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_envelope()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb traffic_signal_bulb = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_traffic_signal_bulb()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignal traffic_signal = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_traffic_signal()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  return false;
#undef DO_
}

void IntersectionAttributionCategory::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  if (this->has_envelope()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->_internal_envelope(), output);
  }

  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb traffic_signal_bulb = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->traffic_signal_bulb_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->traffic_signal_bulb(static_cast<int>(i)),
      output);
  }

  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignal traffic_signal = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->traffic_signal_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3,
      this->traffic_signal(static_cast<int>(i)),
      output);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), output);
  }
  // @@protoc_insertion_point(serialize_end:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
}

::google::protobuf::uint8* IntersectionAttributionCategory::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  if (this->has_envelope()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->_internal_envelope(), deterministic, target);
  }

  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb traffic_signal_bulb = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->traffic_signal_bulb_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->traffic_signal_bulb(static_cast<int>(i)), deterministic, target);
  }

  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignal traffic_signal = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->traffic_signal_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->traffic_signal(static_cast<int>(i)), deterministic, target);
  }

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  return target;
}

size_t IntersectionAttributionCategory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  size_t total_size = 0;

  if ((_internal_metadata_.have_unknown_fields() &&  ::google::protobuf::internal::GetProto3PreserveUnknownsDefault())) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        (::google::protobuf::internal::GetProto3PreserveUnknownsDefault()   ? _internal_metadata_.unknown_fields()   : _internal_metadata_.default_instance()));
  }
  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignalBulb traffic_signal_bulb = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->traffic_signal_bulb_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->traffic_signal_bulb(static_cast<int>(i)));
    }
  }

  // repeated .sensoris.protobuf.categories.intersectionattribution.TrafficSignal traffic_signal = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->traffic_signal_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->traffic_signal(static_cast<int>(i)));
    }
  }

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  if (this->has_envelope()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *envelope_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IntersectionAttributionCategory::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  GOOGLE_DCHECK_NE(&from, this);
  const IntersectionAttributionCategory* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const IntersectionAttributionCategory>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
    MergeFrom(*source);
  }
}

void IntersectionAttributionCategory::MergeFrom(const IntersectionAttributionCategory& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  traffic_signal_bulb_.MergeFrom(from.traffic_signal_bulb_);
  traffic_signal_.MergeFrom(from.traffic_signal_);
  if (from.has_envelope()) {
    mutable_envelope()->::sensoris::protobuf::types::base::CategoryEnvelope::MergeFrom(from.envelope());
  }
}

void IntersectionAttributionCategory::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IntersectionAttributionCategory::CopyFrom(const IntersectionAttributionCategory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sensoris.protobuf.categories.intersectionattribution.IntersectionAttributionCategory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntersectionAttributionCategory::IsInitialized() const {
  return true;
}

void IntersectionAttributionCategory::Swap(IntersectionAttributionCategory* other) {
  if (other == this) return;
  if (GetArenaNoVirtual() == other->GetArenaNoVirtual()) {
    InternalSwap(other);
  } else {
    IntersectionAttributionCategory* temp = New(GetArenaNoVirtual());
    temp->MergeFrom(*other);
    other->CopyFrom(*this);
    InternalSwap(temp);
    if (GetArenaNoVirtual() == NULL) {
      delete temp;
    }
  }
}
void IntersectionAttributionCategory::UnsafeArenaSwap(IntersectionAttributionCategory* other) {
  if (other == this) return;
  GOOGLE_DCHECK(GetArenaNoVirtual() == other->GetArenaNoVirtual());
  InternalSwap(other);
}
void IntersectionAttributionCategory::InternalSwap(IntersectionAttributionCategory* other) {
  using std::swap;
  CastToBase(&traffic_signal_bulb_)->InternalSwap(CastToBase(&other->traffic_signal_bulb_));
  CastToBase(&traffic_signal_)->InternalSwap(CastToBase(&other->traffic_signal_));
  swap(envelope_, other->envelope_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::google::protobuf::Metadata IntersectionAttributionCategory::GetMetadata() const {
  protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_sensoris_2fprotobuf_2fcategories_2fintersection_5fattribution_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace intersectionattribution
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_StatusAndConfidence >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ColorAndConfidence >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb_ShapeAndConfidence >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignalBulb >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal_OrientationAndConfidence >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::TrafficSignal >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory* Arena::CreateMaybeMessage< ::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sensoris::protobuf::categories::intersectionattribution::IntersectionAttributionCategory >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

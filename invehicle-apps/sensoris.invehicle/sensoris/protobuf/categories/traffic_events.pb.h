// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/traffic_events.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto 

namespace protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {
class DangerousSlowDown;
class DangerousSlowDownDefaultTypeInternal;
extern DangerousSlowDownDefaultTypeInternal _DangerousSlowDown_default_instance_;
class Hazard;
class HazardDefaultTypeInternal;
extern HazardDefaultTypeInternal _Hazard_default_instance_;
class Hazard_TypeAndConfidence;
class Hazard_TypeAndConfidenceDefaultTypeInternal;
extern Hazard_TypeAndConfidenceDefaultTypeInternal _Hazard_TypeAndConfidence_default_instance_;
class RoadWeatherCondition;
class RoadWeatherConditionDefaultTypeInternal;
extern RoadWeatherConditionDefaultTypeInternal _RoadWeatherCondition_default_instance_;
class RoadWeatherCondition_TypeAndConfidence;
class RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal;
extern RoadWeatherCondition_TypeAndConfidenceDefaultTypeInternal _RoadWeatherCondition_TypeAndConfidence_default_instance_;
class RoadWorks;
class RoadWorksDefaultTypeInternal;
extern RoadWorksDefaultTypeInternal _RoadWorks_default_instance_;
class RoadWorks_TypeAndConfidence;
class RoadWorks_TypeAndConfidenceDefaultTypeInternal;
extern RoadWorks_TypeAndConfidenceDefaultTypeInternal _RoadWorks_TypeAndConfidence_default_instance_;
class TrafficCondition;
class TrafficConditionDefaultTypeInternal;
extern TrafficConditionDefaultTypeInternal _TrafficCondition_default_instance_;
class TrafficCondition_TypeAndConfidence;
class TrafficCondition_TypeAndConfidenceDefaultTypeInternal;
extern TrafficCondition_TypeAndConfidenceDefaultTypeInternal _TrafficCondition_TypeAndConfidence_default_instance_;
class TrafficEventsCategory;
class TrafficEventsCategoryDefaultTypeInternal;
extern TrafficEventsCategoryDefaultTypeInternal _TrafficEventsCategory_default_instance_;
}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::DangerousSlowDown>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::Hazard* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::Hazard>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::RoadWorks* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWorks>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::TrafficCondition* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficCondition>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficevents::TrafficEventsCategory* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficEventsCategory>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficevents {

enum Hazard_TypeAndConfidence_Type {
  Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  Hazard_TypeAndConfidence_Type_OBSTRUCTION = 1,
  Hazard_TypeAndConfidence_Type_ACCIDENT = 2,
  Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE = 3,
  Hazard_TypeAndConfidence_Type_SLOW_VEHICLE = 4,
  Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE = 5,
  Hazard_TypeAndConfidence_Type_ROADWORKS = 6,
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Hazard_TypeAndConfidence_Type_Hazard_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Hazard_TypeAndConfidence_Type_IsValid(int value);
const Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MIN = Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE;
const Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence_Type_Type_MAX = Hazard_TypeAndConfidence_Type_ROADWORKS;
const int Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE = Hazard_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Hazard_TypeAndConfidence_Type_descriptor();
inline const ::std::string& Hazard_TypeAndConfidence_Type_Name(Hazard_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Hazard_TypeAndConfidence_Type_descriptor(), value);
}
inline bool Hazard_TypeAndConfidence_Type_Parse(
    const ::std::string& name, Hazard_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_TypeAndConfidence_Type>(
    Hazard_TypeAndConfidence_Type_descriptor(), name, value);
}
enum Hazard_Direction {
  Hazard_Direction_UNKNOWN_DIRECTION = 0,
  Hazard_Direction_EGO_DIRECTION = 1,
  Hazard_Direction_OPPOSITE_DIRECTION = 2,
  Hazard_Direction_BOTH = 3,
  Hazard_Direction_Hazard_Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Hazard_Direction_Hazard_Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Hazard_Direction_IsValid(int value);
const Hazard_Direction Hazard_Direction_Direction_MIN = Hazard_Direction_UNKNOWN_DIRECTION;
const Hazard_Direction Hazard_Direction_Direction_MAX = Hazard_Direction_BOTH;
const int Hazard_Direction_Direction_ARRAYSIZE = Hazard_Direction_Direction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Hazard_Direction_descriptor();
inline const ::std::string& Hazard_Direction_Name(Hazard_Direction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Hazard_Direction_descriptor(), value);
}
inline bool Hazard_Direction_Parse(
    const ::std::string& name, Hazard_Direction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hazard_Direction>(
    Hazard_Direction_descriptor(), name, value);
}
enum TrafficCondition_TypeAndConfidence_Type {
  TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficCondition_TypeAndConfidence_Type_FREE_FLOW = 1,
  TrafficCondition_TypeAndConfidence_Type_HEAVY = 2,
  TrafficCondition_TypeAndConfidence_Type_SLOW = 3,
  TrafficCondition_TypeAndConfidence_Type_QUEUING = 4,
  TrafficCondition_TypeAndConfidence_Type_STATIONARY = 5,
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficCondition_TypeAndConfidence_Type_TrafficCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficCondition_TypeAndConfidence_Type_IsValid(int value);
const TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MIN = TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
const TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence_Type_Type_MAX = TrafficCondition_TypeAndConfidence_Type_STATIONARY;
const int TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = TrafficCondition_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficCondition_TypeAndConfidence_Type_descriptor();
inline const ::std::string& TrafficCondition_TypeAndConfidence_Type_Name(TrafficCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficCondition_TypeAndConfidence_Type_descriptor(), value);
}
inline bool TrafficCondition_TypeAndConfidence_Type_Parse(
    const ::std::string& name, TrafficCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficCondition_TypeAndConfidence_Type>(
    TrafficCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWorks_TypeAndConfidence_Type {
  RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWorks_TypeAndConfidence_Type_START = 1,
  RoadWorks_TypeAndConfidence_Type_END = 2,
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadWorks_TypeAndConfidence_Type_RoadWorks_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadWorks_TypeAndConfidence_Type_IsValid(int value);
const RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MIN = RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE;
const RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence_Type_Type_MAX = RoadWorks_TypeAndConfidence_Type_END;
const int RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE = RoadWorks_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadWorks_TypeAndConfidence_Type_descriptor();
inline const ::std::string& RoadWorks_TypeAndConfidence_Type_Name(RoadWorks_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadWorks_TypeAndConfidence_Type_descriptor(), value);
}
inline bool RoadWorks_TypeAndConfidence_Type_Parse(
    const ::std::string& name, RoadWorks_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWorks_TypeAndConfidence_Type>(
    RoadWorks_TypeAndConfidence_Type_descriptor(), name, value);
}
enum RoadWeatherCondition_TypeAndConfidence_Type {
  RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  RoadWeatherCondition_TypeAndConfidence_Type_SNOW = 1,
  RoadWeatherCondition_TypeAndConfidence_Type_ICE = 2,
  RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN = 3,
  RoadWeatherCondition_TypeAndConfidence_Type_FROST = 4,
  RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING = 5,
  RoadWeatherCondition_TypeAndConfidence_Type_FLOODING = 6,
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RoadWeatherCondition_TypeAndConfidence_Type_RoadWeatherCondition_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RoadWeatherCondition_TypeAndConfidence_Type_IsValid(int value);
const RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN = RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
const RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX = RoadWeatherCondition_TypeAndConfidence_Type_FLOODING;
const int RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE = RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
inline const ::std::string& RoadWeatherCondition_TypeAndConfidence_Type_Name(RoadWeatherCondition_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadWeatherCondition_TypeAndConfidence_Type_descriptor(), value);
}
inline bool RoadWeatherCondition_TypeAndConfidence_Type_Parse(
    const ::std::string& name, RoadWeatherCondition_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadWeatherCondition_TypeAndConfidence_Type>(
    RoadWeatherCondition_TypeAndConfidence_Type_descriptor(), name, value);
}
// ===================================================================

class Hazard_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence) */ {
 public:
  Hazard_TypeAndConfidence();
  virtual ~Hazard_TypeAndConfidence();

  Hazard_TypeAndConfidence(const Hazard_TypeAndConfidence& from);

  inline Hazard_TypeAndConfidence& operator=(const Hazard_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hazard_TypeAndConfidence(Hazard_TypeAndConfidence&& from) noexcept
    : Hazard_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline Hazard_TypeAndConfidence& operator=(Hazard_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hazard_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hazard_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const Hazard_TypeAndConfidence*>(
               &_Hazard_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(Hazard_TypeAndConfidence* other);
  void Swap(Hazard_TypeAndConfidence* other);
  friend void swap(Hazard_TypeAndConfidence& a, Hazard_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hazard_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<Hazard_TypeAndConfidence>(NULL);
  }

  Hazard_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Hazard_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Hazard_TypeAndConfidence& from);
  void MergeFrom(const Hazard_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hazard_TypeAndConfidence* other);
  protected:
  explicit Hazard_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Hazard_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    Hazard_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type OBSTRUCTION =
    Hazard_TypeAndConfidence_Type_OBSTRUCTION;
  static const Type ACCIDENT =
    Hazard_TypeAndConfidence_Type_ACCIDENT;
  static const Type BROKEN_DOWN_VEHICLE =
    Hazard_TypeAndConfidence_Type_BROKEN_DOWN_VEHICLE;
  static const Type SLOW_VEHICLE =
    Hazard_TypeAndConfidence_Type_SLOW_VEHICLE;
  static const Type WRONG_WAY_VEHICLE =
    Hazard_TypeAndConfidence_Type_WRONG_WAY_VEHICLE;
  static const Type ROADWORKS =
    Hazard_TypeAndConfidence_Type_ROADWORKS;
  static inline bool Type_IsValid(int value) {
    return Hazard_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Hazard_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    Hazard_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Hazard_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Hazard_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Hazard_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Hazard_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Hazard : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.Hazard) */ {
 public:
  Hazard();
  virtual ~Hazard();

  Hazard(const Hazard& from);

  inline Hazard& operator=(const Hazard& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hazard(Hazard&& from) noexcept
    : Hazard() {
    *this = ::std::move(from);
  }

  inline Hazard& operator=(Hazard&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const Hazard& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hazard* internal_default_instance() {
    return reinterpret_cast<const Hazard*>(
               &_Hazard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(Hazard* other);
  void Swap(Hazard* other);
  friend void swap(Hazard& a, Hazard& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hazard* New() const final {
    return CreateMaybeMessage<Hazard>(NULL);
  }

  Hazard* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Hazard>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Hazard& from);
  void MergeFrom(const Hazard& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hazard* other);
  protected:
  explicit Hazard(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Hazard_TypeAndConfidence TypeAndConfidence;

  typedef Hazard_Direction Direction;
  static const Direction UNKNOWN_DIRECTION =
    Hazard_Direction_UNKNOWN_DIRECTION;
  static const Direction EGO_DIRECTION =
    Hazard_Direction_EGO_DIRECTION;
  static const Direction OPPOSITE_DIRECTION =
    Hazard_Direction_OPPOSITE_DIRECTION;
  static const Direction BOTH =
    Hazard_Direction_BOTH;
  static inline bool Direction_IsValid(int value) {
    return Hazard_Direction_IsValid(value);
  }
  static const Direction Direction_MIN =
    Hazard_Direction_Direction_MIN;
  static const Direction Direction_MAX =
    Hazard_Direction_Direction_MAX;
  static const int Direction_ARRAYSIZE =
    Hazard_Direction_Direction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Direction_descriptor() {
    return Hazard_Direction_descriptor();
  }
  static inline const ::std::string& Direction_Name(Direction value) {
    return Hazard_Direction_Name(value);
  }
  static inline bool Direction_Parse(const ::std::string& name,
      Direction* value) {
    return Hazard_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
  void clear_direction();
  static const int kDirectionFieldNumber = 4;
  ::sensoris::protobuf::categories::trafficevents::Hazard_Direction direction() const;
  void set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.Hazard)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence_;
  int direction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DangerousSlowDown : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.DangerousSlowDown) */ {
 public:
  DangerousSlowDown();
  virtual ~DangerousSlowDown();

  DangerousSlowDown(const DangerousSlowDown& from);

  inline DangerousSlowDown& operator=(const DangerousSlowDown& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DangerousSlowDown(DangerousSlowDown&& from) noexcept
    : DangerousSlowDown() {
    *this = ::std::move(from);
  }

  inline DangerousSlowDown& operator=(DangerousSlowDown&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const DangerousSlowDown& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DangerousSlowDown* internal_default_instance() {
    return reinterpret_cast<const DangerousSlowDown*>(
               &_DangerousSlowDown_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(DangerousSlowDown* other);
  void Swap(DangerousSlowDown* other);
  friend void swap(DangerousSlowDown& a, DangerousSlowDown& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DangerousSlowDown* New() const final {
    return CreateMaybeMessage<DangerousSlowDown>(NULL);
  }

  DangerousSlowDown* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DangerousSlowDown>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DangerousSlowDown& from);
  void MergeFrom(const DangerousSlowDown& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DangerousSlowDown* other);
  protected:
  explicit DangerousSlowDown(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_speed_reduction_and_accuracy() const;
  void clear_speed_reduction_and_accuracy();
  static const int kSpeedReductionAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_speed_reduction_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& speed_reduction_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_speed_reduction_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_speed_reduction_and_accuracy();
  void set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy);
  void unsafe_arena_set_allocated_speed_reduction_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_speed_reduction_and_accuracy();

  // .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_time_period() const;
  void clear_time_period();
  static const int kTimePeriodFieldNumber = 3;
  private:
  const ::google::protobuf::Int64Value& _internal_time_period() const;
  public:
  const ::google::protobuf::Int64Value& time_period() const;
  ::google::protobuf::Int64Value* release_time_period();
  ::google::protobuf::Int64Value* mutable_time_period();
  void set_allocated_time_period(::google::protobuf::Int64Value* time_period);
  void unsafe_arena_set_allocated_time_period(
      ::google::protobuf::Int64Value* time_period);
  ::google::protobuf::Int64Value* unsafe_arena_release_time_period();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.DangerousSlowDown)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy_;
  ::google::protobuf::Int64Value* time_period_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficCondition_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence) */ {
 public:
  TrafficCondition_TypeAndConfidence();
  virtual ~TrafficCondition_TypeAndConfidence();

  TrafficCondition_TypeAndConfidence(const TrafficCondition_TypeAndConfidence& from);

  inline TrafficCondition_TypeAndConfidence& operator=(const TrafficCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficCondition_TypeAndConfidence(TrafficCondition_TypeAndConfidence&& from) noexcept
    : TrafficCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficCondition_TypeAndConfidence& operator=(TrafficCondition_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficCondition_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition_TypeAndConfidence*>(
               &_TrafficCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(TrafficCondition_TypeAndConfidence* other);
  void Swap(TrafficCondition_TypeAndConfidence* other);
  friend void swap(TrafficCondition_TypeAndConfidence& a, TrafficCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficCondition_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficCondition_TypeAndConfidence>(NULL);
  }

  TrafficCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficCondition_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficCondition_TypeAndConfidence& from);
  void MergeFrom(const TrafficCondition_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficCondition_TypeAndConfidence* other);
  protected:
  explicit TrafficCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficCondition_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type FREE_FLOW =
    TrafficCondition_TypeAndConfidence_Type_FREE_FLOW;
  static const Type HEAVY =
    TrafficCondition_TypeAndConfidence_Type_HEAVY;
  static const Type SLOW =
    TrafficCondition_TypeAndConfidence_Type_SLOW;
  static const Type QUEUING =
    TrafficCondition_TypeAndConfidence_Type_QUEUING;
  static const Type STATIONARY =
    TrafficCondition_TypeAndConfidence_Type_STATIONARY;
  static inline bool Type_IsValid(int value) {
    return TrafficCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficCondition_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficCondition_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficCondition_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficCondition) */ {
 public:
  TrafficCondition();
  virtual ~TrafficCondition();

  TrafficCondition(const TrafficCondition& from);

  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficCondition(TrafficCondition&& from) noexcept
    : TrafficCondition() {
    *this = ::std::move(from);
  }

  inline TrafficCondition& operator=(TrafficCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficCondition* internal_default_instance() {
    return reinterpret_cast<const TrafficCondition*>(
               &_TrafficCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(TrafficCondition* other);
  void Swap(TrafficCondition* other);
  friend void swap(TrafficCondition& a, TrafficCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficCondition* New() const final {
    return CreateMaybeMessage<TrafficCondition>(NULL);
  }

  TrafficCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficCondition& from);
  void MergeFrom(const TrafficCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficCondition* other);
  protected:
  explicit TrafficCondition(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficCondition_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadWorks_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence) */ {
 public:
  RoadWorks_TypeAndConfidence();
  virtual ~RoadWorks_TypeAndConfidence();

  RoadWorks_TypeAndConfidence(const RoadWorks_TypeAndConfidence& from);

  inline RoadWorks_TypeAndConfidence& operator=(const RoadWorks_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadWorks_TypeAndConfidence(RoadWorks_TypeAndConfidence&& from) noexcept
    : RoadWorks_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWorks_TypeAndConfidence& operator=(RoadWorks_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadWorks_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadWorks_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWorks_TypeAndConfidence*>(
               &_RoadWorks_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(RoadWorks_TypeAndConfidence* other);
  void Swap(RoadWorks_TypeAndConfidence* other);
  friend void swap(RoadWorks_TypeAndConfidence& a, RoadWorks_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadWorks_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<RoadWorks_TypeAndConfidence>(NULL);
  }

  RoadWorks_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadWorks_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadWorks_TypeAndConfidence& from);
  void MergeFrom(const RoadWorks_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadWorks_TypeAndConfidence* other);
  protected:
  explicit RoadWorks_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadWorks_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    RoadWorks_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type START =
    RoadWorks_TypeAndConfidence_Type_START;
  static const Type END =
    RoadWorks_TypeAndConfidence_Type_END;
  static inline bool Type_IsValid(int value) {
    return RoadWorks_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoadWorks_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    RoadWorks_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoadWorks_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoadWorks_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoadWorks_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoadWorks_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadWorks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWorks) */ {
 public:
  RoadWorks();
  virtual ~RoadWorks();

  RoadWorks(const RoadWorks& from);

  inline RoadWorks& operator=(const RoadWorks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadWorks(RoadWorks&& from) noexcept
    : RoadWorks() {
    *this = ::std::move(from);
  }

  inline RoadWorks& operator=(RoadWorks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadWorks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadWorks* internal_default_instance() {
    return reinterpret_cast<const RoadWorks*>(
               &_RoadWorks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(RoadWorks* other);
  void Swap(RoadWorks* other);
  friend void swap(RoadWorks& a, RoadWorks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadWorks* New() const final {
    return CreateMaybeMessage<RoadWorks>(NULL);
  }

  RoadWorks* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadWorks>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadWorks& from);
  void MergeFrom(const RoadWorks& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadWorks* other);
  protected:
  explicit RoadWorks(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadWorks_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
  bool has_lanes_closed_and_confidence() const;
  void clear_lanes_closed_and_confidence();
  static const int kLanesClosedAndConfidenceFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::base::CountAndConfidence& _internal_lanes_closed_and_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::CountAndConfidence& lanes_closed_and_confidence() const;
  ::sensoris::protobuf::types::base::CountAndConfidence* release_lanes_closed_and_confidence();
  ::sensoris::protobuf::types::base::CountAndConfidence* mutable_lanes_closed_and_confidence();
  void set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence);
  void unsafe_arena_set_allocated_lanes_closed_and_confidence(
      ::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence);
  ::sensoris::protobuf::types::base::CountAndConfidence* unsafe_arena_release_lanes_closed_and_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWorks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadWeatherCondition_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence) */ {
 public:
  RoadWeatherCondition_TypeAndConfidence();
  virtual ~RoadWeatherCondition_TypeAndConfidence();

  RoadWeatherCondition_TypeAndConfidence(const RoadWeatherCondition_TypeAndConfidence& from);

  inline RoadWeatherCondition_TypeAndConfidence& operator=(const RoadWeatherCondition_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadWeatherCondition_TypeAndConfidence(RoadWeatherCondition_TypeAndConfidence&& from) noexcept
    : RoadWeatherCondition_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition_TypeAndConfidence& operator=(RoadWeatherCondition_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadWeatherCondition_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadWeatherCondition_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition_TypeAndConfidence*>(
               &_RoadWeatherCondition_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(RoadWeatherCondition_TypeAndConfidence* other);
  void Swap(RoadWeatherCondition_TypeAndConfidence* other);
  friend void swap(RoadWeatherCondition_TypeAndConfidence& a, RoadWeatherCondition_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadWeatherCondition_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<RoadWeatherCondition_TypeAndConfidence>(NULL);
  }

  RoadWeatherCondition_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadWeatherCondition_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadWeatherCondition_TypeAndConfidence& from);
  void MergeFrom(const RoadWeatherCondition_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadWeatherCondition_TypeAndConfidence* other);
  protected:
  explicit RoadWeatherCondition_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadWeatherCondition_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    RoadWeatherCondition_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type SNOW =
    RoadWeatherCondition_TypeAndConfidence_Type_SNOW;
  static const Type ICE =
    RoadWeatherCondition_TypeAndConfidence_Type_ICE;
  static const Type FREEZING_RAIN =
    RoadWeatherCondition_TypeAndConfidence_Type_FREEZING_RAIN;
  static const Type FROST =
    RoadWeatherCondition_TypeAndConfidence_Type_FROST;
  static const Type HYDROPLANING =
    RoadWeatherCondition_TypeAndConfidence_Type_HYDROPLANING;
  static const Type FLOODING =
    RoadWeatherCondition_TypeAndConfidence_Type_FLOODING;
  static inline bool Type_IsValid(int value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RoadWeatherCondition_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    RoadWeatherCondition_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RoadWeatherCondition_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return RoadWeatherCondition_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadWeatherCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition) */ {
 public:
  RoadWeatherCondition();
  virtual ~RoadWeatherCondition();

  RoadWeatherCondition(const RoadWeatherCondition& from);

  inline RoadWeatherCondition& operator=(const RoadWeatherCondition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadWeatherCondition(RoadWeatherCondition&& from) noexcept
    : RoadWeatherCondition() {
    *this = ::std::move(from);
  }

  inline RoadWeatherCondition& operator=(RoadWeatherCondition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadWeatherCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadWeatherCondition* internal_default_instance() {
    return reinterpret_cast<const RoadWeatherCondition*>(
               &_RoadWeatherCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(RoadWeatherCondition* other);
  void Swap(RoadWeatherCondition* other);
  friend void swap(RoadWeatherCondition& a, RoadWeatherCondition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadWeatherCondition* New() const final {
    return CreateMaybeMessage<RoadWeatherCondition>(NULL);
  }

  RoadWeatherCondition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadWeatherCondition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadWeatherCondition& from);
  void MergeFrom(const RoadWeatherCondition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadWeatherCondition* other);
  protected:
  explicit RoadWeatherCondition(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RoadWeatherCondition_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
  bool has_depth_and_accuracy() const;
  void clear_depth_and_accuracy();
  static const int kDepthAndAccuracyFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& _internal_depth_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& depth_and_accuracy() const;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* release_depth_and_accuracy();
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* mutable_depth_and_accuracy();
  void set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy);
  void unsafe_arena_set_allocated_depth_and_accuracy(
      ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy);
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* unsafe_arena_release_depth_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficEventsCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory) */ {
 public:
  TrafficEventsCategory();
  virtual ~TrafficEventsCategory();

  TrafficEventsCategory(const TrafficEventsCategory& from);

  inline TrafficEventsCategory& operator=(const TrafficEventsCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficEventsCategory(TrafficEventsCategory&& from) noexcept
    : TrafficEventsCategory() {
    *this = ::std::move(from);
  }

  inline TrafficEventsCategory& operator=(TrafficEventsCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficEventsCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficEventsCategory* internal_default_instance() {
    return reinterpret_cast<const TrafficEventsCategory*>(
               &_TrafficEventsCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(TrafficEventsCategory* other);
  void Swap(TrafficEventsCategory* other);
  friend void swap(TrafficEventsCategory& a, TrafficEventsCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficEventsCategory* New() const final {
    return CreateMaybeMessage<TrafficEventsCategory>(NULL);
  }

  TrafficEventsCategory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficEventsCategory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficEventsCategory& from);
  void MergeFrom(const TrafficEventsCategory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficEventsCategory* other);
  protected:
  explicit TrafficEventsCategory(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
  int hazard_size() const;
  void clear_hazard();
  static const int kHazardFieldNumber = 2;
  ::sensoris::protobuf::categories::trafficevents::Hazard* mutable_hazard(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >*
      mutable_hazard();
  const ::sensoris::protobuf::categories::trafficevents::Hazard& hazard(int index) const;
  ::sensoris::protobuf::categories::trafficevents::Hazard* add_hazard();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >&
      hazard() const;

  // repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
  int dangerous_slow_down_size() const;
  void clear_dangerous_slow_down();
  static const int kDangerousSlowDownFieldNumber = 3;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* mutable_dangerous_slow_down(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >*
      mutable_dangerous_slow_down();
  const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& dangerous_slow_down(int index) const;
  ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* add_dangerous_slow_down();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >&
      dangerous_slow_down() const;

  // repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
  int traffic_condition_size() const;
  void clear_traffic_condition();
  static const int kTrafficConditionFieldNumber = 4;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* mutable_traffic_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >*
      mutable_traffic_condition();
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& traffic_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition* add_traffic_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >&
      traffic_condition() const;

  // repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
  int roadworks_size() const;
  void clear_roadworks();
  static const int kRoadworksFieldNumber = 5;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* mutable_roadworks(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >*
      mutable_roadworks();
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks& roadworks(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWorks* add_roadworks();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >&
      roadworks() const;

  // repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
  int road_weather_condition_size() const;
  void clear_road_weather_condition();
  static const int kRoadWeatherConditionFieldNumber = 6;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* mutable_road_weather_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >*
      mutable_road_weather_condition();
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& road_weather_condition(int index) const;
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* add_road_weather_condition();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >&
      road_weather_condition() const;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard > hazard_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown > dangerous_slow_down_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition > traffic_condition_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks > roadworks_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition > road_weather_condition_;
  ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hazard_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.Type type = 1;
inline void Hazard_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type Hazard_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type >(type_);
}
inline void Hazard_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool Hazard_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& Hazard_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* Hazard_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
  return confidence_;
}
inline void Hazard_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// Hazard

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool Hazard::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& Hazard::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* Hazard::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
  return envelope_;
}
inline void Hazard::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool Hazard::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& Hazard::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* Hazard::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
  return detection_status_;
}
inline void Hazard::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.TypeAndConfidence type_and_confidence = 3;
inline bool Hazard::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void Hazard::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence& Hazard::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficevents::_Hazard_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* Hazard::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
  return type_and_confidence_;
}
inline void Hazard::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.Hazard.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficevents.Hazard.Direction direction = 4;
inline void Hazard::clear_direction() {
  direction_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard_Direction Hazard::direction() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.Hazard.direction)
  return static_cast< ::sensoris::protobuf::categories::trafficevents::Hazard_Direction >(direction_);
}
inline void Hazard::set_direction(::sensoris::protobuf::categories::trafficevents::Hazard_Direction value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.Hazard.direction)
}

// -------------------------------------------------------------------

// DangerousSlowDown

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool DangerousSlowDown::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& DangerousSlowDown::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* DangerousSlowDown::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
  return envelope_;
}
inline void DangerousSlowDown::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy speed_reduction_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool DangerousSlowDown::has_speed_reduction_and_accuracy() const {
  return this != internal_default_instance() && speed_reduction_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::_internal_speed_reduction_and_accuracy() const {
  return *speed_reduction_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& DangerousSlowDown::speed_reduction_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = speed_reduction_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::release_speed_reduction_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = speed_reduction_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  speed_reduction_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::unsafe_arena_release_speed_reduction_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = speed_reduction_and_accuracy_;
  speed_reduction_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* DangerousSlowDown::mutable_speed_reduction_and_accuracy() {
  
  if (speed_reduction_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    speed_reduction_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
  return speed_reduction_and_accuracy_;
}
inline void DangerousSlowDown::set_allocated_speed_reduction_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* speed_reduction_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(speed_reduction_and_accuracy_);
  }
  if (speed_reduction_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(speed_reduction_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      speed_reduction_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, speed_reduction_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  speed_reduction_and_accuracy_ = speed_reduction_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.speed_reduction_and_accuracy)
}

// .google.protobuf.Int64Value time_period = 3 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool DangerousSlowDown::has_time_period() const {
  return this != internal_default_instance() && time_period_ != NULL;
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::_internal_time_period() const {
  return *time_period_;
}
inline const ::google::protobuf::Int64Value& DangerousSlowDown::time_period() const {
  const ::google::protobuf::Int64Value* p = time_period_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::Int64Value*>(
      &::google::protobuf::_Int64Value_default_instance_);
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::release_time_period() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  
  ::google::protobuf::Int64Value* temp = time_period_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  time_period_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::unsafe_arena_release_time_period() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  
  ::google::protobuf::Int64Value* temp = time_period_;
  time_period_ = NULL;
  return temp;
}
inline ::google::protobuf::Int64Value* DangerousSlowDown::mutable_time_period() {
  
  if (time_period_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::Int64Value>(GetArenaNoVirtual());
    time_period_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
  return time_period_;
}
inline void DangerousSlowDown::set_allocated_time_period(::google::protobuf::Int64Value* time_period) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(time_period_);
  }
  if (time_period) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(time_period)->GetArena();
    if (message_arena != submessage_arena) {
      time_period = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_period, submessage_arena);
    }
    
  } else {
    
  }
  time_period_ = time_period;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.DangerousSlowDown.time_period)
}

// -------------------------------------------------------------------

// TrafficCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.Type type = 1;
inline void TrafficCondition_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type TrafficCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type >(type_);
}
inline void TrafficCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficCondition_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficCondition_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficCondition_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
  return confidence_;
}
inline void TrafficCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficCondition::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficCondition::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficCondition::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
  return envelope_;
}
inline void TrafficCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficCondition::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficCondition::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficCondition::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
  return detection_status_;
}
inline void TrafficCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.TrafficCondition.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficCondition::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void TrafficCondition::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence& TrafficCondition::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficevents::_TrafficCondition_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* TrafficCondition::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
  return type_and_confidence_;
}
inline void TrafficCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficCondition.type_and_confidence)
}

// -------------------------------------------------------------------

// RoadWorks_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.Type type = 1;
inline void RoadWorks_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type RoadWorks_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type >(type_);
}
inline void RoadWorks_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWorks_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWorks_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWorks_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
  return confidence_;
}
inline void RoadWorks_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWorks

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWorks::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWorks::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWorks::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
  return envelope_;
}
inline void RoadWorks::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWorks::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWorks::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWorks::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
  return detection_status_;
}
inline void RoadWorks::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWorks.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWorks::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void RoadWorks::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence& RoadWorks::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficevents::_RoadWorks_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* RoadWorks::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
  return type_and_confidence_;
}
inline void RoadWorks::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.type_and_confidence)
}

// .sensoris.protobuf.types.base.CountAndConfidence lanes_closed_and_confidence = 5;
inline bool RoadWorks::has_lanes_closed_and_confidence() const {
  return this != internal_default_instance() && lanes_closed_and_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::_internal_lanes_closed_and_confidence() const {
  return *lanes_closed_and_confidence_;
}
inline const ::sensoris::protobuf::types::base::CountAndConfidence& RoadWorks::lanes_closed_and_confidence() const {
  const ::sensoris::protobuf::types::base::CountAndConfidence* p = lanes_closed_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CountAndConfidence*>(
      &::sensoris::protobuf::types::base::_CountAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::release_lanes_closed_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = lanes_closed_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  lanes_closed_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::unsafe_arena_release_lanes_closed_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  
  ::sensoris::protobuf::types::base::CountAndConfidence* temp = lanes_closed_and_confidence_;
  lanes_closed_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CountAndConfidence* RoadWorks::mutable_lanes_closed_and_confidence() {
  
  if (lanes_closed_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CountAndConfidence>(GetArenaNoVirtual());
    lanes_closed_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
  return lanes_closed_and_confidence_;
}
inline void RoadWorks::set_allocated_lanes_closed_and_confidence(::sensoris::protobuf::types::base::CountAndConfidence* lanes_closed_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(lanes_closed_and_confidence_);
  }
  if (lanes_closed_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(lanes_closed_and_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      lanes_closed_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lanes_closed_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  lanes_closed_and_confidence_ = lanes_closed_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWorks.lanes_closed_and_confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition_TypeAndConfidence

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.Type type = 1;
inline void RoadWeatherCondition_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type RoadWeatherCondition_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type >(type_);
}
inline void RoadWeatherCondition_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool RoadWeatherCondition_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& RoadWeatherCondition_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* RoadWeatherCondition_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
  return confidence_;
}
inline void RoadWeatherCondition_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// RoadWeatherCondition

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool RoadWeatherCondition::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& RoadWeatherCondition::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* RoadWeatherCondition::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
  return envelope_;
}
inline void RoadWeatherCondition::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.envelope)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool RoadWeatherCondition::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& RoadWeatherCondition::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* RoadWeatherCondition::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
  return detection_status_;
}
inline void RoadWeatherCondition::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.detection_status)
}

// .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.TypeAndConfidence type_and_confidence = 3;
inline bool RoadWeatherCondition::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void RoadWeatherCondition::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence& RoadWeatherCondition::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficevents::_RoadWeatherCondition_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* RoadWeatherCondition::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
  return type_and_confidence_;
}
inline void RoadWeatherCondition::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.type_and_confidence)
}

// .sensoris.protobuf.types.base.Int64ValueAndAccuracy depth_and_accuracy = 4 [(.sensoris.protobuf.types.base.exponent) = 0];
inline bool RoadWeatherCondition::has_depth_and_accuracy() const {
  return this != internal_default_instance() && depth_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::_internal_depth_and_accuracy() const {
  return *depth_and_accuracy_;
}
inline const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy& RoadWeatherCondition::depth_and_accuracy() const {
  const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* p = depth_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64ValueAndAccuracy*>(
      &::sensoris::protobuf::types::base::_Int64ValueAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::release_depth_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = depth_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  depth_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::unsafe_arena_release_depth_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  
  ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* temp = depth_and_accuracy_;
  depth_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64ValueAndAccuracy* RoadWeatherCondition::mutable_depth_and_accuracy() {
  
  if (depth_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64ValueAndAccuracy>(GetArenaNoVirtual());
    depth_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
  return depth_and_accuracy_;
}
inline void RoadWeatherCondition::set_allocated_depth_and_accuracy(::sensoris::protobuf::types::base::Int64ValueAndAccuracy* depth_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(depth_and_accuracy_);
  }
  if (depth_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(depth_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      depth_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, depth_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  depth_and_accuracy_ = depth_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.RoadWeatherCondition.depth_and_accuracy)
}

// -------------------------------------------------------------------

// TrafficEventsCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficEventsCategory::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficEventsCategory::envelope() const {
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      &::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficEventsCategory::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
  return envelope_;
}
inline void TrafficEventsCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficevents.Hazard hazard = 2;
inline int TrafficEventsCategory::hazard_size() const {
  return hazard_.size();
}
inline void TrafficEventsCategory::clear_hazard() {
  hazard_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::mutable_hazard(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return hazard_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >*
TrafficEventsCategory::mutable_hazard() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return &hazard_;
}
inline const ::sensoris::protobuf::categories::trafficevents::Hazard& TrafficEventsCategory::hazard(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return hazard_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::Hazard* TrafficEventsCategory::add_hazard() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return hazard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::Hazard >&
TrafficEventsCategory::hazard() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.hazard)
  return hazard_;
}

// repeated .sensoris.protobuf.categories.trafficevents.DangerousSlowDown dangerous_slow_down = 3;
inline int TrafficEventsCategory::dangerous_slow_down_size() const {
  return dangerous_slow_down_.size();
}
inline void TrafficEventsCategory::clear_dangerous_slow_down() {
  dangerous_slow_down_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::mutable_dangerous_slow_down(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return dangerous_slow_down_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >*
TrafficEventsCategory::mutable_dangerous_slow_down() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return &dangerous_slow_down_;
}
inline const ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown& TrafficEventsCategory::dangerous_slow_down(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return dangerous_slow_down_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown* TrafficEventsCategory::add_dangerous_slow_down() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return dangerous_slow_down_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::DangerousSlowDown >&
TrafficEventsCategory::dangerous_slow_down() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.dangerous_slow_down)
  return dangerous_slow_down_;
}

// repeated .sensoris.protobuf.categories.trafficevents.TrafficCondition traffic_condition = 4;
inline int TrafficEventsCategory::traffic_condition_size() const {
  return traffic_condition_.size();
}
inline void TrafficEventsCategory::clear_traffic_condition() {
  traffic_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::mutable_traffic_condition(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return traffic_condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >*
TrafficEventsCategory::mutable_traffic_condition() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return &traffic_condition_;
}
inline const ::sensoris::protobuf::categories::trafficevents::TrafficCondition& TrafficEventsCategory::traffic_condition(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return traffic_condition_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::TrafficCondition* TrafficEventsCategory::add_traffic_condition() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return traffic_condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::TrafficCondition >&
TrafficEventsCategory::traffic_condition() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.traffic_condition)
  return traffic_condition_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWorks roadworks = 5;
inline int TrafficEventsCategory::roadworks_size() const {
  return roadworks_.size();
}
inline void TrafficEventsCategory::clear_roadworks() {
  roadworks_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::mutable_roadworks(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return roadworks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >*
TrafficEventsCategory::mutable_roadworks() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return &roadworks_;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWorks& TrafficEventsCategory::roadworks(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return roadworks_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWorks* TrafficEventsCategory::add_roadworks() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return roadworks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWorks >&
TrafficEventsCategory::roadworks() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.roadworks)
  return roadworks_;
}

// repeated .sensoris.protobuf.categories.trafficevents.RoadWeatherCondition road_weather_condition = 6;
inline int TrafficEventsCategory::road_weather_condition_size() const {
  return road_weather_condition_.size();
}
inline void TrafficEventsCategory::clear_road_weather_condition() {
  road_weather_condition_.Clear();
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::mutable_road_weather_condition(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return road_weather_condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >*
TrafficEventsCategory::mutable_road_weather_condition() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return &road_weather_condition_;
}
inline const ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition& TrafficEventsCategory::road_weather_condition(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return road_weather_condition_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition* TrafficEventsCategory::add_road_weather_condition() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return road_weather_condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition >&
TrafficEventsCategory::road_weather_condition() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficevents.TrafficEventsCategory.road_weather_condition)
  return road_weather_condition_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trafficevents
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficevents::Hazard_Direction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficevents::Hazard_Direction>() {
  return ::sensoris::protobuf::categories::trafficevents::Hazard_Direction_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::TrafficCondition_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWorks_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficevents::RoadWeatherCondition_TypeAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fevents_2eproto

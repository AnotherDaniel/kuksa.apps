// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/localization.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto 

namespace protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace localization {
class LocalizationCategory;
class LocalizationCategoryDefaultTypeInternal;
extern LocalizationCategoryDefaultTypeInternal _LocalizationCategory_default_instance_;
class VehicleAcceleration;
class VehicleAccelerationDefaultTypeInternal;
extern VehicleAccelerationDefaultTypeInternal _VehicleAcceleration_default_instance_;
class VehicleOdometry;
class VehicleOdometryDefaultTypeInternal;
extern VehicleOdometryDefaultTypeInternal _VehicleOdometry_default_instance_;
class VehiclePositionAndOrientation;
class VehiclePositionAndOrientationDefaultTypeInternal;
extern VehiclePositionAndOrientationDefaultTypeInternal _VehiclePositionAndOrientation_default_instance_;
class VehiclePositionAndOrientation_NavigationSatelliteSystemStatus;
class VehiclePositionAndOrientation_NavigationSatelliteSystemStatusDefaultTypeInternal;
extern VehiclePositionAndOrientation_NavigationSatelliteSystemStatusDefaultTypeInternal _VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_default_instance_;
class VehicleRotationRate;
class VehicleRotationRateDefaultTypeInternal;
extern VehicleRotationRateDefaultTypeInternal _VehicleRotationRate_default_instance_;
class VehicleSpeed;
class VehicleSpeedDefaultTypeInternal;
extern VehicleSpeedDefaultTypeInternal _VehicleSpeed_default_instance_;
}  // namespace localization
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::categories::localization::LocalizationCategory* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::LocalizationCategory>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehicleAcceleration* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehicleAcceleration>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehicleOdometry* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehicleOdometry>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehicleRotationRate* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehicleRotationRate>(Arena*);
template<> ::sensoris::protobuf::categories::localization::VehicleSpeed* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehicleSpeed>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace categories {
namespace localization {

enum VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType {
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_UNKNOWN_FIX_TYPE = 0,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_NONE = 1,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D = 2,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_SATELLITE_BASED_AUGMENTATION = 3,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_GROUND_BASED_AUGMENTATION = 4,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION = 5,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D = 6,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_SATELLITE_BASED_AUGMENTATION = 7,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_GROUND_BASED_AUGMENTATION = 8,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION = 9,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_IsValid(int value);
const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_MIN = VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_UNKNOWN_FIX_TYPE;
const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_MAX = VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION;
const int VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_ARRAYSIZE = VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_descriptor();
inline const ::std::string& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_Name(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_descriptor(), value);
}
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_Parse(
    const ::std::string& name, VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType>(
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_descriptor(), name, value);
}
// ===================================================================

class VehiclePositionAndOrientation_NavigationSatelliteSystemStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus) */ {
 public:
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus();
  virtual ~VehiclePositionAndOrientation_NavigationSatelliteSystemStatus();

  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus(const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& from);

  inline VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& operator=(const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus&& from) noexcept
    : VehiclePositionAndOrientation_NavigationSatelliteSystemStatus() {
    *this = ::std::move(from);
  }

  inline VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& operator=(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* internal_default_instance() {
    return reinterpret_cast<const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus*>(
               &_VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* other);
  void Swap(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* other);
  friend void swap(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& a, VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* New() const final {
    return CreateMaybeMessage<VehiclePositionAndOrientation_NavigationSatelliteSystemStatus>(NULL);
  }

  VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehiclePositionAndOrientation_NavigationSatelliteSystemStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& from);
  void MergeFrom(const VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* other);
  protected:
  explicit VehiclePositionAndOrientation_NavigationSatelliteSystemStatus(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType FixType;
  static const FixType UNKNOWN_FIX_TYPE =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_UNKNOWN_FIX_TYPE;
  static const FixType NONE =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_NONE;
  static const FixType TWO_D =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D;
  static const FixType TWO_D_SATELLITE_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_SATELLITE_BASED_AUGMENTATION;
  static const FixType TWO_D_GROUND_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_GROUND_BASED_AUGMENTATION;
  static const FixType TWO_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_TWO_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION;
  static const FixType THREE_D =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D;
  static const FixType THREE_D_SATELLITE_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_SATELLITE_BASED_AUGMENTATION;
  static const FixType THREE_D_GROUND_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_GROUND_BASED_AUGMENTATION;
  static const FixType THREE_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_THREE_D_SATELLITE_AND_GROUND_BASED_AUGMENTATION;
  static inline bool FixType_IsValid(int value) {
    return VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_IsValid(value);
  }
  static const FixType FixType_MIN =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_MIN;
  static const FixType FixType_MAX =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_MAX;
  static const int FixType_ARRAYSIZE =
    VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_FixType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FixType_descriptor() {
    return VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_descriptor();
  }
  static inline const ::std::string& FixType_Name(FixType value) {
    return VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_Name(value);
  }
  static inline bool FixType_Parse(const ::std::string& name,
      FixType* value) {
    return VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Int64Value count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_count() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& count() const;
  ::sensoris::protobuf::types::base::Int64Value* release_count();
  ::sensoris::protobuf::types::base::Int64Value* mutable_count();
  void set_allocated_count(::sensoris::protobuf::types::base::Int64Value* count);
  void unsafe_arena_set_allocated_count(
      ::sensoris::protobuf::types::base::Int64Value* count);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_count();

  // .sensoris.protobuf.types.base.Int64Value hdop = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_hdop() const;
  void clear_hdop();
  static const int kHdopFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_hdop() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& hdop() const;
  ::sensoris::protobuf::types::base::Int64Value* release_hdop();
  ::sensoris::protobuf::types::base::Int64Value* mutable_hdop();
  void set_allocated_hdop(::sensoris::protobuf::types::base::Int64Value* hdop);
  void unsafe_arena_set_allocated_hdop(
      ::sensoris::protobuf::types::base::Int64Value* hdop);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_hdop();

  // .sensoris.protobuf.types.base.Int64Value vdop = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_vdop() const;
  void clear_vdop();
  static const int kVdopFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_vdop() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& vdop() const;
  ::sensoris::protobuf::types::base::Int64Value* release_vdop();
  ::sensoris::protobuf::types::base::Int64Value* mutable_vdop();
  void set_allocated_vdop(::sensoris::protobuf::types::base::Int64Value* vdop);
  void unsafe_arena_set_allocated_vdop(
      ::sensoris::protobuf::types::base::Int64Value* vdop);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_vdop();

  // .sensoris.protobuf.types.base.Int64Value pdop = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_pdop() const;
  void clear_pdop();
  static const int kPdopFieldNumber = 5;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_pdop() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& pdop() const;
  ::sensoris::protobuf::types::base::Int64Value* release_pdop();
  ::sensoris::protobuf::types::base::Int64Value* mutable_pdop();
  void set_allocated_pdop(::sensoris::protobuf::types::base::Int64Value* pdop);
  void unsafe_arena_set_allocated_pdop(
      ::sensoris::protobuf::types::base::Int64Value* pdop);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_pdop();

  // .sensoris.protobuf.types.base.Int64Value tdop = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
  bool has_tdop() const;
  void clear_tdop();
  static const int kTdopFieldNumber = 6;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_tdop() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& tdop() const;
  ::sensoris::protobuf::types::base::Int64Value* release_tdop();
  ::sensoris::protobuf::types::base::Int64Value* mutable_tdop();
  void set_allocated_tdop(::sensoris::protobuf::types::base::Int64Value* tdop);
  void unsafe_arena_set_allocated_tdop(
      ::sensoris::protobuf::types::base::Int64Value* tdop);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_tdop();

  // .sensoris.protobuf.types.base.Int64Value snr = 8 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_snr() const;
  void clear_snr();
  static const int kSnrFieldNumber = 8;
  private:
  const ::sensoris::protobuf::types::base::Int64Value& _internal_snr() const;
  public:
  const ::sensoris::protobuf::types::base::Int64Value& snr() const;
  ::sensoris::protobuf::types::base::Int64Value* release_snr();
  ::sensoris::protobuf::types::base::Int64Value* mutable_snr();
  void set_allocated_snr(::sensoris::protobuf::types::base::Int64Value* snr);
  void unsafe_arena_set_allocated_snr(
      ::sensoris::protobuf::types::base::Int64Value* snr);
  ::sensoris::protobuf::types::base::Int64Value* unsafe_arena_release_snr();

  // .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.FixType fix_type = 1;
  void clear_fix_type();
  static const int kFixTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType fix_type() const;
  void set_fix_type(::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Int64Value* count_;
  ::sensoris::protobuf::types::base::Int64Value* hdop_;
  ::sensoris::protobuf::types::base::Int64Value* vdop_;
  ::sensoris::protobuf::types::base::Int64Value* pdop_;
  ::sensoris::protobuf::types::base::Int64Value* tdop_;
  ::sensoris::protobuf::types::base::Int64Value* snr_;
  int fix_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehiclePositionAndOrientation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation) */ {
 public:
  VehiclePositionAndOrientation();
  virtual ~VehiclePositionAndOrientation();

  VehiclePositionAndOrientation(const VehiclePositionAndOrientation& from);

  inline VehiclePositionAndOrientation& operator=(const VehiclePositionAndOrientation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehiclePositionAndOrientation(VehiclePositionAndOrientation&& from) noexcept
    : VehiclePositionAndOrientation() {
    *this = ::std::move(from);
  }

  inline VehiclePositionAndOrientation& operator=(VehiclePositionAndOrientation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePositionAndOrientation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehiclePositionAndOrientation* internal_default_instance() {
    return reinterpret_cast<const VehiclePositionAndOrientation*>(
               &_VehiclePositionAndOrientation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(VehiclePositionAndOrientation* other);
  void Swap(VehiclePositionAndOrientation* other);
  friend void swap(VehiclePositionAndOrientation& a, VehiclePositionAndOrientation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehiclePositionAndOrientation* New() const final {
    return CreateMaybeMessage<VehiclePositionAndOrientation>(NULL);
  }

  VehiclePositionAndOrientation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehiclePositionAndOrientation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehiclePositionAndOrientation& from);
  void MergeFrom(const VehiclePositionAndOrientation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePositionAndOrientation* other);
  protected:
  explicit VehiclePositionAndOrientation(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VehiclePositionAndOrientation_NavigationSatelliteSystemStatus NavigationSatelliteSystemStatus;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
  bool has_position_and_accuracy() const;
  void clear_position_and_accuracy();
  static const int kPositionAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_position_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& position_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_position_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_position_and_accuracy();
  void set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  void unsafe_arena_set_allocated_position_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_position_and_accuracy();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 3;
  bool has_orientation_and_accuracy() const;
  void clear_orientation_and_accuracy();
  static const int kOrientationAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_orientation_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& orientation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* release_orientation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* mutable_orientation_and_accuracy();
  void set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy);
  void unsafe_arena_set_allocated_orientation_and_accuracy(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* unsafe_arena_release_orientation_and_accuracy();

  // .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus navigation_satellite_system_status = 4;
  bool has_navigation_satellite_system_status() const;
  void clear_navigation_satellite_system_status();
  static const int kNavigationSatelliteSystemStatusFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& _internal_navigation_satellite_system_status() const;
  public:
  const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& navigation_satellite_system_status() const;
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* release_navigation_satellite_system_status();
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* mutable_navigation_satellite_system_status();
  void set_allocated_navigation_satellite_system_status(::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* navigation_satellite_system_status);
  void unsafe_arena_set_allocated_navigation_satellite_system_status(
      ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* navigation_satellite_system_status);
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* unsafe_arena_release_navigation_satellite_system_status();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy_;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy_;
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* navigation_satellite_system_status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleOdometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehicleOdometry) */ {
 public:
  VehicleOdometry();
  virtual ~VehicleOdometry();

  VehicleOdometry(const VehicleOdometry& from);

  inline VehicleOdometry& operator=(const VehicleOdometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleOdometry(VehicleOdometry&& from) noexcept
    : VehicleOdometry() {
    *this = ::std::move(from);
  }

  inline VehicleOdometry& operator=(VehicleOdometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleOdometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleOdometry* internal_default_instance() {
    return reinterpret_cast<const VehicleOdometry*>(
               &_VehicleOdometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(VehicleOdometry* other);
  void Swap(VehicleOdometry* other);
  friend void swap(VehicleOdometry& a, VehicleOdometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleOdometry* New() const final {
    return CreateMaybeMessage<VehicleOdometry>(NULL);
  }

  VehicleOdometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleOdometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleOdometry& from);
  void MergeFrom(const VehicleOdometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleOdometry* other);
  protected:
  explicit VehicleOdometry(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Timestamp end_timestamp = 2;
  bool has_end_timestamp() const;
  void clear_end_timestamp();
  static const int kEndTimestampFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Timestamp& _internal_end_timestamp() const;
  public:
  const ::sensoris::protobuf::types::base::Timestamp& end_timestamp() const;
  ::sensoris::protobuf::types::base::Timestamp* release_end_timestamp();
  ::sensoris::protobuf::types::base::Timestamp* mutable_end_timestamp();
  void set_allocated_end_timestamp(::sensoris::protobuf::types::base::Timestamp* end_timestamp);
  void unsafe_arena_set_allocated_end_timestamp(
      ::sensoris::protobuf::types::base::Timestamp* end_timestamp);
  ::sensoris::protobuf::types::base::Timestamp* unsafe_arena_release_end_timestamp();

  // .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 3;
  bool has_translation_and_accuracy() const;
  void clear_translation_and_accuracy();
  static const int kTranslationAndAccuracyFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& _internal_translation_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& translation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* release_translation_and_accuracy();
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* mutable_translation_and_accuracy();
  void set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* translation_and_accuracy);
  void unsafe_arena_set_allocated_translation_and_accuracy(
      ::sensoris::protobuf::types::spatial::PositionAndAccuracy* translation_and_accuracy);
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* unsafe_arena_release_translation_and_accuracy();

  // .sensoris.protobuf.types.spatial.RotationAndAccuracy rotation_and_accuracy = 4;
  bool has_rotation_and_accuracy() const;
  void clear_rotation_and_accuracy();
  static const int kRotationAndAccuracyFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& _internal_rotation_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& rotation_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* release_rotation_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* mutable_rotation_and_accuracy();
  void set_allocated_rotation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* rotation_and_accuracy);
  void unsafe_arena_set_allocated_rotation_and_accuracy(
      ::sensoris::protobuf::types::spatial::RotationAndAccuracy* rotation_and_accuracy);
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* unsafe_arena_release_rotation_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehicleOdometry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Timestamp* end_timestamp_;
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* translation_and_accuracy_;
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* rotation_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehicleSpeed) */ {
 public:
  VehicleSpeed();
  virtual ~VehicleSpeed();

  VehicleSpeed(const VehicleSpeed& from);

  inline VehicleSpeed& operator=(const VehicleSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleSpeed(VehicleSpeed&& from) noexcept
    : VehicleSpeed() {
    *this = ::std::move(from);
  }

  inline VehicleSpeed& operator=(VehicleSpeed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleSpeed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleSpeed* internal_default_instance() {
    return reinterpret_cast<const VehicleSpeed*>(
               &_VehicleSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(VehicleSpeed* other);
  void Swap(VehicleSpeed* other);
  friend void swap(VehicleSpeed& a, VehicleSpeed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleSpeed* New() const final {
    return CreateMaybeMessage<VehicleSpeed>(NULL);
  }

  VehicleSpeed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleSpeed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleSpeed& from);
  void MergeFrom(const VehicleSpeed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleSpeed* other);
  protected:
  explicit VehicleSpeed(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy value_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_value_and_accuracy() const;
  void clear_value_and_accuracy();
  static const int kValueAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_value_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& value_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_value_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_value_and_accuracy();
  void set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy);
  void unsafe_arena_set_allocated_value_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_value_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehicleSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleAcceleration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehicleAcceleration) */ {
 public:
  VehicleAcceleration();
  virtual ~VehicleAcceleration();

  VehicleAcceleration(const VehicleAcceleration& from);

  inline VehicleAcceleration& operator=(const VehicleAcceleration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleAcceleration(VehicleAcceleration&& from) noexcept
    : VehicleAcceleration() {
    *this = ::std::move(from);
  }

  inline VehicleAcceleration& operator=(VehicleAcceleration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleAcceleration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleAcceleration* internal_default_instance() {
    return reinterpret_cast<const VehicleAcceleration*>(
               &_VehicleAcceleration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(VehicleAcceleration* other);
  void Swap(VehicleAcceleration* other);
  friend void swap(VehicleAcceleration& a, VehicleAcceleration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleAcceleration* New() const final {
    return CreateMaybeMessage<VehicleAcceleration>(NULL);
  }

  VehicleAcceleration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleAcceleration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleAcceleration& from);
  void MergeFrom(const VehicleAcceleration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleAcceleration* other);
  protected:
  explicit VehicleAcceleration(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy value_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
  bool has_value_and_accuracy() const;
  void clear_value_and_accuracy();
  static const int kValueAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& _internal_value_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& value_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* release_value_and_accuracy();
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* mutable_value_and_accuracy();
  void set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy);
  void unsafe_arena_set_allocated_value_and_accuracy(
      ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy);
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* unsafe_arena_release_value_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehicleAcceleration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehicleRotationRate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.VehicleRotationRate) */ {
 public:
  VehicleRotationRate();
  virtual ~VehicleRotationRate();

  VehicleRotationRate(const VehicleRotationRate& from);

  inline VehicleRotationRate& operator=(const VehicleRotationRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehicleRotationRate(VehicleRotationRate&& from) noexcept
    : VehicleRotationRate() {
    *this = ::std::move(from);
  }

  inline VehicleRotationRate& operator=(VehicleRotationRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleRotationRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehicleRotationRate* internal_default_instance() {
    return reinterpret_cast<const VehicleRotationRate*>(
               &_VehicleRotationRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(VehicleRotationRate* other);
  void Swap(VehicleRotationRate* other);
  friend void swap(VehicleRotationRate& a, VehicleRotationRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehicleRotationRate* New() const final {
    return CreateMaybeMessage<VehicleRotationRate>(NULL);
  }

  VehicleRotationRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehicleRotationRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehicleRotationRate& from);
  void MergeFrom(const VehicleRotationRate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehicleRotationRate* other);
  protected:
  explicit VehicleRotationRate(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.spatial.RotationRateAndAccuracy value_and_accuracy = 2;
  bool has_value_and_accuracy() const;
  void clear_value_and_accuracy();
  static const int kValueAndAccuracyFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy& _internal_value_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy& value_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* release_value_and_accuracy();
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* mutable_value_and_accuracy();
  void set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* value_and_accuracy);
  void unsafe_arena_set_allocated_value_and_accuracy(
      ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* value_and_accuracy);
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* unsafe_arena_release_value_and_accuracy();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.VehicleRotationRate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* value_and_accuracy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocalizationCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.localization.LocalizationCategory) */ {
 public:
  LocalizationCategory();
  virtual ~LocalizationCategory();

  LocalizationCategory(const LocalizationCategory& from);

  inline LocalizationCategory& operator=(const LocalizationCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocalizationCategory(LocalizationCategory&& from) noexcept
    : LocalizationCategory() {
    *this = ::std::move(from);
  }

  inline LocalizationCategory& operator=(LocalizationCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalizationCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocalizationCategory* internal_default_instance() {
    return reinterpret_cast<const LocalizationCategory*>(
               &_LocalizationCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(LocalizationCategory* other);
  void Swap(LocalizationCategory* other);
  friend void swap(LocalizationCategory& a, LocalizationCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocalizationCategory* New() const final {
    return CreateMaybeMessage<LocalizationCategory>(NULL);
  }

  LocalizationCategory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocalizationCategory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocalizationCategory& from);
  void MergeFrom(const LocalizationCategory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalizationCategory* other);
  protected:
  explicit LocalizationCategory(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation vehicle_position_and_orientation = 2;
  int vehicle_position_and_orientation_size() const;
  void clear_vehicle_position_and_orientation();
  static const int kVehiclePositionAndOrientationFieldNumber = 2;
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation* mutable_vehicle_position_and_orientation(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation >*
      mutable_vehicle_position_and_orientation();
  const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation& vehicle_position_and_orientation(int index) const;
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation* add_vehicle_position_and_orientation();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation >&
      vehicle_position_and_orientation() const;

  // repeated .sensoris.protobuf.categories.localization.VehicleOdometry vehicle_odometry = 3;
  int vehicle_odometry_size() const;
  void clear_vehicle_odometry();
  static const int kVehicleOdometryFieldNumber = 3;
  ::sensoris::protobuf::categories::localization::VehicleOdometry* mutable_vehicle_odometry(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleOdometry >*
      mutable_vehicle_odometry();
  const ::sensoris::protobuf::categories::localization::VehicleOdometry& vehicle_odometry(int index) const;
  ::sensoris::protobuf::categories::localization::VehicleOdometry* add_vehicle_odometry();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleOdometry >&
      vehicle_odometry() const;

  // repeated .sensoris.protobuf.categories.localization.VehicleSpeed vehicle_speed = 4;
  int vehicle_speed_size() const;
  void clear_vehicle_speed();
  static const int kVehicleSpeedFieldNumber = 4;
  ::sensoris::protobuf::categories::localization::VehicleSpeed* mutable_vehicle_speed(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleSpeed >*
      mutable_vehicle_speed();
  const ::sensoris::protobuf::categories::localization::VehicleSpeed& vehicle_speed(int index) const;
  ::sensoris::protobuf::categories::localization::VehicleSpeed* add_vehicle_speed();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleSpeed >&
      vehicle_speed() const;

  // repeated .sensoris.protobuf.categories.localization.VehicleAcceleration vehicle_acceleration = 5;
  int vehicle_acceleration_size() const;
  void clear_vehicle_acceleration();
  static const int kVehicleAccelerationFieldNumber = 5;
  ::sensoris::protobuf::categories::localization::VehicleAcceleration* mutable_vehicle_acceleration(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleAcceleration >*
      mutable_vehicle_acceleration();
  const ::sensoris::protobuf::categories::localization::VehicleAcceleration& vehicle_acceleration(int index) const;
  ::sensoris::protobuf::categories::localization::VehicleAcceleration* add_vehicle_acceleration();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleAcceleration >&
      vehicle_acceleration() const;

  // repeated .sensoris.protobuf.categories.localization.VehicleRotationRate vehicle_rotation_rate = 6;
  int vehicle_rotation_rate_size() const;
  void clear_vehicle_rotation_rate();
  static const int kVehicleRotationRateFieldNumber = 6;
  ::sensoris::protobuf::categories::localization::VehicleRotationRate* mutable_vehicle_rotation_rate(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleRotationRate >*
      mutable_vehicle_rotation_rate();
  const ::sensoris::protobuf::categories::localization::VehicleRotationRate& vehicle_rotation_rate(int index) const;
  ::sensoris::protobuf::categories::localization::VehicleRotationRate* add_vehicle_rotation_rate();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleRotationRate >&
      vehicle_rotation_rate() const;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.localization.LocalizationCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation > vehicle_position_and_orientation_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleOdometry > vehicle_odometry_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleSpeed > vehicle_speed_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleAcceleration > vehicle_acceleration_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleRotationRate > vehicle_rotation_rate_;
  ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VehiclePositionAndOrientation_NavigationSatelliteSystemStatus

// .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.FixType fix_type = 1;
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::clear_fix_type() {
  fix_type_ = 0;
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::fix_type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.fix_type)
  return static_cast< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType >(fix_type_);
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_fix_type(::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType value) {
  
  fix_type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.fix_type)
}

// .sensoris.protobuf.types.base.Int64Value count = 2;
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_count() const {
  return this != internal_default_instance() && count_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_count() const {
  return *count_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::count() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = count_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.count)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_count() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.count)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = count_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  count_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_count() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.count)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = count_;
  count_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_count() {
  
  if (count_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    count_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.count)
  return count_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_count(::sensoris::protobuf::types::base::Int64Value* count) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(count_);
  }
  if (count) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(count)->GetArena();
    if (message_arena != submessage_arena) {
      count = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, count, submessage_arena);
    }
    
  } else {
    
  }
  count_ = count;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.count)
}

// .sensoris.protobuf.types.base.Int64Value hdop = 3 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_hdop() const {
  return this != internal_default_instance() && hdop_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_hdop() const {
  return *hdop_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::hdop() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = hdop_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.hdop)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_hdop() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.hdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = hdop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  hdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_hdop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.hdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = hdop_;
  hdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_hdop() {
  
  if (hdop_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    hdop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.hdop)
  return hdop_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_hdop(::sensoris::protobuf::types::base::Int64Value* hdop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hdop_);
  }
  if (hdop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(hdop)->GetArena();
    if (message_arena != submessage_arena) {
      hdop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hdop, submessage_arena);
    }
    
  } else {
    
  }
  hdop_ = hdop;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.hdop)
}

// .sensoris.protobuf.types.base.Int64Value vdop = 4 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_vdop() const {
  return this != internal_default_instance() && vdop_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_vdop() const {
  return *vdop_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::vdop() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = vdop_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.vdop)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_vdop() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.vdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = vdop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  vdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_vdop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.vdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = vdop_;
  vdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_vdop() {
  
  if (vdop_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    vdop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.vdop)
  return vdop_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_vdop(::sensoris::protobuf::types::base::Int64Value* vdop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(vdop_);
  }
  if (vdop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(vdop)->GetArena();
    if (message_arena != submessage_arena) {
      vdop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vdop, submessage_arena);
    }
    
  } else {
    
  }
  vdop_ = vdop;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.vdop)
}

// .sensoris.protobuf.types.base.Int64Value pdop = 5 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_pdop() const {
  return this != internal_default_instance() && pdop_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_pdop() const {
  return *pdop_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::pdop() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = pdop_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.pdop)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_pdop() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.pdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pdop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  pdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_pdop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.pdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = pdop_;
  pdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_pdop() {
  
  if (pdop_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    pdop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.pdop)
  return pdop_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_pdop(::sensoris::protobuf::types::base::Int64Value* pdop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(pdop_);
  }
  if (pdop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(pdop)->GetArena();
    if (message_arena != submessage_arena) {
      pdop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pdop, submessage_arena);
    }
    
  } else {
    
  }
  pdop_ = pdop;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.pdop)
}

// .sensoris.protobuf.types.base.Int64Value tdop = 6 [(.sensoris.protobuf.types.base.exponent) = 2];
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_tdop() const {
  return this != internal_default_instance() && tdop_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_tdop() const {
  return *tdop_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::tdop() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = tdop_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.tdop)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_tdop() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.tdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = tdop_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  tdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_tdop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.tdop)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = tdop_;
  tdop_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_tdop() {
  
  if (tdop_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    tdop_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.tdop)
  return tdop_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_tdop(::sensoris::protobuf::types::base::Int64Value* tdop) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(tdop_);
  }
  if (tdop) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(tdop)->GetArena();
    if (message_arena != submessage_arena) {
      tdop = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tdop, submessage_arena);
    }
    
  } else {
    
  }
  tdop_ = tdop;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.tdop)
}

// .sensoris.protobuf.types.base.Int64Value snr = 8 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::has_snr() const {
  return this != internal_default_instance() && snr_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::_internal_snr() const {
  return *snr_;
}
inline const ::sensoris::protobuf::types::base::Int64Value& VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::snr() const {
  const ::sensoris::protobuf::types::base::Int64Value* p = snr_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.snr)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Int64Value*>(
      &::sensoris::protobuf::types::base::_Int64Value_default_instance_);
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::release_snr() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.snr)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = snr_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  snr_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::unsafe_arena_release_snr() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.snr)
  
  ::sensoris::protobuf::types::base::Int64Value* temp = snr_;
  snr_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Int64Value* VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::mutable_snr() {
  
  if (snr_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Int64Value>(GetArenaNoVirtual());
    snr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.snr)
  return snr_;
}
inline void VehiclePositionAndOrientation_NavigationSatelliteSystemStatus::set_allocated_snr(::sensoris::protobuf::types::base::Int64Value* snr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(snr_);
  }
  if (snr) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(snr)->GetArena();
    if (message_arena != submessage_arena) {
      snr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snr, submessage_arena);
    }
    
  } else {
    
  }
  snr_ = snr;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus.snr)
}

// -------------------------------------------------------------------

// VehiclePositionAndOrientation

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VehiclePositionAndOrientation::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehiclePositionAndOrientation::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehiclePositionAndOrientation::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehiclePositionAndOrientation::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehiclePositionAndOrientation::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehiclePositionAndOrientation::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.envelope)
  return envelope_;
}
inline void VehiclePositionAndOrientation::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.envelope)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy position_and_accuracy = 2;
inline bool VehiclePositionAndOrientation::has_position_and_accuracy() const {
  return this != internal_default_instance() && position_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& VehiclePositionAndOrientation::_internal_position_and_accuracy() const {
  return *position_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& VehiclePositionAndOrientation::position_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = position_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.position_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehiclePositionAndOrientation::release_position_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehiclePositionAndOrientation::unsafe_arena_release_position_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.position_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = position_and_accuracy_;
  position_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehiclePositionAndOrientation::mutable_position_and_accuracy() {
  
  if (position_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    position_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.position_and_accuracy)
  return position_and_accuracy_;
}
inline void VehiclePositionAndOrientation::set_allocated_position_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* position_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(position_and_accuracy_);
  }
  if (position_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(position_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      position_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  position_and_accuracy_ = position_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.position_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy orientation_and_accuracy = 3;
inline bool VehiclePositionAndOrientation::has_orientation_and_accuracy() const {
  return this != internal_default_instance() && orientation_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& VehiclePositionAndOrientation::_internal_orientation_and_accuracy() const {
  return *orientation_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& VehiclePositionAndOrientation::orientation_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = orientation_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.orientation_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehiclePositionAndOrientation::release_orientation_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.orientation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = orientation_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  orientation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehiclePositionAndOrientation::unsafe_arena_release_orientation_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.orientation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = orientation_and_accuracy_;
  orientation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehiclePositionAndOrientation::mutable_orientation_and_accuracy() {
  
  if (orientation_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArenaNoVirtual());
    orientation_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.orientation_and_accuracy)
  return orientation_and_accuracy_;
}
inline void VehiclePositionAndOrientation::set_allocated_orientation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* orientation_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(orientation_and_accuracy_);
  }
  if (orientation_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(orientation_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      orientation_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  orientation_and_accuracy_ = orientation_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.orientation_and_accuracy)
}

// .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.NavigationSatelliteSystemStatus navigation_satellite_system_status = 4;
inline bool VehiclePositionAndOrientation::has_navigation_satellite_system_status() const {
  return this != internal_default_instance() && navigation_satellite_system_status_ != NULL;
}
inline void VehiclePositionAndOrientation::clear_navigation_satellite_system_status() {
  if (GetArenaNoVirtual() == NULL && navigation_satellite_system_status_ != NULL) {
    delete navigation_satellite_system_status_;
  }
  navigation_satellite_system_status_ = NULL;
}
inline const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& VehiclePositionAndOrientation::_internal_navigation_satellite_system_status() const {
  return *navigation_satellite_system_status_;
}
inline const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus& VehiclePositionAndOrientation::navigation_satellite_system_status() const {
  const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* p = navigation_satellite_system_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.navigation_satellite_system_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus*>(
      &::sensoris::protobuf::categories::localization::_VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_default_instance_);
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* VehiclePositionAndOrientation::release_navigation_satellite_system_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.navigation_satellite_system_status)
  
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* temp = navigation_satellite_system_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  navigation_satellite_system_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* VehiclePositionAndOrientation::unsafe_arena_release_navigation_satellite_system_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.navigation_satellite_system_status)
  
  ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* temp = navigation_satellite_system_status_;
  navigation_satellite_system_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* VehiclePositionAndOrientation::mutable_navigation_satellite_system_status() {
  
  if (navigation_satellite_system_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus>(GetArenaNoVirtual());
    navigation_satellite_system_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.navigation_satellite_system_status)
  return navigation_satellite_system_status_;
}
inline void VehiclePositionAndOrientation::set_allocated_navigation_satellite_system_status(::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus* navigation_satellite_system_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete navigation_satellite_system_status_;
  }
  if (navigation_satellite_system_status) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(navigation_satellite_system_status);
    if (message_arena != submessage_arena) {
      navigation_satellite_system_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, navigation_satellite_system_status, submessage_arena);
    }
    
  } else {
    
  }
  navigation_satellite_system_status_ = navigation_satellite_system_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehiclePositionAndOrientation.navigation_satellite_system_status)
}

// -------------------------------------------------------------------

// VehicleOdometry

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VehicleOdometry::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleOdometry::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleOdometry::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleOdometry.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleOdometry::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleOdometry.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleOdometry::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleOdometry.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleOdometry::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleOdometry.envelope)
  return envelope_;
}
inline void VehicleOdometry::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleOdometry.envelope)
}

// .sensoris.protobuf.types.base.Timestamp end_timestamp = 2;
inline bool VehicleOdometry::has_end_timestamp() const {
  return this != internal_default_instance() && end_timestamp_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Timestamp& VehicleOdometry::_internal_end_timestamp() const {
  return *end_timestamp_;
}
inline const ::sensoris::protobuf::types::base::Timestamp& VehicleOdometry::end_timestamp() const {
  const ::sensoris::protobuf::types::base::Timestamp* p = end_timestamp_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleOdometry.end_timestamp)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Timestamp*>(
      &::sensoris::protobuf::types::base::_Timestamp_default_instance_);
}
inline ::sensoris::protobuf::types::base::Timestamp* VehicleOdometry::release_end_timestamp() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleOdometry.end_timestamp)
  
  ::sensoris::protobuf::types::base::Timestamp* temp = end_timestamp_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  end_timestamp_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Timestamp* VehicleOdometry::unsafe_arena_release_end_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleOdometry.end_timestamp)
  
  ::sensoris::protobuf::types::base::Timestamp* temp = end_timestamp_;
  end_timestamp_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Timestamp* VehicleOdometry::mutable_end_timestamp() {
  
  if (end_timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Timestamp>(GetArenaNoVirtual());
    end_timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleOdometry.end_timestamp)
  return end_timestamp_;
}
inline void VehicleOdometry::set_allocated_end_timestamp(::sensoris::protobuf::types::base::Timestamp* end_timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(end_timestamp_);
  }
  if (end_timestamp) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(end_timestamp)->GetArena();
    if (message_arena != submessage_arena) {
      end_timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, end_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  end_timestamp_ = end_timestamp;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleOdometry.end_timestamp)
}

// .sensoris.protobuf.types.spatial.PositionAndAccuracy translation_and_accuracy = 3;
inline bool VehicleOdometry::has_translation_and_accuracy() const {
  return this != internal_default_instance() && translation_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& VehicleOdometry::_internal_translation_and_accuracy() const {
  return *translation_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::PositionAndAccuracy& VehicleOdometry::translation_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::PositionAndAccuracy* p = translation_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleOdometry.translation_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::PositionAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_PositionAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehicleOdometry::release_translation_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleOdometry.translation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = translation_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  translation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehicleOdometry::unsafe_arena_release_translation_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleOdometry.translation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::PositionAndAccuracy* temp = translation_and_accuracy_;
  translation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::PositionAndAccuracy* VehicleOdometry::mutable_translation_and_accuracy() {
  
  if (translation_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::PositionAndAccuracy>(GetArenaNoVirtual());
    translation_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleOdometry.translation_and_accuracy)
  return translation_and_accuracy_;
}
inline void VehicleOdometry::set_allocated_translation_and_accuracy(::sensoris::protobuf::types::spatial::PositionAndAccuracy* translation_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(translation_and_accuracy_);
  }
  if (translation_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(translation_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      translation_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, translation_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  translation_and_accuracy_ = translation_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleOdometry.translation_and_accuracy)
}

// .sensoris.protobuf.types.spatial.RotationAndAccuracy rotation_and_accuracy = 4;
inline bool VehicleOdometry::has_rotation_and_accuracy() const {
  return this != internal_default_instance() && rotation_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& VehicleOdometry::_internal_rotation_and_accuracy() const {
  return *rotation_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RotationAndAccuracy& VehicleOdometry::rotation_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RotationAndAccuracy* p = rotation_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleOdometry.rotation_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RotationAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehicleOdometry::release_rotation_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleOdometry.rotation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = rotation_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  rotation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehicleOdometry::unsafe_arena_release_rotation_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleOdometry.rotation_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationAndAccuracy* temp = rotation_and_accuracy_;
  rotation_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationAndAccuracy* VehicleOdometry::mutable_rotation_and_accuracy() {
  
  if (rotation_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationAndAccuracy>(GetArenaNoVirtual());
    rotation_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleOdometry.rotation_and_accuracy)
  return rotation_and_accuracy_;
}
inline void VehicleOdometry::set_allocated_rotation_and_accuracy(::sensoris::protobuf::types::spatial::RotationAndAccuracy* rotation_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rotation_and_accuracy_);
  }
  if (rotation_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(rotation_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      rotation_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rotation_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  rotation_and_accuracy_ = rotation_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleOdometry.rotation_and_accuracy)
}

// -------------------------------------------------------------------

// VehicleSpeed

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VehicleSpeed::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleSpeed::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleSpeed::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleSpeed.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleSpeed::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleSpeed.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleSpeed::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleSpeed.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleSpeed::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleSpeed.envelope)
  return envelope_;
}
inline void VehicleSpeed::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleSpeed.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy value_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool VehicleSpeed::has_value_and_accuracy() const {
  return this != internal_default_instance() && value_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& VehicleSpeed::_internal_value_and_accuracy() const {
  return *value_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& VehicleSpeed::value_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = value_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleSpeed.value_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleSpeed::release_value_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleSpeed.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = value_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleSpeed::unsafe_arena_release_value_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleSpeed.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = value_and_accuracy_;
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleSpeed::mutable_value_and_accuracy() {
  
  if (value_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    value_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleSpeed.value_and_accuracy)
  return value_and_accuracy_;
}
inline void VehicleSpeed::set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_and_accuracy_);
  }
  if (value_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      value_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  value_and_accuracy_ = value_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleSpeed.value_and_accuracy)
}

// -------------------------------------------------------------------

// VehicleAcceleration

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VehicleAcceleration::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleAcceleration::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleAcceleration::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleAcceleration.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleAcceleration::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleAcceleration.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleAcceleration::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleAcceleration.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleAcceleration::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleAcceleration.envelope)
  return envelope_;
}
inline void VehicleAcceleration::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleAcceleration.envelope)
}

// .sensoris.protobuf.types.spatial.XyzVectorAndAccuracy value_and_accuracy = 2 [(.sensoris.protobuf.types.base.exponent) = 1];
inline bool VehicleAcceleration::has_value_and_accuracy() const {
  return this != internal_default_instance() && value_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& VehicleAcceleration::_internal_value_and_accuracy() const {
  return *value_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy& VehicleAcceleration::value_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* p = value_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleAcceleration.value_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_XyzVectorAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleAcceleration::release_value_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleAcceleration.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = value_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleAcceleration::unsafe_arena_release_value_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleAcceleration.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* temp = value_and_accuracy_;
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* VehicleAcceleration::mutable_value_and_accuracy() {
  
  if (value_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy>(GetArenaNoVirtual());
    value_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleAcceleration.value_and_accuracy)
  return value_and_accuracy_;
}
inline void VehicleAcceleration::set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::XyzVectorAndAccuracy* value_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_and_accuracy_);
  }
  if (value_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      value_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  value_and_accuracy_ = value_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleAcceleration.value_and_accuracy)
}

// -------------------------------------------------------------------

// VehicleRotationRate

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool VehicleRotationRate::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleRotationRate::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& VehicleRotationRate::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleRotationRate.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleRotationRate::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleRotationRate.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleRotationRate::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleRotationRate.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* VehicleRotationRate::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleRotationRate.envelope)
  return envelope_;
}
inline void VehicleRotationRate::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleRotationRate.envelope)
}

// .sensoris.protobuf.types.spatial.RotationRateAndAccuracy value_and_accuracy = 2;
inline bool VehicleRotationRate::has_value_and_accuracy() const {
  return this != internal_default_instance() && value_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy& VehicleRotationRate::_internal_value_and_accuracy() const {
  return *value_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy& VehicleRotationRate::value_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* p = value_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.VehicleRotationRate.value_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RotationRateAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* VehicleRotationRate::release_value_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.VehicleRotationRate.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* temp = value_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* VehicleRotationRate::unsafe_arena_release_value_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.VehicleRotationRate.value_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* temp = value_and_accuracy_;
  value_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* VehicleRotationRate::mutable_value_and_accuracy() {
  
  if (value_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RotationRateAndAccuracy>(GetArenaNoVirtual());
    value_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.VehicleRotationRate.value_and_accuracy)
  return value_and_accuracy_;
}
inline void VehicleRotationRate::set_allocated_value_and_accuracy(::sensoris::protobuf::types::spatial::RotationRateAndAccuracy* value_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_and_accuracy_);
  }
  if (value_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      value_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  value_and_accuracy_ = value_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.VehicleRotationRate.value_and_accuracy)
}

// -------------------------------------------------------------------

// LocalizationCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool LocalizationCategory::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& LocalizationCategory::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& LocalizationCategory::envelope() const {
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      &::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* LocalizationCategory::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.localization.LocalizationCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* LocalizationCategory::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.localization.LocalizationCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* LocalizationCategory::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.envelope)
  return envelope_;
}
inline void LocalizationCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.localization.LocalizationCategory.envelope)
}

// repeated .sensoris.protobuf.categories.localization.VehiclePositionAndOrientation vehicle_position_and_orientation = 2;
inline int LocalizationCategory::vehicle_position_and_orientation_size() const {
  return vehicle_position_and_orientation_.size();
}
inline void LocalizationCategory::clear_vehicle_position_and_orientation() {
  vehicle_position_and_orientation_.Clear();
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation* LocalizationCategory::mutable_vehicle_position_and_orientation(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_position_and_orientation)
  return vehicle_position_and_orientation_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation >*
LocalizationCategory::mutable_vehicle_position_and_orientation() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_position_and_orientation)
  return &vehicle_position_and_orientation_;
}
inline const ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation& LocalizationCategory::vehicle_position_and_orientation(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_position_and_orientation)
  return vehicle_position_and_orientation_.Get(index);
}
inline ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation* LocalizationCategory::add_vehicle_position_and_orientation() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_position_and_orientation)
  return vehicle_position_and_orientation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation >&
LocalizationCategory::vehicle_position_and_orientation() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_position_and_orientation)
  return vehicle_position_and_orientation_;
}

// repeated .sensoris.protobuf.categories.localization.VehicleOdometry vehicle_odometry = 3;
inline int LocalizationCategory::vehicle_odometry_size() const {
  return vehicle_odometry_.size();
}
inline void LocalizationCategory::clear_vehicle_odometry() {
  vehicle_odometry_.Clear();
}
inline ::sensoris::protobuf::categories::localization::VehicleOdometry* LocalizationCategory::mutable_vehicle_odometry(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_odometry)
  return vehicle_odometry_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleOdometry >*
LocalizationCategory::mutable_vehicle_odometry() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_odometry)
  return &vehicle_odometry_;
}
inline const ::sensoris::protobuf::categories::localization::VehicleOdometry& LocalizationCategory::vehicle_odometry(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_odometry)
  return vehicle_odometry_.Get(index);
}
inline ::sensoris::protobuf::categories::localization::VehicleOdometry* LocalizationCategory::add_vehicle_odometry() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_odometry)
  return vehicle_odometry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleOdometry >&
LocalizationCategory::vehicle_odometry() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_odometry)
  return vehicle_odometry_;
}

// repeated .sensoris.protobuf.categories.localization.VehicleSpeed vehicle_speed = 4;
inline int LocalizationCategory::vehicle_speed_size() const {
  return vehicle_speed_.size();
}
inline void LocalizationCategory::clear_vehicle_speed() {
  vehicle_speed_.Clear();
}
inline ::sensoris::protobuf::categories::localization::VehicleSpeed* LocalizationCategory::mutable_vehicle_speed(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_speed)
  return vehicle_speed_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleSpeed >*
LocalizationCategory::mutable_vehicle_speed() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_speed)
  return &vehicle_speed_;
}
inline const ::sensoris::protobuf::categories::localization::VehicleSpeed& LocalizationCategory::vehicle_speed(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_speed)
  return vehicle_speed_.Get(index);
}
inline ::sensoris::protobuf::categories::localization::VehicleSpeed* LocalizationCategory::add_vehicle_speed() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_speed)
  return vehicle_speed_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleSpeed >&
LocalizationCategory::vehicle_speed() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_speed)
  return vehicle_speed_;
}

// repeated .sensoris.protobuf.categories.localization.VehicleAcceleration vehicle_acceleration = 5;
inline int LocalizationCategory::vehicle_acceleration_size() const {
  return vehicle_acceleration_.size();
}
inline void LocalizationCategory::clear_vehicle_acceleration() {
  vehicle_acceleration_.Clear();
}
inline ::sensoris::protobuf::categories::localization::VehicleAcceleration* LocalizationCategory::mutable_vehicle_acceleration(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_acceleration)
  return vehicle_acceleration_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleAcceleration >*
LocalizationCategory::mutable_vehicle_acceleration() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_acceleration)
  return &vehicle_acceleration_;
}
inline const ::sensoris::protobuf::categories::localization::VehicleAcceleration& LocalizationCategory::vehicle_acceleration(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_acceleration)
  return vehicle_acceleration_.Get(index);
}
inline ::sensoris::protobuf::categories::localization::VehicleAcceleration* LocalizationCategory::add_vehicle_acceleration() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_acceleration)
  return vehicle_acceleration_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleAcceleration >&
LocalizationCategory::vehicle_acceleration() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_acceleration)
  return vehicle_acceleration_;
}

// repeated .sensoris.protobuf.categories.localization.VehicleRotationRate vehicle_rotation_rate = 6;
inline int LocalizationCategory::vehicle_rotation_rate_size() const {
  return vehicle_rotation_rate_.size();
}
inline void LocalizationCategory::clear_vehicle_rotation_rate() {
  vehicle_rotation_rate_.Clear();
}
inline ::sensoris::protobuf::categories::localization::VehicleRotationRate* LocalizationCategory::mutable_vehicle_rotation_rate(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_rotation_rate)
  return vehicle_rotation_rate_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleRotationRate >*
LocalizationCategory::mutable_vehicle_rotation_rate() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_rotation_rate)
  return &vehicle_rotation_rate_;
}
inline const ::sensoris::protobuf::categories::localization::VehicleRotationRate& LocalizationCategory::vehicle_rotation_rate(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_rotation_rate)
  return vehicle_rotation_rate_.Get(index);
}
inline ::sensoris::protobuf::categories::localization::VehicleRotationRate* LocalizationCategory::add_vehicle_rotation_rate() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_rotation_rate)
  return vehicle_rotation_rate_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::localization::VehicleRotationRate >&
LocalizationCategory::vehicle_rotation_rate() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.localization.LocalizationCategory.vehicle_rotation_rate)
  return vehicle_rotation_rate_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace localization
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType>() {
  return ::sensoris::protobuf::categories::localization::VehiclePositionAndOrientation_NavigationSatelliteSystemStatus_FixType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2flocalization_2eproto

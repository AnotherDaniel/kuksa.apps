// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensoris/protobuf/categories/traffic_regulation.proto

#ifndef PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto
#define PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include "sensoris/protobuf/types/base.pb.h"
#include "sensoris/protobuf/types/spatial.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto 

namespace protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficregulation {
class TrafficRegulationCategory;
class TrafficRegulationCategoryDefaultTypeInternal;
extern TrafficRegulationCategoryDefaultTypeInternal _TrafficRegulationCategory_default_instance_;
class TrafficSign;
class TrafficSignDefaultTypeInternal;
extern TrafficSignDefaultTypeInternal _TrafficSign_default_instance_;
class TrafficSign_DominantBackgroundColorAndConfidence;
class TrafficSign_DominantBackgroundColorAndConfidenceDefaultTypeInternal;
extern TrafficSign_DominantBackgroundColorAndConfidenceDefaultTypeInternal _TrafficSign_DominantBackgroundColorAndConfidence_default_instance_;
class TrafficSign_PermanencyAndConfidence;
class TrafficSign_PermanencyAndConfidenceDefaultTypeInternal;
extern TrafficSign_PermanencyAndConfidenceDefaultTypeInternal _TrafficSign_PermanencyAndConfidence_default_instance_;
class TrafficSign_ShapeAndConfidence;
class TrafficSign_ShapeAndConfidenceDefaultTypeInternal;
extern TrafficSign_ShapeAndConfidenceDefaultTypeInternal _TrafficSign_ShapeAndConfidence_default_instance_;
class TrafficSign_SupplementarySignAndConfidence;
class TrafficSign_SupplementarySignAndConfidenceDefaultTypeInternal;
extern TrafficSign_SupplementarySignAndConfidenceDefaultTypeInternal _TrafficSign_SupplementarySignAndConfidence_default_instance_;
class TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence;
class TrafficSign_SupplementarySignAndConfidence_TypeAndConfidenceDefaultTypeInternal;
extern TrafficSign_SupplementarySignAndConfidence_TypeAndConfidenceDefaultTypeInternal _TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_;
class TrafficSign_TypeAndConfidence;
class TrafficSign_TypeAndConfidenceDefaultTypeInternal;
extern TrafficSign_TypeAndConfidenceDefaultTypeInternal _TrafficSign_TypeAndConfidence_default_instance_;
class TrafficSign_ValidationAndConfidence;
class TrafficSign_ValidationAndConfidenceDefaultTypeInternal;
extern TrafficSign_ValidationAndConfidenceDefaultTypeInternal _TrafficSign_ValidationAndConfidence_default_instance_;
class TrafficSign_ValueAndConfidence;
class TrafficSign_ValueAndConfidenceDefaultTypeInternal;
extern TrafficSign_ValueAndConfidenceDefaultTypeInternal _TrafficSign_ValueAndConfidence_default_instance_;
}  // namespace trafficregulation
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris
namespace google {
namespace protobuf {
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficRegulationCategory* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficRegulationCategory>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence>(Arena*);
template<> ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* Arena::CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sensoris {
namespace protobuf {
namespace categories {
namespace trafficregulation {

enum TrafficSign_ShapeAndConfidence_Type {
  TrafficSign_ShapeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_ShapeAndConfidence_Type_OTHER = 1,
  TrafficSign_ShapeAndConfidence_Type_RECTANGLE = 2,
  TrafficSign_ShapeAndConfidence_Type_SQUARE = 3,
  TrafficSign_ShapeAndConfidence_Type_TRIANGLE_UP = 4,
  TrafficSign_ShapeAndConfidence_Type_TRIANGLE_DOWN = 5,
  TrafficSign_ShapeAndConfidence_Type_DIAMOND = 6,
  TrafficSign_ShapeAndConfidence_Type_HEXAGON = 7,
  TrafficSign_ShapeAndConfidence_Type_ROUND = 8,
  TrafficSign_ShapeAndConfidence_Type_CROSS_BUCK = 9,
  TrafficSign_ShapeAndConfidence_Type_OCTAGON = 10,
  TrafficSign_ShapeAndConfidence_Type_ELLIPSE = 11,
  TrafficSign_ShapeAndConfidence_Type_PENTAGON = 12,
  TrafficSign_ShapeAndConfidence_Type_TrafficSign_ShapeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_ShapeAndConfidence_Type_TrafficSign_ShapeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_ShapeAndConfidence_Type_IsValid(int value);
const TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence_Type_Type_MIN = TrafficSign_ShapeAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence_Type_Type_MAX = TrafficSign_ShapeAndConfidence_Type_PENTAGON;
const int TrafficSign_ShapeAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_ShapeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_ShapeAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_ShapeAndConfidence_Type_Name(TrafficSign_ShapeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_ShapeAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_ShapeAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_ShapeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_ShapeAndConfidence_Type>(
    TrafficSign_ShapeAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_TypeAndConfidence_Type {
  TrafficSign_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_TypeAndConfidence_Type_OTHER_AS_TEXT = 1,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT = 2,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_END = 3,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_CHANGE_UPCOMING = 4,
  TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT = 5,
  TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT_END = 6,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING = 7,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_END = 8,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_START = 9,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_END = 10,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_START = 11,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_START = 12,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_END = 13,
  TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_END = 14,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK = 15,
  TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK_END = 16,
  TrafficSign_TypeAndConfidence_Type_ALL_RESTRICTIONS_END = 17,
  TrafficSign_TypeAndConfidence_Type_CITY_START = 18,
  TrafficSign_TypeAndConfidence_Type_CITY_END = 19,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY = 20,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_END = 21,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY = 22,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_END = 23,
  TrafficSign_TypeAndConfidence_Type_CONSTRUCTION = 24,
  TrafficSign_TypeAndConfidence_Type_CONSTRUCTION_END = 25,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE = 26,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_RIGHT = 27,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_LEFT = 28,
  TrafficSign_TypeAndConfidence_Type_LANE_MERGE_CENTER = 29,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_GENERAL = 30,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_PROTECTED = 31,
  TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_UNPROTECTED = 32,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS = 33,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_LEFT = 34,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_RIGHT = 35,
  TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_CENTER = 36,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE = 37,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_LEFT = 38,
  TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_RIGHT = 39,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD = 40,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_LEFT = 41,
  TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_RIGHT = 42,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL = 43,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL_UPWARDS = 44,
  TrafficSign_TypeAndConfidence_Type_STEEP_HILL_DOWNWARDS = 45,
  TrafficSign_TypeAndConfidence_Type_STOP_SIGN = 46,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND = 47,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_RIGHT = 48,
  TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_LEFT = 49,
  TrafficSign_TypeAndConfidence_Type_GENERAL_WARNING = 50,
  TrafficSign_TypeAndConfidence_Type_RISK_OF_GROUNDING = 51,
  TrafficSign_TypeAndConfidence_Type_ANIMAL = 52,
  TrafficSign_TypeAndConfidence_Type_ICY_CONDITIONS = 53,
  TrafficSign_TypeAndConfidence_Type_SLIPPERY_ROAD = 54,
  TrafficSign_TypeAndConfidence_Type_UNEVEN_ROAD = 55,
  TrafficSign_TypeAndConfidence_Type_SCHOOL_ZONE = 56,
  TrafficSign_TypeAndConfidence_Type_TRAMWAY_CROSSING = 57,
  TrafficSign_TypeAndConfidence_Type_CONGESTION_HAZARD = 58,
  TrafficSign_TypeAndConfidence_Type_ACCIDENT_HAZARD = 59,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_CROSSING = 60,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_OVER_ONCOMING_TRAFFIC = 61,
  TrafficSign_TypeAndConfidence_Type_YIELD = 62,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD = 63,
  TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD_END = 64,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING = 65,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING_END = 66,
  TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA = 67,
  TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA_END = 68,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION = 69,
  TrafficSign_TypeAndConfidence_Type_ROUNDABOUT = 70,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT = 71,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_RIGHT = 72,
  TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT_OR_RIGHT = 73,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RIGHT_ONLY = 74,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_ONLY = 75,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_ONLY = 76,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_OR_RIGHT = 77,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RESTRICTION = 78,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_LEFT = 79,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_RIGHT = 80,
  TrafficSign_TypeAndConfidence_Type_NO_LEFT_TURN = 81,
  TrafficSign_TypeAndConfidence_Type_NO_RIGHT_TURN = 82,
  TrafficSign_TypeAndConfidence_Type_NO_U_TURN = 83,
  TrafficSign_TypeAndConfidence_Type_NO_U_OR_LEFT_TURN = 84,
  TrafficSign_TypeAndConfidence_Type_U_TURN_ALLOWED = 85,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_TRUCK = 86,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_RIGHT_TRUCK = 87,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_TRUCK = 88,
  TrafficSign_TypeAndConfidence_Type_NO_ENTRY = 89,
  TrafficSign_TypeAndConfidence_Type_DEAD_END = 90,
  TrafficSign_TypeAndConfidence_Type_HIGH_OCCUPANCY_VEHICLE_LANE = 91,
  TrafficSign_TypeAndConfidence_Type_TOLL = 92,
  TrafficSign_TypeAndConfidence_Type_TOLL_CAR = 93,
  TrafficSign_TypeAndConfidence_Type_TOLL_LANE = 94,
  TrafficSign_TypeAndConfidence_Type_EXPRESS_LANE = 95,
  TrafficSign_TypeAndConfidence_Type_SHOULDER_OPEN_FOR_TRAFFIC = 96,
  TrafficSign_TypeAndConfidence_Type_SHOULDER_CLOSED_FOR_TRAFFIC = 97,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED = 98,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_RIGHT_MOST_LANE = 99,
  TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_LEFT_MOST_LANE = 100,
  TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN = 101,
  TrafficSign_TypeAndConfidence_Type_WARNING_CHILDREN = 102,
  TrafficSign_TypeAndConfidence_Type_WARNING_BICYCLE = 103,
  TrafficSign_TypeAndConfidence_Type_WARNING_BUS = 104,
  TrafficSign_TypeAndConfidence_Type_PUBLIC_TRANSPORTATION_STOP = 105,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_CROSSING = 106,
  TrafficSign_TypeAndConfidence_Type_WEIGHT_RESTRICTION = 107,
  TrafficSign_TypeAndConfidence_Type_HEIGHT_RESTRICTION = 108,
  TrafficSign_TypeAndConfidence_Type_LENGTH_RESTRICTION = 109,
  TrafficSign_TypeAndConfidence_Type_WIDTH_RESTRICTION = 110,
  TrafficSign_TypeAndConfidence_Type_WARNING_TRUCK_ROLLOVER = 111,
  TrafficSign_TypeAndConfidence_Type_SIGNAL_AHEAD = 112,
  TrafficSign_TypeAndConfidence_Type_SKI_CROSSING = 113,
  TrafficSign_TypeAndConfidence_Type_NO_AGRICULTUR_VEHICLE = 114,
  TrafficSign_TypeAndConfidence_Type_NO_BICYCLE = 115,
  TrafficSign_TypeAndConfidence_Type_NO_BUS = 116,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_EXPLOSIVES = 117,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_HARMFUL_TO_WATER = 118,
  TrafficSign_TypeAndConfidence_Type_NO_HAUL_HAZARDOUS_MATERIAL = 119,
  TrafficSign_TypeAndConfidence_Type_NO_MOTORCYCLE = 120,
  TrafficSign_TypeAndConfidence_Type_NO_TRAILER = 121,
  TrafficSign_TypeAndConfidence_Type_NO_TRUCK_WITH_TRAILER = 122,
  TrafficSign_TypeAndConfidence_Type_PARK_AND_RIDE = 123,
  TrafficSign_TypeAndConfidence_Type_ROAD_DISTANCE = 124,
  TrafficSign_TypeAndConfidence_Type_EMERGENCY_PHONE = 125,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ENFORCEMENT = 126,
  TrafficSign_TypeAndConfidence_Type_TRAFFIC_LIGHT_ENFORCEMENT = 127,
  TrafficSign_TypeAndConfidence_Type_BOARD_DIRECTION = 128,
  TrafficSign_TypeAndConfidence_Type_STREET_NAME = 129,
  TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT = 130,
  TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT_END = 131,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT = 132,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT_END = 133,
  TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED = 134,
  TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED_END = 135,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE = 136,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE_END = 137,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH = 138,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH_END = 139,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH = 140,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH_END = 141,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH = 142,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH_END = 143,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET = 144,
  TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET_END = 145,
  TrafficSign_TypeAndConfidence_Type_CURVE_LEFT_THEN_RIGHT = 146,
  TrafficSign_TypeAndConfidence_Type_CURVE_RIGHT_THEN_LEFT = 147,
  TrafficSign_TypeAndConfidence_Type_CURVE_TRIPLE_HAIRPIN = 148,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP = 149,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_LEFT = 150,
  TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_RIGHT = 151,
  TrafficSign_TypeAndConfidence_Type_NO_ANIMAL_CATTLE = 152,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_DEER = 153,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_MOOSE = 154,
  TrafficSign_TypeAndConfidence_Type_NO_HORSE_RIDING = 155,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS = 156,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_LEFT = 157,
  TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_RIGHT = 158,
  TrafficSign_TypeAndConfidence_Type_YIELD_TO_ONCOMING_TRAFFIC = 159,
  TrafficSign_TypeAndConfidence_Type_UNPROTECTED_LEFT_TURN = 160,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC = 161,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_LEFT = 162,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_RIGHT = 163,
  TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_STRAIGHT = 164,
  TrafficSign_TypeAndConfidence_Type_NO_VEHICLE = 165,
  TrafficSign_TypeAndConfidence_Type_NO_MOTOR_VEHICLE = 166,
  TrafficSign_TypeAndConfidence_Type_NO_TRUCK = 167,
  TrafficSign_TypeAndConfidence_Type_NO_PEDESTRIAN = 168,
  TrafficSign_TypeAndConfidence_Type_LANE_USED_IN_BOTH_DIRECTIONS = 169,
  TrafficSign_TypeAndConfidence_Type_FOG_AREA = 170,
  TrafficSign_TypeAndConfidence_Type_TIRE_CHAINS_MANDATORY = 171,
  TrafficSign_TypeAndConfidence_Type_HIJACKING_HOTSPOT = 172,
  TrafficSign_TypeAndConfidence_Type_OVERPASS_AHEAD = 173,
  TrafficSign_TypeAndConfidence_Type_TUNNEL = 174,
  TrafficSign_TypeAndConfidence_Type_FERRY_TERMINAL = 175,
  TrafficSign_TypeAndConfidence_Type_NARROW_BRIDGE = 176,
  TrafficSign_TypeAndConfidence_Type_NO_IDLING = 177,
  TrafficSign_TypeAndConfidence_Type_HUMPBACK_BRIDGE = 178,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT = 179,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_LEFT = 180,
  TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_RIGHT = 181,
  TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD = 182,
  TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_TO_THE_RIGHT = 183,
  TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_LEFT = 184,
  TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_RIGHT = 185,
  TrafficSign_TypeAndConfidence_Type_TWO_WAY_TRAFFIC = 186,
  TrafficSign_TypeAndConfidence_Type_BUMP = 187,
  TrafficSign_TypeAndConfidence_Type_DIP = 188,
  TrafficSign_TypeAndConfidence_Type_ROAD_FLOODED = 189,
  TrafficSign_TypeAndConfidence_Type_AUDIBLE_WARNING = 190,
  TrafficSign_TypeAndConfidence_Type_VILLAGE_AHEAD = 191,
  TrafficSign_TypeAndConfidence_Type_MOVABLE_BRIDGE = 192,
  TrafficSign_TypeAndConfidence_Type_SLOW_DOWN = 193,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T = 194,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT = 195,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_RIGHT = 196,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT_RIGHT = 197,
  TrafficSign_TypeAndConfidence_Type_INTERSECTION_Y = 198,
  TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR = 199,
  TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR_END = 200,
  TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING = 201,
  TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING_END = 202,
  TrafficSign_TypeAndConfidence_Type_WAITING_LINE = 203,
  TrafficSign_TypeAndConfidence_Type_DONT_STOP_ZONE = 204,
  TrafficSign_TypeAndConfidence_Type_HONKING_PROHIBITED = 205,
  TrafficSign_TypeAndConfidence_Type_FASTEN_SEAT_BELT = 206,
  TrafficSign_TypeAndConfidence_Type_HAMLET_ENTRY = 207,
  TrafficSign_TypeAndConfidence_Type_HAMLET_EXIT = 208,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_1_STRIPE = 209,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_2_STRIPES = 210,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_3_STRIPES = 211,
  TrafficSign_TypeAndConfidence_Type_GUIDING_BEACON = 212,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_1_STRIPE = 213,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_2_STRIPES = 214,
  TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_3_STRIPES = 215,
  TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE = 216,
  TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE_END = 217,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_EXCEPT_TAXI = 218,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING = 219,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT = 220,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_RIGHT = 221,
  TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT_AND_RIGHT = 222,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING = 223,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT = 224,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_RIGHT = 225,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT_AND_RIGHT = 226,
  TrafficSign_TypeAndConfidence_Type_RUNNAWAY_TRUCK_RAMP = 227,
  TrafficSign_TypeAndConfidence_Type_TURN_ON_GREEN = 228,
  TrafficSign_TypeAndConfidence_Type_NO_TURN_ON_RED = 229,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_ROAD_NUMBER = 230,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_ROAD_NUMBER = 231,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_INTERCHANGE_NUMBER = 232,
  TrafficSign_TypeAndConfidence_Type_EUROPEAN_ROAD_NUMBER = 233,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE = 234,
  TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE_END = 235,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE = 236,
  TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE_END = 237,
  TrafficSign_TypeAndConfidence_Type_PARKING_ZONE = 238,
  TrafficSign_TypeAndConfidence_Type_PARKING_ZONE_END = 239,
  TrafficSign_TypeAndConfidence_Type_PARKING = 240,
  TrafficSign_TypeAndConfidence_Type_PARKING_TO_LEFT = 241,
  TrafficSign_TypeAndConfidence_Type_PARKING_TO_RIGHT = 242,
  TrafficSign_TypeAndConfidence_Type_PARKING_GARAGE = 243,
  TrafficSign_TypeAndConfidence_Type_PARKING_ON_SIDEWAY = 244,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE = 245,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_VEHICLE = 246,
  TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_TRUCK = 247,
  TrafficSign_TypeAndConfidence_Type_DETOUR = 248,
  TrafficSign_TypeAndConfidence_Type_DETOUR_END = 249,
  TrafficSign_TypeAndConfidence_Type_DETOUR_LEFT = 250,
  TrafficSign_TypeAndConfidence_Type_DETOUR_RIGHT = 251,
  TrafficSign_TypeAndConfidence_Type_STATION_GAS = 252,
  TrafficSign_TypeAndConfidence_Type_STATION_LPG = 253,
  TrafficSign_TypeAndConfidence_Type_STATION_CNG = 254,
  TrafficSign_TypeAndConfidence_Type_STATION_H2 = 255,
  TrafficSign_TypeAndConfidence_Type_STATION_ELECTRO = 256,
  TrafficSign_TypeAndConfidence_Type_STATION_POLICE = 257,
  TrafficSign_TypeAndConfidence_Type_CAMPING_SPOT = 258,
  TrafficSign_TypeAndConfidence_Type_RESTROOMS = 259,
  TrafficSign_TypeAndConfidence_Type_INFO_POINT = 260,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT_AHEAD = 261,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT_AHEAD = 262,
  TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT = 263,
  TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT = 264,
  TrafficSign_TypeAndConfidence_Type_FIRST_AID = 265,
  TrafficSign_TypeAndConfidence_Type_LOW_FLYING = 266,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT = 267,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_LEFT = 268,
  TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_RIGHT = 269,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_UNDERPASS = 270,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_OVERPASS = 271,
  TrafficSign_TypeAndConfidence_Type_BREAKDOWN_BAY = 272,
  TrafficSign_TypeAndConfidence_Type_BUS_LANE = 273,
  TrafficSign_TypeAndConfidence_Type_DOUBLE_HAIRPIN = 274,
  TrafficSign_TypeAndConfidence_Type_COUNTRY_SPECIFIC_INFORMATION = 275,
  TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_SHARED_PATH = 276,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSED = 277,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_OPEN = 278,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_LEFT = 279,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_RIGHT = 280,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT = 281,
  TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT = 282,
  TrafficSign_TypeAndConfidence_Type_TRINATURE = 283,
  TrafficSign_TypeAndConfidence_Type_ANIMAL_FROG = 284,
  TrafficSign_TypeAndConfidence_Type_GRAVEL = 285,
  TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN_CROSSING = 286,
  TrafficSign_TypeAndConfidence_Type_LOW_TREE = 287,
  TrafficSign_TypeAndConfidence_Type_WARNING_RIDER = 288,
  TrafficSign_TypeAndConfidence_Type_STOP_AHEAD = 289,
  TrafficSign_TypeAndConfidence_Type_YIELD_AHEAD = 290,
  TrafficSign_TypeAndConfidence_Type_WATER_PROTECTION_AREA = 291,
  TrafficSign_TypeAndConfidence_Type_TOLL_DOUANE = 292,
  TrafficSign_TypeAndConfidence_Type_NO_CAR_OR_BIKE = 293,
  TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_ONLY_UP = 294,
  TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_UP_AND_DOWN = 295,
  TrafficSign_TypeAndConfidence_Type_MILITARY_SIGN = 296,
  TrafficSign_TypeAndConfidence_Type_SMOG = 297,
  TrafficSign_TypeAndConfidence_Type_ROUNDABOUT_AHEAD = 298,
  TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT = 299,
  TrafficSign_TypeAndConfidence_Type_DEAD_END_RIGHT = 300,
  TrafficSign_TypeAndConfidence_Type_DEAD_END_LEFT = 301,
  TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK = 302,
  TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK_END = 303,
  TrafficSign_TypeAndConfidence_Type_STAGGERED_JUNCTION = 304,
  TrafficSign_TypeAndConfidence_Type_AXLE_WEIGHT_RESTRICTION = 305,
  TrafficSign_TypeAndConfidence_Type_TOLL_END = 306,
  TrafficSign_TypeAndConfidence_Type_TOLL_CAR_END = 307,
  TrafficSign_TypeAndConfidence_Type_TOLL_LANE_END = 308,
  TrafficSign_TypeAndConfidence_Type_TrafficSign_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_TypeAndConfidence_Type_TrafficSign_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_TypeAndConfidence_Type_IsValid(int value);
const TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence_Type_Type_MIN = TrafficSign_TypeAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence_Type_Type_MAX = TrafficSign_TypeAndConfidence_Type_TOLL_LANE_END;
const int TrafficSign_TypeAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_TypeAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_TypeAndConfidence_Type_Name(TrafficSign_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_TypeAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_TypeAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_TypeAndConfidence_Type>(
    TrafficSign_TypeAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_PermanencyAndConfidence_Type {
  TrafficSign_PermanencyAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_PermanencyAndConfidence_Type_STATIC = 1,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE = 2,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_ELECTRONICALLY = 3,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_MECHANICALLY = 4,
  TrafficSign_PermanencyAndConfidence_Type_VARIABLE_DEACTIVATED = 5,
  TrafficSign_PermanencyAndConfidence_Type_TrafficSign_PermanencyAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_PermanencyAndConfidence_Type_TrafficSign_PermanencyAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_PermanencyAndConfidence_Type_IsValid(int value);
const TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence_Type_Type_MIN = TrafficSign_PermanencyAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence_Type_Type_MAX = TrafficSign_PermanencyAndConfidence_Type_VARIABLE_DEACTIVATED;
const int TrafficSign_PermanencyAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_PermanencyAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_PermanencyAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_PermanencyAndConfidence_Type_Name(TrafficSign_PermanencyAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_PermanencyAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_PermanencyAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_PermanencyAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_PermanencyAndConfidence_Type>(
    TrafficSign_PermanencyAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_ValidationAndConfidence_Type {
  TrafficSign_ValidationAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_ValidationAndConfidence_Type_VALID = 1,
  TrafficSign_ValidationAndConfidence_Type_INVALID = 2,
  TrafficSign_ValidationAndConfidence_Type_TrafficSign_ValidationAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_ValidationAndConfidence_Type_TrafficSign_ValidationAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_ValidationAndConfidence_Type_IsValid(int value);
const TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence_Type_Type_MIN = TrafficSign_ValidationAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence_Type_Type_MAX = TrafficSign_ValidationAndConfidence_Type_INVALID;
const int TrafficSign_ValidationAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_ValidationAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_ValidationAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_ValidationAndConfidence_Type_Name(TrafficSign_ValidationAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_ValidationAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_ValidationAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_ValidationAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_ValidationAndConfidence_Type>(
    TrafficSign_ValidationAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_DominantBackgroundColorAndConfidence_Type {
  TrafficSign_DominantBackgroundColorAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_OTHER = 1,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_WHITE = 2,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_RED = 3,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_GREEN = 4,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BLUE = 5,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_YELLOW = 6,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BLACK = 7,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_BROWN = 8,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_TrafficSign_DominantBackgroundColorAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_DominantBackgroundColorAndConfidence_Type_TrafficSign_DominantBackgroundColorAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_DominantBackgroundColorAndConfidence_Type_IsValid(int value);
const TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MIN = TrafficSign_DominantBackgroundColorAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MAX = TrafficSign_DominantBackgroundColorAndConfidence_Type_BROWN;
const int TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(TrafficSign_DominantBackgroundColorAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_DominantBackgroundColorAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_DominantBackgroundColorAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_DominantBackgroundColorAndConfidence_Type>(
    TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor(), name, value);
}
enum TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type {
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_UNKNOWN_TYPE = 0,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OTHER_AS_TEXT = 1,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WET = 2,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAIN = 3,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW = 4,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW_OR_RAIN = 5,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FOG = 6,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TIME = 7,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DAY_AND_TIME = 8,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NIGHT = 9,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SEASON = 10,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS = 11,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS_AND_TIME = 12,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SCHOOL = 13,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAMP = 14,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK = 15,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER = 16,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR = 17,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER = 18,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_EXCEPT = 19,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS = 20,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCKS_AND_BUS = 21,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARS_TRUCKS_BUS = 22,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TAXI = 23,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TANK = 24,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE = 25,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WEIGHT = 26,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STARTING_IN = 27,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_VALID_FOR = 28,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_RIGHT_DIRECTION = 29,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_LEFT_DIRECTION = 30,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE = 31,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_START = 32,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_END = 33,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BEGIN_OF_VALIDITY = 34,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_END_OF_VALIDITY = 35,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FROG = 36,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ALL_WAY = 37,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE = 38,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE_EXCEPT = 39,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS_EXCEPT = 40,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CAMPER = 41,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARAVAN = 42,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CONSTRUCTION_GATEWAY = 43,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CROSS_WAY = 44,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DELIVERY_EXCEPT = 45,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ELECTRONIC_CAR = 46,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GATEWAY = 47,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_LEFT = 48,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_RIGHT = 49,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GRAVEL = 50,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZMAT = 51,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZ_WATER = 52,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_KIDS = 53,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOCAL_EXCEP = 54,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOW_TREE = 55,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE = 56,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE_EXCEPT = 57,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NEW_ROAD_BED = 58,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NO_STOP_SHOULDER = 59,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OIL_TRAIL = 60,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_EXCEPT = 61,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT = 62,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PEDESTRIAN = 63,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_LEFT = 64,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_RIGHT = 65,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROAD_DAMAGE = 66,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RUTS = 67,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR = 68,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_MAY_BE_OVERTAKEN = 69,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAFFIC_JAM = 70,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAIN = 71,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAM = 72,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_EXCEPT = 73,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER_EXCEPT = 74,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GET_IN_PROPER_LANE = 75,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE_TRUCK = 76,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAPPEL = 77,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RADAR_ENFORCED = 78,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STOP_IN_DISTANCE = 79,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_IsValid(int value);
const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MIN = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_UNKNOWN_TYPE;
const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MAX = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STOP_IN_DISTANCE;
const int TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_ARRAYSIZE = TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
inline const ::std::string& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor(), value);
}
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Parse(
    const ::std::string& name, TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>(
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor(), name, value);
}
// ===================================================================

class TrafficSign_ShapeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence) */ {
 public:
  TrafficSign_ShapeAndConfidence();
  virtual ~TrafficSign_ShapeAndConfidence();

  TrafficSign_ShapeAndConfidence(const TrafficSign_ShapeAndConfidence& from);

  inline TrafficSign_ShapeAndConfidence& operator=(const TrafficSign_ShapeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_ShapeAndConfidence(TrafficSign_ShapeAndConfidence&& from) noexcept
    : TrafficSign_ShapeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ShapeAndConfidence& operator=(TrafficSign_ShapeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_ShapeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_ShapeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ShapeAndConfidence*>(
               &_TrafficSign_ShapeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void UnsafeArenaSwap(TrafficSign_ShapeAndConfidence* other);
  void Swap(TrafficSign_ShapeAndConfidence* other);
  friend void swap(TrafficSign_ShapeAndConfidence& a, TrafficSign_ShapeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_ShapeAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_ShapeAndConfidence>(NULL);
  }

  TrafficSign_ShapeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_ShapeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_ShapeAndConfidence& from);
  void MergeFrom(const TrafficSign_ShapeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_ShapeAndConfidence* other);
  protected:
  explicit TrafficSign_ShapeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_ShapeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_ShapeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type OTHER =
    TrafficSign_ShapeAndConfidence_Type_OTHER;
  static const Type RECTANGLE =
    TrafficSign_ShapeAndConfidence_Type_RECTANGLE;
  static const Type SQUARE =
    TrafficSign_ShapeAndConfidence_Type_SQUARE;
  static const Type TRIANGLE_UP =
    TrafficSign_ShapeAndConfidence_Type_TRIANGLE_UP;
  static const Type TRIANGLE_DOWN =
    TrafficSign_ShapeAndConfidence_Type_TRIANGLE_DOWN;
  static const Type DIAMOND =
    TrafficSign_ShapeAndConfidence_Type_DIAMOND;
  static const Type HEXAGON =
    TrafficSign_ShapeAndConfidence_Type_HEXAGON;
  static const Type ROUND =
    TrafficSign_ShapeAndConfidence_Type_ROUND;
  static const Type CROSS_BUCK =
    TrafficSign_ShapeAndConfidence_Type_CROSS_BUCK;
  static const Type OCTAGON =
    TrafficSign_ShapeAndConfidence_Type_OCTAGON;
  static const Type ELLIPSE =
    TrafficSign_ShapeAndConfidence_Type_ELLIPSE;
  static const Type PENTAGON =
    TrafficSign_ShapeAndConfidence_Type_PENTAGON;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_ShapeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_ShapeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_ShapeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_ShapeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_ShapeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_ShapeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_ShapeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence) */ {
 public:
  TrafficSign_TypeAndConfidence();
  virtual ~TrafficSign_TypeAndConfidence();

  TrafficSign_TypeAndConfidence(const TrafficSign_TypeAndConfidence& from);

  inline TrafficSign_TypeAndConfidence& operator=(const TrafficSign_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_TypeAndConfidence(TrafficSign_TypeAndConfidence&& from) noexcept
    : TrafficSign_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_TypeAndConfidence& operator=(TrafficSign_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_TypeAndConfidence*>(
               &_TrafficSign_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void UnsafeArenaSwap(TrafficSign_TypeAndConfidence* other);
  void Swap(TrafficSign_TypeAndConfidence* other);
  friend void swap(TrafficSign_TypeAndConfidence& a, TrafficSign_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_TypeAndConfidence>(NULL);
  }

  TrafficSign_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_TypeAndConfidence& from);
  void MergeFrom(const TrafficSign_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_TypeAndConfidence* other);
  protected:
  explicit TrafficSign_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type OTHER_AS_TEXT =
    TrafficSign_TypeAndConfidence_Type_OTHER_AS_TEXT;
  static const Type SPEED_LIMIT =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT;
  static const Type SPEED_LIMIT_END =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_END;
  static const Type SPEED_LIMIT_CHANGE_UPCOMING =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_CHANGE_UPCOMING;
  static const Type ADVISORY_SPEED_LIMIT =
    TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT;
  static const Type ADVISORY_SPEED_LIMIT_END =
    TrafficSign_TypeAndConfidence_Type_ADVISORY_SPEED_LIMIT_END;
  static const Type NO_OVERTAKING =
    TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING;
  static const Type NO_OVERTAKING_END =
    TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_END;
  static const Type PROTECTED_PASSING_START =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_START;
  static const Type PROTECTED_PASSING_END =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_END;
  static const Type PROTECTED_PASSING_LEFT_START =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_START;
  static const Type PROTECTED_PASSING_RIGHT_START =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_START;
  static const Type PROTECTED_PASSING_LEFT_END =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_LEFT_END;
  static const Type PROTECTED_PASSING_RIGHT_END =
    TrafficSign_TypeAndConfidence_Type_PROTECTED_PASSING_RIGHT_END;
  static const Type NO_OVERTAKING_TRUCK =
    TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK;
  static const Type NO_OVERTAKING_TRUCK_END =
    TrafficSign_TypeAndConfidence_Type_NO_OVERTAKING_TRUCK_END;
  static const Type ALL_RESTRICTIONS_END =
    TrafficSign_TypeAndConfidence_Type_ALL_RESTRICTIONS_END;
  static const Type CITY_START =
    TrafficSign_TypeAndConfidence_Type_CITY_START;
  static const Type CITY_END =
    TrafficSign_TypeAndConfidence_Type_CITY_END;
  static const Type HIGHWAY =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY;
  static const Type HIGHWAY_END =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_END;
  static const Type MOTORWAY =
    TrafficSign_TypeAndConfidence_Type_MOTORWAY;
  static const Type MOTORWAY_END =
    TrafficSign_TypeAndConfidence_Type_MOTORWAY_END;
  static const Type CONSTRUCTION =
    TrafficSign_TypeAndConfidence_Type_CONSTRUCTION;
  static const Type CONSTRUCTION_END =
    TrafficSign_TypeAndConfidence_Type_CONSTRUCTION_END;
  static const Type LANE_MERGE =
    TrafficSign_TypeAndConfidence_Type_LANE_MERGE;
  static const Type LANE_MERGE_ON_RIGHT =
    TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_RIGHT;
  static const Type LANE_MERGE_ON_LEFT =
    TrafficSign_TypeAndConfidence_Type_LANE_MERGE_ON_LEFT;
  static const Type LANE_MERGE_CENTER =
    TrafficSign_TypeAndConfidence_Type_LANE_MERGE_CENTER;
  static const Type RAILWAY_CROSSING_GENERAL =
    TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_GENERAL;
  static const Type RAILWAY_CROSSING_PROTECTED =
    TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_PROTECTED;
  static const Type RAILWAY_CROSSING_UNPROTECTED =
    TrafficSign_TypeAndConfidence_Type_RAILWAY_CROSSING_UNPROTECTED;
  static const Type ROAD_NARROWS =
    TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS;
  static const Type ROAD_NARROWS_LEFT =
    TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_LEFT;
  static const Type ROAD_NARROWS_RIGHT =
    TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_RIGHT;
  static const Type ROAD_NARROWS_CENTER =
    TrafficSign_TypeAndConfidence_Type_ROAD_NARROWS_CENTER;
  static const Type SHARP_CURVE =
    TrafficSign_TypeAndConfidence_Type_SHARP_CURVE;
  static const Type SHARP_CURVE_LEFT =
    TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_LEFT;
  static const Type SHARP_CURVE_RIGHT =
    TrafficSign_TypeAndConfidence_Type_SHARP_CURVE_RIGHT;
  static const Type WINDING_ROAD =
    TrafficSign_TypeAndConfidence_Type_WINDING_ROAD;
  static const Type WINDING_ROAD_STARTING_LEFT =
    TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_LEFT;
  static const Type WINDING_ROAD_STARTING_RIGHT =
    TrafficSign_TypeAndConfidence_Type_WINDING_ROAD_STARTING_RIGHT;
  static const Type STEEP_HILL =
    TrafficSign_TypeAndConfidence_Type_STEEP_HILL;
  static const Type STEEP_HILL_UPWARDS =
    TrafficSign_TypeAndConfidence_Type_STEEP_HILL_UPWARDS;
  static const Type STEEP_HILL_DOWNWARDS =
    TrafficSign_TypeAndConfidence_Type_STEEP_HILL_DOWNWARDS;
  static const Type STOP_SIGN =
    TrafficSign_TypeAndConfidence_Type_STOP_SIGN;
  static const Type LATERAL_WIND =
    TrafficSign_TypeAndConfidence_Type_LATERAL_WIND;
  static const Type LATERAL_WIND_FROM_RIGHT =
    TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_RIGHT;
  static const Type LATERAL_WIND_FROM_LEFT =
    TrafficSign_TypeAndConfidence_Type_LATERAL_WIND_FROM_LEFT;
  static const Type GENERAL_WARNING =
    TrafficSign_TypeAndConfidence_Type_GENERAL_WARNING;
  static const Type RISK_OF_GROUNDING =
    TrafficSign_TypeAndConfidence_Type_RISK_OF_GROUNDING;
  static const Type ANIMAL =
    TrafficSign_TypeAndConfidence_Type_ANIMAL;
  static const Type ICY_CONDITIONS =
    TrafficSign_TypeAndConfidence_Type_ICY_CONDITIONS;
  static const Type SLIPPERY_ROAD =
    TrafficSign_TypeAndConfidence_Type_SLIPPERY_ROAD;
  static const Type UNEVEN_ROAD =
    TrafficSign_TypeAndConfidence_Type_UNEVEN_ROAD;
  static const Type SCHOOL_ZONE =
    TrafficSign_TypeAndConfidence_Type_SCHOOL_ZONE;
  static const Type TRAMWAY_CROSSING =
    TrafficSign_TypeAndConfidence_Type_TRAMWAY_CROSSING;
  static const Type CONGESTION_HAZARD =
    TrafficSign_TypeAndConfidence_Type_CONGESTION_HAZARD;
  static const Type ACCIDENT_HAZARD =
    TrafficSign_TypeAndConfidence_Type_ACCIDENT_HAZARD;
  static const Type BICYCLE_CROSSING =
    TrafficSign_TypeAndConfidence_Type_BICYCLE_CROSSING;
  static const Type PRIORITY_OVER_ONCOMING_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_PRIORITY_OVER_ONCOMING_TRAFFIC;
  static const Type YIELD =
    TrafficSign_TypeAndConfidence_Type_YIELD;
  static const Type PRIORITY_ROAD =
    TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD;
  static const Type PRIORITY_ROAD_END =
    TrafficSign_TypeAndConfidence_Type_PRIORITY_ROAD_END;
  static const Type TRAFFIC_CALMING =
    TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING;
  static const Type TRAFFIC_CALMING_END =
    TrafficSign_TypeAndConfidence_Type_TRAFFIC_CALMING_END;
  static const Type ENVIRONMENTAL_AREA =
    TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA;
  static const Type ENVIRONMENTAL_AREA_END =
    TrafficSign_TypeAndConfidence_Type_ENVIRONMENTAL_AREA_END;
  static const Type INTERSECTION =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION;
  static const Type ROUNDABOUT =
    TrafficSign_TypeAndConfidence_Type_ROUNDABOUT;
  static const Type PASSING_ON_LEFT =
    TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT;
  static const Type PASSING_ON_RIGHT =
    TrafficSign_TypeAndConfidence_Type_PASSING_ON_RIGHT;
  static const Type PASSING_ON_LEFT_OR_RIGHT =
    TrafficSign_TypeAndConfidence_Type_PASSING_ON_LEFT_OR_RIGHT;
  static const Type MANDATORY_TURN_RIGHT_ONLY =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RIGHT_ONLY;
  static const Type MANDATORY_TURN_LEFT_ONLY =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_ONLY;
  static const Type MANDATORY_STRAIGHT_ONLY =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_ONLY;
  static const Type MANDATORY_TURN_LEFT_OR_RIGHT =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_LEFT_OR_RIGHT;
  static const Type MANDATORY_TURN_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_TURN_RESTRICTION;
  static const Type MANDATORY_STRAIGHT_OR_LEFT =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_LEFT;
  static const Type MANDATORY_STRAIGHT_OR_RIGHT =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_OR_RIGHT;
  static const Type NO_LEFT_TURN =
    TrafficSign_TypeAndConfidence_Type_NO_LEFT_TURN;
  static const Type NO_RIGHT_TURN =
    TrafficSign_TypeAndConfidence_Type_NO_RIGHT_TURN;
  static const Type NO_U_TURN =
    TrafficSign_TypeAndConfidence_Type_NO_U_TURN;
  static const Type NO_U_OR_LEFT_TURN =
    TrafficSign_TypeAndConfidence_Type_NO_U_OR_LEFT_TURN;
  static const Type U_TURN_ALLOWED =
    TrafficSign_TypeAndConfidence_Type_U_TURN_ALLOWED;
  static const Type MANDATORY_LEFT_TRUCK =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_TRUCK;
  static const Type MANDATORY_RIGHT_TRUCK =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_RIGHT_TRUCK;
  static const Type MANDATORY_STRAIGHT_TRUCK =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_STRAIGHT_TRUCK;
  static const Type NO_ENTRY =
    TrafficSign_TypeAndConfidence_Type_NO_ENTRY;
  static const Type DEAD_END =
    TrafficSign_TypeAndConfidence_Type_DEAD_END;
  static const Type HIGH_OCCUPANCY_VEHICLE_LANE =
    TrafficSign_TypeAndConfidence_Type_HIGH_OCCUPANCY_VEHICLE_LANE;
  static const Type TOLL =
    TrafficSign_TypeAndConfidence_Type_TOLL;
  static const Type TOLL_CAR =
    TrafficSign_TypeAndConfidence_Type_TOLL_CAR;
  static const Type TOLL_LANE =
    TrafficSign_TypeAndConfidence_Type_TOLL_LANE;
  static const Type EXPRESS_LANE =
    TrafficSign_TypeAndConfidence_Type_EXPRESS_LANE;
  static const Type SHOULDER_OPEN_FOR_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_SHOULDER_OPEN_FOR_TRAFFIC;
  static const Type SHOULDER_CLOSED_FOR_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_SHOULDER_CLOSED_FOR_TRAFFIC;
  static const Type LANE_CLOSED =
    TrafficSign_TypeAndConfidence_Type_LANE_CLOSED;
  static const Type LANE_CLOSED_RIGHT_MOST_LANE =
    TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_RIGHT_MOST_LANE;
  static const Type LANE_CLOSED_LEFT_MOST_LANE =
    TrafficSign_TypeAndConfidence_Type_LANE_CLOSED_LEFT_MOST_LANE;
  static const Type WARNING_PEDESTRIAN =
    TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN;
  static const Type WARNING_CHILDREN =
    TrafficSign_TypeAndConfidence_Type_WARNING_CHILDREN;
  static const Type WARNING_BICYCLE =
    TrafficSign_TypeAndConfidence_Type_WARNING_BICYCLE;
  static const Type WARNING_BUS =
    TrafficSign_TypeAndConfidence_Type_WARNING_BUS;
  static const Type PUBLIC_TRANSPORTATION_STOP =
    TrafficSign_TypeAndConfidence_Type_PUBLIC_TRANSPORTATION_STOP;
  static const Type PEDESTRIAN_CROSSING =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_CROSSING;
  static const Type WEIGHT_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_WEIGHT_RESTRICTION;
  static const Type HEIGHT_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_HEIGHT_RESTRICTION;
  static const Type LENGTH_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_LENGTH_RESTRICTION;
  static const Type WIDTH_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_WIDTH_RESTRICTION;
  static const Type WARNING_TRUCK_ROLLOVER =
    TrafficSign_TypeAndConfidence_Type_WARNING_TRUCK_ROLLOVER;
  static const Type SIGNAL_AHEAD =
    TrafficSign_TypeAndConfidence_Type_SIGNAL_AHEAD;
  static const Type SKI_CROSSING =
    TrafficSign_TypeAndConfidence_Type_SKI_CROSSING;
  static const Type NO_AGRICULTUR_VEHICLE =
    TrafficSign_TypeAndConfidence_Type_NO_AGRICULTUR_VEHICLE;
  static const Type NO_BICYCLE =
    TrafficSign_TypeAndConfidence_Type_NO_BICYCLE;
  static const Type NO_BUS =
    TrafficSign_TypeAndConfidence_Type_NO_BUS;
  static const Type NO_HAUL_EXPLOSIVES =
    TrafficSign_TypeAndConfidence_Type_NO_HAUL_EXPLOSIVES;
  static const Type NO_HAUL_HARMFUL_TO_WATER =
    TrafficSign_TypeAndConfidence_Type_NO_HAUL_HARMFUL_TO_WATER;
  static const Type NO_HAUL_HAZARDOUS_MATERIAL =
    TrafficSign_TypeAndConfidence_Type_NO_HAUL_HAZARDOUS_MATERIAL;
  static const Type NO_MOTORCYCLE =
    TrafficSign_TypeAndConfidence_Type_NO_MOTORCYCLE;
  static const Type NO_TRAILER =
    TrafficSign_TypeAndConfidence_Type_NO_TRAILER;
  static const Type NO_TRUCK_WITH_TRAILER =
    TrafficSign_TypeAndConfidence_Type_NO_TRUCK_WITH_TRAILER;
  static const Type PARK_AND_RIDE =
    TrafficSign_TypeAndConfidence_Type_PARK_AND_RIDE;
  static const Type ROAD_DISTANCE =
    TrafficSign_TypeAndConfidence_Type_ROAD_DISTANCE;
  static const Type EMERGENCY_PHONE =
    TrafficSign_TypeAndConfidence_Type_EMERGENCY_PHONE;
  static const Type SPEED_LIMIT_ENFORCEMENT =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ENFORCEMENT;
  static const Type TRAFFIC_LIGHT_ENFORCEMENT =
    TrafficSign_TypeAndConfidence_Type_TRAFFIC_LIGHT_ENFORCEMENT;
  static const Type BOARD_DIRECTION =
    TrafficSign_TypeAndConfidence_Type_BOARD_DIRECTION;
  static const Type STREET_NAME =
    TrafficSign_TypeAndConfidence_Type_STREET_NAME;
  static const Type TRUCK_SPEED_LIMIT =
    TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT;
  static const Type TRUCK_SPEED_LIMIT_END =
    TrafficSign_TypeAndConfidence_Type_TRUCK_SPEED_LIMIT_END;
  static const Type SPEED_LIMIT_NIGHT =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT;
  static const Type SPEED_LIMIT_NIGHT_END =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_NIGHT_END;
  static const Type MINIMUM_SPEED =
    TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED;
  static const Type MINIMUM_SPEED_END =
    TrafficSign_TypeAndConfidence_Type_MINIMUM_SPEED_END;
  static const Type PEDESTRIAN_ZONE =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE;
  static const Type PEDESTRIAN_ZONE_END =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_ZONE_END;
  static const Type PEDESTRIAN_PATH =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH;
  static const Type PEDESTRIAN_PATH_END =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_PATH_END;
  static const Type PEDESTRIAN_BICYCLE_PATH =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH;
  static const Type PEDESTRIAN_BICYCLE_PATH_END =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_PATH_END;
  static const Type BICYCLE_PATH =
    TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH;
  static const Type BICYCLE_PATH_END =
    TrafficSign_TypeAndConfidence_Type_BICYCLE_PATH_END;
  static const Type BICYCLE_STREET =
    TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET;
  static const Type BICYCLE_STREET_END =
    TrafficSign_TypeAndConfidence_Type_BICYCLE_STREET_END;
  static const Type CURVE_LEFT_THEN_RIGHT =
    TrafficSign_TypeAndConfidence_Type_CURVE_LEFT_THEN_RIGHT;
  static const Type CURVE_RIGHT_THEN_LEFT =
    TrafficSign_TypeAndConfidence_Type_CURVE_RIGHT_THEN_LEFT;
  static const Type CURVE_TRIPLE_HAIRPIN =
    TrafficSign_TypeAndConfidence_Type_CURVE_TRIPLE_HAIRPIN;
  static const Type STEEP_DROP =
    TrafficSign_TypeAndConfidence_Type_STEEP_DROP;
  static const Type STEEP_DROP_ON_LEFT =
    TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_LEFT;
  static const Type STEEP_DROP_ON_RIGHT =
    TrafficSign_TypeAndConfidence_Type_STEEP_DROP_ON_RIGHT;
  static const Type NO_ANIMAL_CATTLE =
    TrafficSign_TypeAndConfidence_Type_NO_ANIMAL_CATTLE;
  static const Type ANIMAL_DEER =
    TrafficSign_TypeAndConfidence_Type_ANIMAL_DEER;
  static const Type ANIMAL_MOOSE =
    TrafficSign_TypeAndConfidence_Type_ANIMAL_MOOSE;
  static const Type NO_HORSE_RIDING =
    TrafficSign_TypeAndConfidence_Type_NO_HORSE_RIDING;
  static const Type FALLING_ROCKS =
    TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS;
  static const Type FALLING_ROCKS_LEFT =
    TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_LEFT;
  static const Type FALLING_ROCKS_RIGHT =
    TrafficSign_TypeAndConfidence_Type_FALLING_ROCKS_RIGHT;
  static const Type YIELD_TO_ONCOMING_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_YIELD_TO_ONCOMING_TRAFFIC;
  static const Type UNPROTECTED_LEFT_TURN =
    TrafficSign_TypeAndConfidence_Type_UNPROTECTED_LEFT_TURN;
  static const Type ONEWAY_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC;
  static const Type ONEWAY_TRAFFIC_TO_LEFT =
    TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_LEFT;
  static const Type ONEWAY_TRAFFIC_TO_RIGHT =
    TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_RIGHT;
  static const Type ONEWAY_TRAFFIC_TO_STRAIGHT =
    TrafficSign_TypeAndConfidence_Type_ONEWAY_TRAFFIC_TO_STRAIGHT;
  static const Type NO_VEHICLE =
    TrafficSign_TypeAndConfidence_Type_NO_VEHICLE;
  static const Type NO_MOTOR_VEHICLE =
    TrafficSign_TypeAndConfidence_Type_NO_MOTOR_VEHICLE;
  static const Type NO_TRUCK =
    TrafficSign_TypeAndConfidence_Type_NO_TRUCK;
  static const Type NO_PEDESTRIAN =
    TrafficSign_TypeAndConfidence_Type_NO_PEDESTRIAN;
  static const Type LANE_USED_IN_BOTH_DIRECTIONS =
    TrafficSign_TypeAndConfidence_Type_LANE_USED_IN_BOTH_DIRECTIONS;
  static const Type FOG_AREA =
    TrafficSign_TypeAndConfidence_Type_FOG_AREA;
  static const Type TIRE_CHAINS_MANDATORY =
    TrafficSign_TypeAndConfidence_Type_TIRE_CHAINS_MANDATORY;
  static const Type HIJACKING_HOTSPOT =
    TrafficSign_TypeAndConfidence_Type_HIJACKING_HOTSPOT;
  static const Type OVERPASS_AHEAD =
    TrafficSign_TypeAndConfidence_Type_OVERPASS_AHEAD;
  static const Type TUNNEL =
    TrafficSign_TypeAndConfidence_Type_TUNNEL;
  static const Type FERRY_TERMINAL =
    TrafficSign_TypeAndConfidence_Type_FERRY_TERMINAL;
  static const Type NARROW_BRIDGE =
    TrafficSign_TypeAndConfidence_Type_NARROW_BRIDGE;
  static const Type NO_IDLING =
    TrafficSign_TypeAndConfidence_Type_NO_IDLING;
  static const Type HUMPBACK_BRIDGE =
    TrafficSign_TypeAndConfidence_Type_HUMPBACK_BRIDGE;
  static const Type EMBANKMENT =
    TrafficSign_TypeAndConfidence_Type_EMBANKMENT;
  static const Type EMBANKMENT_ON_THE_LEFT =
    TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_LEFT;
  static const Type EMBANKMENT_ON_THE_RIGHT =
    TrafficSign_TypeAndConfidence_Type_EMBANKMENT_ON_THE_RIGHT;
  static const Type CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD =
    TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_OVER_MINOR_ROAD;
  static const Type CROSSING_WITH_PRIORITY_TO_THE_RIGHT =
    TrafficSign_TypeAndConfidence_Type_CROSSING_WITH_PRIORITY_TO_THE_RIGHT;
  static const Type BRANCH_TO_THE_LEFT =
    TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_LEFT;
  static const Type BRANCH_TO_THE_RIGHT =
    TrafficSign_TypeAndConfidence_Type_BRANCH_TO_THE_RIGHT;
  static const Type TWO_WAY_TRAFFIC =
    TrafficSign_TypeAndConfidence_Type_TWO_WAY_TRAFFIC;
  static const Type BUMP =
    TrafficSign_TypeAndConfidence_Type_BUMP;
  static const Type DIP =
    TrafficSign_TypeAndConfidence_Type_DIP;
  static const Type ROAD_FLOODED =
    TrafficSign_TypeAndConfidence_Type_ROAD_FLOODED;
  static const Type AUDIBLE_WARNING =
    TrafficSign_TypeAndConfidence_Type_AUDIBLE_WARNING;
  static const Type VILLAGE_AHEAD =
    TrafficSign_TypeAndConfidence_Type_VILLAGE_AHEAD;
  static const Type MOVABLE_BRIDGE =
    TrafficSign_TypeAndConfidence_Type_MOVABLE_BRIDGE;
  static const Type SLOW_DOWN =
    TrafficSign_TypeAndConfidence_Type_SLOW_DOWN;
  static const Type INTERSECTION_T =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION_T;
  static const Type INTERSECTION_T_LEFT =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT;
  static const Type INTERSECTION_T_RIGHT =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_RIGHT;
  static const Type INTERSECTION_T_LEFT_RIGHT =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION_T_LEFT_RIGHT;
  static const Type INTERSECTION_Y =
    TrafficSign_TypeAndConfidence_Type_INTERSECTION_Y;
  static const Type USE_LOW_GEAR =
    TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR;
  static const Type USE_LOW_GEAR_END =
    TrafficSign_TypeAndConfidence_Type_USE_LOW_GEAR_END;
  static const Type NO_COMPRESSION_BRAKING =
    TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING;
  static const Type NO_COMPRESSION_BRAKING_END =
    TrafficSign_TypeAndConfidence_Type_NO_COMPRESSION_BRAKING_END;
  static const Type WAITING_LINE =
    TrafficSign_TypeAndConfidence_Type_WAITING_LINE;
  static const Type DONT_STOP_ZONE =
    TrafficSign_TypeAndConfidence_Type_DONT_STOP_ZONE;
  static const Type HONKING_PROHIBITED =
    TrafficSign_TypeAndConfidence_Type_HONKING_PROHIBITED;
  static const Type FASTEN_SEAT_BELT =
    TrafficSign_TypeAndConfidence_Type_FASTEN_SEAT_BELT;
  static const Type HAMLET_ENTRY =
    TrafficSign_TypeAndConfidence_Type_HAMLET_ENTRY;
  static const Type HAMLET_EXIT =
    TrafficSign_TypeAndConfidence_Type_HAMLET_EXIT;
  static const Type HIGHWAY_MARKER_1_STRIPE =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_1_STRIPE;
  static const Type HIGHWAY_MARKER_2_STRIPES =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_2_STRIPES;
  static const Type HIGHWAY_MARKER_3_STRIPES =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_MARKER_3_STRIPES;
  static const Type GUIDING_BEACON =
    TrafficSign_TypeAndConfidence_Type_GUIDING_BEACON;
  static const Type COUNTDOWN_MARKER_1_STRIPE =
    TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_1_STRIPE;
  static const Type COUNTDOWN_MARKER_2_STRIPES =
    TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_2_STRIPES;
  static const Type COUNTDOWN_MARKER_3_STRIPES =
    TrafficSign_TypeAndConfidence_Type_COUNTDOWN_MARKER_3_STRIPES;
  static const Type DIVERSION_ROUTE =
    TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE;
  static const Type DIVERSION_ROUTE_END =
    TrafficSign_TypeAndConfidence_Type_DIVERSION_ROUTE_END;
  static const Type NO_STOPPING_EXCEPT_TAXI =
    TrafficSign_TypeAndConfidence_Type_NO_STOPPING_EXCEPT_TAXI;
  static const Type NO_STOPPING =
    TrafficSign_TypeAndConfidence_Type_NO_STOPPING;
  static const Type NO_STOPPING_LEFT =
    TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT;
  static const Type NO_STOPPING_RIGHT =
    TrafficSign_TypeAndConfidence_Type_NO_STOPPING_RIGHT;
  static const Type NO_STOPPING_LEFT_AND_RIGHT =
    TrafficSign_TypeAndConfidence_Type_NO_STOPPING_LEFT_AND_RIGHT;
  static const Type NO_PARKING =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING;
  static const Type NO_PARKING_LEFT =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT;
  static const Type NO_PARKING_RIGHT =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING_RIGHT;
  static const Type NO_PARKING_LEFT_AND_RIGHT =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING_LEFT_AND_RIGHT;
  static const Type RUNNAWAY_TRUCK_RAMP =
    TrafficSign_TypeAndConfidence_Type_RUNNAWAY_TRUCK_RAMP;
  static const Type TURN_ON_GREEN =
    TrafficSign_TypeAndConfidence_Type_TURN_ON_GREEN;
  static const Type NO_TURN_ON_RED =
    TrafficSign_TypeAndConfidence_Type_NO_TURN_ON_RED;
  static const Type MOTORWAY_ROAD_NUMBER =
    TrafficSign_TypeAndConfidence_Type_MOTORWAY_ROAD_NUMBER;
  static const Type HIGHWAY_ROAD_NUMBER =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_ROAD_NUMBER;
  static const Type HIGHWAY_INTERCHANGE_NUMBER =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_INTERCHANGE_NUMBER;
  static const Type EUROPEAN_ROAD_NUMBER =
    TrafficSign_TypeAndConfidence_Type_EUROPEAN_ROAD_NUMBER;
  static const Type SPEED_LIMIT_ZONE =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE;
  static const Type SPEED_LIMIT_ZONE_END =
    TrafficSign_TypeAndConfidence_Type_SPEED_LIMIT_ZONE_END;
  static const Type NO_PARKING_ZONE =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE;
  static const Type NO_PARKING_ZONE_END =
    TrafficSign_TypeAndConfidence_Type_NO_PARKING_ZONE_END;
  static const Type PARKING_ZONE =
    TrafficSign_TypeAndConfidence_Type_PARKING_ZONE;
  static const Type PARKING_ZONE_END =
    TrafficSign_TypeAndConfidence_Type_PARKING_ZONE_END;
  static const Type PARKING =
    TrafficSign_TypeAndConfidence_Type_PARKING;
  static const Type PARKING_TO_LEFT =
    TrafficSign_TypeAndConfidence_Type_PARKING_TO_LEFT;
  static const Type PARKING_TO_RIGHT =
    TrafficSign_TypeAndConfidence_Type_PARKING_TO_RIGHT;
  static const Type PARKING_GARAGE =
    TrafficSign_TypeAndConfidence_Type_PARKING_GARAGE;
  static const Type PARKING_ON_SIDEWAY =
    TrafficSign_TypeAndConfidence_Type_PARKING_ON_SIDEWAY;
  static const Type SAFETY_DISTANCE =
    TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE;
  static const Type SAFETY_DISTANCE_VEHICLE =
    TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_VEHICLE;
  static const Type SAFETY_DISTANCE_TRUCK =
    TrafficSign_TypeAndConfidence_Type_SAFETY_DISTANCE_TRUCK;
  static const Type DETOUR =
    TrafficSign_TypeAndConfidence_Type_DETOUR;
  static const Type DETOUR_END =
    TrafficSign_TypeAndConfidence_Type_DETOUR_END;
  static const Type DETOUR_LEFT =
    TrafficSign_TypeAndConfidence_Type_DETOUR_LEFT;
  static const Type DETOUR_RIGHT =
    TrafficSign_TypeAndConfidence_Type_DETOUR_RIGHT;
  static const Type STATION_GAS =
    TrafficSign_TypeAndConfidence_Type_STATION_GAS;
  static const Type STATION_LPG =
    TrafficSign_TypeAndConfidence_Type_STATION_LPG;
  static const Type STATION_CNG =
    TrafficSign_TypeAndConfidence_Type_STATION_CNG;
  static const Type STATION_H2 =
    TrafficSign_TypeAndConfidence_Type_STATION_H2;
  static const Type STATION_ELECTRO =
    TrafficSign_TypeAndConfidence_Type_STATION_ELECTRO;
  static const Type STATION_POLICE =
    TrafficSign_TypeAndConfidence_Type_STATION_POLICE;
  static const Type CAMPING_SPOT =
    TrafficSign_TypeAndConfidence_Type_CAMPING_SPOT;
  static const Type RESTROOMS =
    TrafficSign_TypeAndConfidence_Type_RESTROOMS;
  static const Type INFO_POINT =
    TrafficSign_TypeAndConfidence_Type_INFO_POINT;
  static const Type MOTORWAY_EXIT_AHEAD =
    TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT_AHEAD;
  static const Type HIGHWAY_EXIT_AHEAD =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT_AHEAD;
  static const Type MOTORWAY_EXIT =
    TrafficSign_TypeAndConfidence_Type_MOTORWAY_EXIT;
  static const Type HIGHWAY_EXIT =
    TrafficSign_TypeAndConfidence_Type_HIGHWAY_EXIT;
  static const Type FIRST_AID =
    TrafficSign_TypeAndConfidence_Type_FIRST_AID;
  static const Type LOW_FLYING =
    TrafficSign_TypeAndConfidence_Type_LOW_FLYING;
  static const Type LANE_SHIFT =
    TrafficSign_TypeAndConfidence_Type_LANE_SHIFT;
  static const Type LANE_SHIFT_TO_LEFT =
    TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_LEFT;
  static const Type LANE_SHIFT_TO_RIGHT =
    TrafficSign_TypeAndConfidence_Type_LANE_SHIFT_TO_RIGHT;
  static const Type PEDESTRIAN_UNDERPASS =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_UNDERPASS;
  static const Type PEDESTRIAN_OVERPASS =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_OVERPASS;
  static const Type BREAKDOWN_BAY =
    TrafficSign_TypeAndConfidence_Type_BREAKDOWN_BAY;
  static const Type BUS_LANE =
    TrafficSign_TypeAndConfidence_Type_BUS_LANE;
  static const Type DOUBLE_HAIRPIN =
    TrafficSign_TypeAndConfidence_Type_DOUBLE_HAIRPIN;
  static const Type COUNTRY_SPECIFIC_INFORMATION =
    TrafficSign_TypeAndConfidence_Type_COUNTRY_SPECIFIC_INFORMATION;
  static const Type PEDESTRIAN_BICYCLE_SHARED_PATH =
    TrafficSign_TypeAndConfidence_Type_PEDESTRIAN_BICYCLE_SHARED_PATH;
  static const Type OVERHEAD_LANE_CONTROL_CLOSED =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSED;
  static const Type OVERHEAD_LANE_CONTROL_OPEN =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_OPEN;
  static const Type OVERHEAD_LANE_CONTROL_CLOSING_LEFT =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_LEFT;
  static const Type OVERHEAD_LANE_CONTROL_CLOSING_RIGHT =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_CLOSING_RIGHT;
  static const Type OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_LEFT;
  static const Type OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT =
    TrafficSign_TypeAndConfidence_Type_OVERHEAD_LANE_CONTROL_FLASH_ARROW_RIGHT;
  static const Type TRINATURE =
    TrafficSign_TypeAndConfidence_Type_TRINATURE;
  static const Type ANIMAL_FROG =
    TrafficSign_TypeAndConfidence_Type_ANIMAL_FROG;
  static const Type GRAVEL =
    TrafficSign_TypeAndConfidence_Type_GRAVEL;
  static const Type WARNING_PEDESTRIAN_CROSSING =
    TrafficSign_TypeAndConfidence_Type_WARNING_PEDESTRIAN_CROSSING;
  static const Type LOW_TREE =
    TrafficSign_TypeAndConfidence_Type_LOW_TREE;
  static const Type WARNING_RIDER =
    TrafficSign_TypeAndConfidence_Type_WARNING_RIDER;
  static const Type STOP_AHEAD =
    TrafficSign_TypeAndConfidence_Type_STOP_AHEAD;
  static const Type YIELD_AHEAD =
    TrafficSign_TypeAndConfidence_Type_YIELD_AHEAD;
  static const Type WATER_PROTECTION_AREA =
    TrafficSign_TypeAndConfidence_Type_WATER_PROTECTION_AREA;
  static const Type TOLL_DOUANE =
    TrafficSign_TypeAndConfidence_Type_TOLL_DOUANE;
  static const Type NO_CAR_OR_BIKE =
    TrafficSign_TypeAndConfidence_Type_NO_CAR_OR_BIKE;
  static const Type DRIVING_DIRECTION_ONLY_UP =
    TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_ONLY_UP;
  static const Type DRIVING_DIRECTION_UP_AND_DOWN =
    TrafficSign_TypeAndConfidence_Type_DRIVING_DIRECTION_UP_AND_DOWN;
  static const Type MILITARY_SIGN =
    TrafficSign_TypeAndConfidence_Type_MILITARY_SIGN;
  static const Type SMOG =
    TrafficSign_TypeAndConfidence_Type_SMOG;
  static const Type ROUNDABOUT_AHEAD =
    TrafficSign_TypeAndConfidence_Type_ROUNDABOUT_AHEAD;
  static const Type MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT =
    TrafficSign_TypeAndConfidence_Type_MANDATORY_LEFT_OR_STRAIGHT_OR_RIGHT;
  static const Type DEAD_END_RIGHT =
    TrafficSign_TypeAndConfidence_Type_DEAD_END_RIGHT;
  static const Type DEAD_END_LEFT =
    TrafficSign_TypeAndConfidence_Type_DEAD_END_LEFT;
  static const Type TOLL_TRUCK =
    TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK;
  static const Type TOLL_TRUCK_END =
    TrafficSign_TypeAndConfidence_Type_TOLL_TRUCK_END;
  static const Type STAGGERED_JUNCTION =
    TrafficSign_TypeAndConfidence_Type_STAGGERED_JUNCTION;
  static const Type AXLE_WEIGHT_RESTRICTION =
    TrafficSign_TypeAndConfidence_Type_AXLE_WEIGHT_RESTRICTION;
  static const Type TOLL_END =
    TrafficSign_TypeAndConfidence_Type_TOLL_END;
  static const Type TOLL_CAR_END =
    TrafficSign_TypeAndConfidence_Type_TOLL_CAR_END;
  static const Type TOLL_LANE_END =
    TrafficSign_TypeAndConfidence_Type_TOLL_LANE_END;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .google.protobuf.StringValue other_text = 3;
  bool has_other_text() const;
  void clear_other_text();
  static const int kOtherTextFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_other_text() const;
  public:
  const ::google::protobuf::StringValue& other_text() const;
  ::google::protobuf::StringValue* release_other_text();
  ::google::protobuf::StringValue* mutable_other_text();
  void set_allocated_other_text(::google::protobuf::StringValue* other_text);
  void unsafe_arena_set_allocated_other_text(
      ::google::protobuf::StringValue* other_text);
  ::google::protobuf::StringValue* unsafe_arena_release_other_text();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  ::google::protobuf::StringValue* other_text_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_ValueAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence) */ {
 public:
  TrafficSign_ValueAndConfidence();
  virtual ~TrafficSign_ValueAndConfidence();

  TrafficSign_ValueAndConfidence(const TrafficSign_ValueAndConfidence& from);

  inline TrafficSign_ValueAndConfidence& operator=(const TrafficSign_ValueAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_ValueAndConfidence(TrafficSign_ValueAndConfidence&& from) noexcept
    : TrafficSign_ValueAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ValueAndConfidence& operator=(TrafficSign_ValueAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_ValueAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_ValueAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ValueAndConfidence*>(
               &_TrafficSign_ValueAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void UnsafeArenaSwap(TrafficSign_ValueAndConfidence* other);
  void Swap(TrafficSign_ValueAndConfidence* other);
  friend void swap(TrafficSign_ValueAndConfidence& a, TrafficSign_ValueAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_ValueAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_ValueAndConfidence>(NULL);
  }

  TrafficSign_ValueAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_ValueAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_ValueAndConfidence& from);
  void MergeFrom(const TrafficSign_ValueAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_ValueAndConfidence* other);
  protected:
  explicit TrafficSign_ValueAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .google.protobuf.StringValue value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::google::protobuf::StringValue& _internal_value() const;
  public:
  const ::google::protobuf::StringValue& value() const;
  ::google::protobuf::StringValue* release_value();
  ::google::protobuf::StringValue* mutable_value();
  void set_allocated_value(::google::protobuf::StringValue* value);
  void unsafe_arena_set_allocated_value(
      ::google::protobuf::StringValue* value);
  ::google::protobuf::StringValue* unsafe_arena_release_value();

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::StringValue* value_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_PermanencyAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence) */ {
 public:
  TrafficSign_PermanencyAndConfidence();
  virtual ~TrafficSign_PermanencyAndConfidence();

  TrafficSign_PermanencyAndConfidence(const TrafficSign_PermanencyAndConfidence& from);

  inline TrafficSign_PermanencyAndConfidence& operator=(const TrafficSign_PermanencyAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_PermanencyAndConfidence(TrafficSign_PermanencyAndConfidence&& from) noexcept
    : TrafficSign_PermanencyAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_PermanencyAndConfidence& operator=(TrafficSign_PermanencyAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_PermanencyAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_PermanencyAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_PermanencyAndConfidence*>(
               &_TrafficSign_PermanencyAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void UnsafeArenaSwap(TrafficSign_PermanencyAndConfidence* other);
  void Swap(TrafficSign_PermanencyAndConfidence* other);
  friend void swap(TrafficSign_PermanencyAndConfidence& a, TrafficSign_PermanencyAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_PermanencyAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_PermanencyAndConfidence>(NULL);
  }

  TrafficSign_PermanencyAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_PermanencyAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_PermanencyAndConfidence& from);
  void MergeFrom(const TrafficSign_PermanencyAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_PermanencyAndConfidence* other);
  protected:
  explicit TrafficSign_PermanencyAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_PermanencyAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_PermanencyAndConfidence_Type_UNKNOWN_TYPE;
  static const Type STATIC =
    TrafficSign_PermanencyAndConfidence_Type_STATIC;
  static const Type VARIABLE =
    TrafficSign_PermanencyAndConfidence_Type_VARIABLE;
  static const Type VARIABLE_ELECTRONICALLY =
    TrafficSign_PermanencyAndConfidence_Type_VARIABLE_ELECTRONICALLY;
  static const Type VARIABLE_MECHANICALLY =
    TrafficSign_PermanencyAndConfidence_Type_VARIABLE_MECHANICALLY;
  static const Type VARIABLE_DEACTIVATED =
    TrafficSign_PermanencyAndConfidence_Type_VARIABLE_DEACTIVATED;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_PermanencyAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_PermanencyAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_PermanencyAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_PermanencyAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_PermanencyAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_PermanencyAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_PermanencyAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_ValidationAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence) */ {
 public:
  TrafficSign_ValidationAndConfidence();
  virtual ~TrafficSign_ValidationAndConfidence();

  TrafficSign_ValidationAndConfidence(const TrafficSign_ValidationAndConfidence& from);

  inline TrafficSign_ValidationAndConfidence& operator=(const TrafficSign_ValidationAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_ValidationAndConfidence(TrafficSign_ValidationAndConfidence&& from) noexcept
    : TrafficSign_ValidationAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_ValidationAndConfidence& operator=(TrafficSign_ValidationAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_ValidationAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_ValidationAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_ValidationAndConfidence*>(
               &_TrafficSign_ValidationAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void UnsafeArenaSwap(TrafficSign_ValidationAndConfidence* other);
  void Swap(TrafficSign_ValidationAndConfidence* other);
  friend void swap(TrafficSign_ValidationAndConfidence& a, TrafficSign_ValidationAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_ValidationAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_ValidationAndConfidence>(NULL);
  }

  TrafficSign_ValidationAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_ValidationAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_ValidationAndConfidence& from);
  void MergeFrom(const TrafficSign_ValidationAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_ValidationAndConfidence* other);
  protected:
  explicit TrafficSign_ValidationAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_ValidationAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_ValidationAndConfidence_Type_UNKNOWN_TYPE;
  static const Type VALID =
    TrafficSign_ValidationAndConfidence_Type_VALID;
  static const Type INVALID =
    TrafficSign_ValidationAndConfidence_Type_INVALID;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_ValidationAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_ValidationAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_ValidationAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_ValidationAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_ValidationAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_ValidationAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_ValidationAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_DominantBackgroundColorAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence) */ {
 public:
  TrafficSign_DominantBackgroundColorAndConfidence();
  virtual ~TrafficSign_DominantBackgroundColorAndConfidence();

  TrafficSign_DominantBackgroundColorAndConfidence(const TrafficSign_DominantBackgroundColorAndConfidence& from);

  inline TrafficSign_DominantBackgroundColorAndConfidence& operator=(const TrafficSign_DominantBackgroundColorAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_DominantBackgroundColorAndConfidence(TrafficSign_DominantBackgroundColorAndConfidence&& from) noexcept
    : TrafficSign_DominantBackgroundColorAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_DominantBackgroundColorAndConfidence& operator=(TrafficSign_DominantBackgroundColorAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_DominantBackgroundColorAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_DominantBackgroundColorAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_DominantBackgroundColorAndConfidence*>(
               &_TrafficSign_DominantBackgroundColorAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void UnsafeArenaSwap(TrafficSign_DominantBackgroundColorAndConfidence* other);
  void Swap(TrafficSign_DominantBackgroundColorAndConfidence* other);
  friend void swap(TrafficSign_DominantBackgroundColorAndConfidence& a, TrafficSign_DominantBackgroundColorAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_DominantBackgroundColorAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_DominantBackgroundColorAndConfidence>(NULL);
  }

  TrafficSign_DominantBackgroundColorAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_DominantBackgroundColorAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_DominantBackgroundColorAndConfidence& from);
  void MergeFrom(const TrafficSign_DominantBackgroundColorAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_DominantBackgroundColorAndConfidence* other);
  protected:
  explicit TrafficSign_DominantBackgroundColorAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_DominantBackgroundColorAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_UNKNOWN_TYPE;
  static const Type OTHER =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_OTHER;
  static const Type WHITE =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_WHITE;
  static const Type RED =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_RED;
  static const Type GREEN =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_GREEN;
  static const Type BLUE =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_BLUE;
  static const Type YELLOW =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_YELLOW;
  static const Type BLACK =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_BLACK;
  static const Type BROWN =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_BROWN;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_DominantBackgroundColorAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_DominantBackgroundColorAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence) */ {
 public:
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence();
  virtual ~TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence();

  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from);

  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& operator=(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence&& from) noexcept
    : TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& operator=(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(
               &_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void UnsafeArenaSwap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other);
  void Swap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other);
  friend void swap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& a, TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(NULL);
  }

  TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from);
  void MergeFrom(const TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* other);
  protected:
  explicit TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type Type;
  static const Type UNKNOWN_TYPE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_UNKNOWN_TYPE;
  static const Type SUP_OTHER_AS_TEXT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OTHER_AS_TEXT;
  static const Type SUP_WET =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WET;
  static const Type SUP_RAIN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAIN;
  static const Type SUP_SNOW =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW;
  static const Type SUP_SNOW_OR_RAIN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SNOW_OR_RAIN;
  static const Type SUP_FOG =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FOG;
  static const Type SUP_TIME =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TIME;
  static const Type SUP_DAY_AND_TIME =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DAY_AND_TIME;
  static const Type SUP_NIGHT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NIGHT;
  static const Type SUP_SEASON =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SEASON;
  static const Type SUP_WORKDAYS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS;
  static const Type SUP_WORKDAYS_AND_TIME =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WORKDAYS_AND_TIME;
  static const Type SUP_SCHOOL =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_SCHOOL;
  static const Type SUP_RAMP =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAMP;
  static const Type SUP_TRUCK =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK;
  static const Type SUP_TRUCK_WITH_TRAILER =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER;
  static const Type SUP_PASSENGER_CAR =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR;
  static const Type SUP_PASSENGER_CAR_WITH_TAILER =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER;
  static const Type SUP_TRACTOR_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_EXCEPT;
  static const Type SUP_BUS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS;
  static const Type SUP_TRUCKS_AND_BUS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCKS_AND_BUS;
  static const Type SUP_CARS_TRUCKS_BUS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARS_TRUCKS_BUS;
  static const Type SUP_TAXI =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TAXI;
  static const Type SUP_TANK =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TANK;
  static const Type SUP_ROADSIDE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE;
  static const Type SUP_WEIGHT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_WEIGHT;
  static const Type SUP_STARTING_IN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STARTING_IN;
  static const Type SUP_VALID_FOR =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_VALID_FOR;
  static const Type SUP_IN_RIGHT_DIRECTION =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_RIGHT_DIRECTION;
  static const Type SUP_IN_LEFT_DIRECTION =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_IN_LEFT_DIRECTION;
  static const Type SUP_ZONE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE;
  static const Type SUP_ZONE_START =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_START;
  static const Type SUP_ZONE_END =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ZONE_END;
  static const Type SUP_BEGIN_OF_VALIDITY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BEGIN_OF_VALIDITY;
  static const Type SUP_END_OF_VALIDITY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_END_OF_VALIDITY;
  static const Type SUP_FROG =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_FROG;
  static const Type SUP_ALL_WAY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ALL_WAY;
  static const Type SUP_BIKE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE;
  static const Type SUP_BIKE_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BIKE_EXCEPT;
  static const Type SUP_BUS_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_BUS_EXCEPT;
  static const Type SUP_CAMPER =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CAMPER;
  static const Type SUP_CARAVAN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CARAVAN;
  static const Type SUP_CONSTRUCTION_GATEWAY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CONSTRUCTION_GATEWAY;
  static const Type SUP_CROSS_WAY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_CROSS_WAY;
  static const Type SUP_DELIVERY_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_DELIVERY_EXCEPT;
  static const Type SUP_ELECTRONIC_CAR =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ELECTRONIC_CAR;
  static const Type SUP_GATEWAY =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GATEWAY;
  static const Type SUP_GIVE_WAY_LEFT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_LEFT;
  static const Type SUP_GIVE_WAY_RIGHT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GIVE_WAY_RIGHT;
  static const Type SUP_GRAVEL =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GRAVEL;
  static const Type SUP_HAZMAT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZMAT;
  static const Type SUP_HAZ_WATER =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_HAZ_WATER;
  static const Type SUP_KIDS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_KIDS;
  static const Type SUP_LOCAL_EXCEP =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOCAL_EXCEP;
  static const Type SUP_LOW_TREE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_LOW_TREE;
  static const Type SUP_MOTORCYCLE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE;
  static const Type SUP_MOTORCYCLE_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_MOTORCYCLE_EXCEPT;
  static const Type SUP_NEW_ROAD_BED =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NEW_ROAD_BED;
  static const Type SUP_NO_STOP_SHOULDER =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_NO_STOP_SHOULDER;
  static const Type SUP_OIL_TRAIL =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_OIL_TRAIL;
  static const Type SUP_PASSENGER_CAR_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_EXCEPT;
  static const Type SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PASSENGER_CAR_WITH_TAILER_EXCEPT;
  static const Type SUP_PEDESTRIAN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PEDESTRIAN;
  static const Type SUP_PRIORITY_TURN_LEFT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_LEFT;
  static const Type SUP_PRIORITY_TURN_RIGHT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_PRIORITY_TURN_RIGHT;
  static const Type SUP_ROAD_DAMAGE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROAD_DAMAGE;
  static const Type SUP_RUTS =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RUTS;
  static const Type SUP_TRACTOR =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR;
  static const Type SUP_TRACTOR_MAY_BE_OVERTAKEN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRACTOR_MAY_BE_OVERTAKEN;
  static const Type SUP_TRAFFIC_JAM =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAFFIC_JAM;
  static const Type SUP_TRAIN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAIN;
  static const Type SUP_TRAM =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRAM;
  static const Type SUP_TRUCK_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_EXCEPT;
  static const Type SUP_TRUCK_WITH_TRAILER_EXCEPT =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_TRUCK_WITH_TRAILER_EXCEPT;
  static const Type SUP_GET_IN_PROPER_LANE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_GET_IN_PROPER_LANE;
  static const Type SUP_ROADSIDE_TRUCK =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_ROADSIDE_TRUCK;
  static const Type SUP_RAPPEL =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RAPPEL;
  static const Type SUP_RADAR_ENFORCED =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_RADAR_ENFORCED;
  static const Type SUP_STOP_IN_DISTANCE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_SUP_STOP_IN_DISTANCE;
  static inline bool Type_IsValid(int value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MIN;
  static const Type Type_MAX =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_confidence();
  void set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence);
  void unsafe_arena_set_allocated_confidence(
      ::sensoris::protobuf::types::base::Confidence* confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_confidence();

  // .google.protobuf.StringValue other_text = 3;
  bool has_other_text() const;
  void clear_other_text();
  static const int kOtherTextFieldNumber = 3;
  private:
  const ::google::protobuf::StringValue& _internal_other_text() const;
  public:
  const ::google::protobuf::StringValue& other_text() const;
  ::google::protobuf::StringValue* release_other_text();
  ::google::protobuf::StringValue* mutable_other_text();
  void set_allocated_other_text(::google::protobuf::StringValue* other_text);
  void unsafe_arena_set_allocated_other_text(
      ::google::protobuf::StringValue* other_text);
  ::google::protobuf::StringValue* unsafe_arena_release_other_text();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type type() const;
  void set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value);

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* confidence_;
  ::google::protobuf::StringValue* other_text_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign_SupplementarySignAndConfidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence) */ {
 public:
  TrafficSign_SupplementarySignAndConfidence();
  virtual ~TrafficSign_SupplementarySignAndConfidence();

  TrafficSign_SupplementarySignAndConfidence(const TrafficSign_SupplementarySignAndConfidence& from);

  inline TrafficSign_SupplementarySignAndConfidence& operator=(const TrafficSign_SupplementarySignAndConfidence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign_SupplementarySignAndConfidence(TrafficSign_SupplementarySignAndConfidence&& from) noexcept
    : TrafficSign_SupplementarySignAndConfidence() {
    *this = ::std::move(from);
  }

  inline TrafficSign_SupplementarySignAndConfidence& operator=(TrafficSign_SupplementarySignAndConfidence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign_SupplementarySignAndConfidence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign_SupplementarySignAndConfidence* internal_default_instance() {
    return reinterpret_cast<const TrafficSign_SupplementarySignAndConfidence*>(
               &_TrafficSign_SupplementarySignAndConfidence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void UnsafeArenaSwap(TrafficSign_SupplementarySignAndConfidence* other);
  void Swap(TrafficSign_SupplementarySignAndConfidence* other);
  friend void swap(TrafficSign_SupplementarySignAndConfidence& a, TrafficSign_SupplementarySignAndConfidence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign_SupplementarySignAndConfidence* New() const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence>(NULL);
  }

  TrafficSign_SupplementarySignAndConfidence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign_SupplementarySignAndConfidence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign_SupplementarySignAndConfidence& from);
  void MergeFrom(const TrafficSign_SupplementarySignAndConfidence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign_SupplementarySignAndConfidence* other);
  protected:
  explicit TrafficSign_SupplementarySignAndConfidence(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence TypeAndConfidence;

  // accessors -------------------------------------------------------

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 1;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence);
  void unsafe_arena_set_allocated_existence_confidence(
      ::sensoris::protobuf::types::base::Confidence* existence_confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence type_and_confidence = 3;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 3;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 4;
  bool has_value_and_confidence() const;
  void clear_value_and_confidence();
  static const int kValueAndConfidenceFieldNumber = 4;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& _internal_value_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& value_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* release_value_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* mutable_value_and_confidence();
  void set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence);
  void unsafe_arena_set_allocated_value_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* unsafe_arena_release_value_and_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSign : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficSign) */ {
 public:
  TrafficSign();
  virtual ~TrafficSign();

  TrafficSign(const TrafficSign& from);

  inline TrafficSign& operator=(const TrafficSign& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSign(TrafficSign&& from) noexcept
    : TrafficSign() {
    *this = ::std::move(from);
  }

  inline TrafficSign& operator=(TrafficSign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSign* internal_default_instance() {
    return reinterpret_cast<const TrafficSign*>(
               &_TrafficSign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void UnsafeArenaSwap(TrafficSign* other);
  void Swap(TrafficSign* other);
  friend void swap(TrafficSign& a, TrafficSign& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSign* New() const final {
    return CreateMaybeMessage<TrafficSign>(NULL);
  }

  TrafficSign* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSign>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSign& from);
  void MergeFrom(const TrafficSign& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSign* other);
  protected:
  explicit TrafficSign(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSign_ShapeAndConfidence ShapeAndConfidence;
  typedef TrafficSign_TypeAndConfidence TypeAndConfidence;
  typedef TrafficSign_ValueAndConfidence ValueAndConfidence;
  typedef TrafficSign_PermanencyAndConfidence PermanencyAndConfidence;
  typedef TrafficSign_ValidationAndConfidence ValidationAndConfidence;
  typedef TrafficSign_DominantBackgroundColorAndConfidence DominantBackgroundColorAndConfidence;
  typedef TrafficSign_SupplementarySignAndConfidence SupplementarySignAndConfidence;

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence supplementary_sign_and_confidence = 11;
  int supplementary_sign_and_confidence_size() const;
  void clear_supplementary_sign_and_confidence();
  static const int kSupplementarySignAndConfidenceFieldNumber = 11;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* mutable_supplementary_sign_and_confidence(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >*
      mutable_supplementary_sign_and_confidence();
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence& supplementary_sign_and_confidence(int index) const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* add_supplementary_sign_and_confidence();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >&
      supplementary_sign_and_confidence() const;

  // .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::EventEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::EventEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::EventEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::EventEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::EventEnvelope* envelope);
  ::sensoris::protobuf::types::base::EventEnvelope* unsafe_arena_release_envelope();

  // .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
  bool has_existence_confidence() const;
  void clear_existence_confidence();
  static const int kExistenceConfidenceFieldNumber = 2;
  private:
  const ::sensoris::protobuf::types::base::Confidence& _internal_existence_confidence() const;
  public:
  const ::sensoris::protobuf::types::base::Confidence& existence_confidence() const;
  ::sensoris::protobuf::types::base::Confidence* release_existence_confidence();
  ::sensoris::protobuf::types::base::Confidence* mutable_existence_confidence();
  void set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence);
  void unsafe_arena_set_allocated_existence_confidence(
      ::sensoris::protobuf::types::base::Confidence* existence_confidence);
  ::sensoris::protobuf::types::base::Confidence* unsafe_arena_release_existence_confidence();

  // .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
  bool has_detection_status() const;
  void clear_detection_status();
  static const int kDetectionStatusFieldNumber = 3;
  private:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& _internal_detection_status() const;
  public:
  const ::sensoris::protobuf::types::base::EventDetectionStatus& detection_status() const;
  ::sensoris::protobuf::types::base::EventDetectionStatus* release_detection_status();
  ::sensoris::protobuf::types::base::EventDetectionStatus* mutable_detection_status();
  void set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  void unsafe_arena_set_allocated_detection_status(
      ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status);
  ::sensoris::protobuf::types::base::EventDetectionStatus* unsafe_arena_release_detection_status();

  // .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
  bool has_rectangular_box_and_accuracy() const;
  void clear_rectangular_box_and_accuracy();
  static const int kRectangularBoxAndAccuracyFieldNumber = 4;
  private:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& _internal_rectangular_box_and_accuracy() const;
  public:
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& rectangular_box_and_accuracy() const;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* release_rectangular_box_and_accuracy();
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* mutable_rectangular_box_and_accuracy();
  void set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy);
  void unsafe_arena_set_allocated_rectangular_box_and_accuracy(
      ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy);
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* unsafe_arena_release_rectangular_box_and_accuracy();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence shape_and_confidence = 5;
  bool has_shape_and_confidence() const;
  void clear_shape_and_confidence();
  static const int kShapeAndConfidenceFieldNumber = 5;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& _internal_shape_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& shape_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* release_shape_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* mutable_shape_and_confidence();
  void set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* shape_and_confidence);
  void unsafe_arena_set_allocated_shape_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* shape_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* unsafe_arena_release_shape_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence type_and_confidence = 6;
  bool has_type_and_confidence() const;
  void clear_type_and_confidence();
  static const int kTypeAndConfidenceFieldNumber = 6;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& _internal_type_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& type_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* release_type_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* mutable_type_and_confidence();
  void set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* type_and_confidence);
  void unsafe_arena_set_allocated_type_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* type_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* unsafe_arena_release_type_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 7;
  bool has_value_and_confidence() const;
  void clear_value_and_confidence();
  static const int kValueAndConfidenceFieldNumber = 7;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& _internal_value_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& value_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* release_value_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* mutable_value_and_confidence();
  void set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence);
  void unsafe_arena_set_allocated_value_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* unsafe_arena_release_value_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence permanency_and_confidence = 8;
  bool has_permanency_and_confidence() const;
  void clear_permanency_and_confidence();
  static const int kPermanencyAndConfidenceFieldNumber = 8;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& _internal_permanency_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& permanency_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* release_permanency_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* mutable_permanency_and_confidence();
  void set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* permanency_and_confidence);
  void unsafe_arena_set_allocated_permanency_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* permanency_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* unsafe_arena_release_permanency_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence validation_and_confidence = 9;
  bool has_validation_and_confidence() const;
  void clear_validation_and_confidence();
  static const int kValidationAndConfidenceFieldNumber = 9;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& _internal_validation_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& validation_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* release_validation_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* mutable_validation_and_confidence();
  void set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* validation_and_confidence);
  void unsafe_arena_set_allocated_validation_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* validation_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* unsafe_arena_release_validation_and_confidence();

  // .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence background_color_and_confidence = 10;
  bool has_background_color_and_confidence() const;
  void clear_background_color_and_confidence();
  static const int kBackgroundColorAndConfidenceFieldNumber = 10;
  private:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& _internal_background_color_and_confidence() const;
  public:
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& background_color_and_confidence() const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* release_background_color_and_confidence();
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* mutable_background_color_and_confidence();
  void set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* background_color_and_confidence);
  void unsafe_arena_set_allocated_background_color_and_confidence(
      ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* background_color_and_confidence);
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* unsafe_arena_release_background_color_and_confidence();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficSign)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence > supplementary_sign_and_confidence_;
  ::sensoris::protobuf::types::base::EventEnvelope* envelope_;
  ::sensoris::protobuf::types::base::Confidence* existence_confidence_;
  ::sensoris::protobuf::types::base::EventDetectionStatus* detection_status_;
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* shape_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* type_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* permanency_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* validation_and_confidence_;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* background_color_and_confidence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficRegulationCategory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory) */ {
 public:
  TrafficRegulationCategory();
  virtual ~TrafficRegulationCategory();

  TrafficRegulationCategory(const TrafficRegulationCategory& from);

  inline TrafficRegulationCategory& operator=(const TrafficRegulationCategory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficRegulationCategory(TrafficRegulationCategory&& from) noexcept
    : TrafficRegulationCategory() {
    *this = ::std::move(from);
  }

  inline TrafficRegulationCategory& operator=(TrafficRegulationCategory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline ::google::protobuf::Arena* GetArena() const final {
    return GetArenaNoVirtual();
  }
  inline void* GetMaybeArenaPointer() const final {
    return MaybeArenaPtr();
  }
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficRegulationCategory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficRegulationCategory* internal_default_instance() {
    return reinterpret_cast<const TrafficRegulationCategory*>(
               &_TrafficRegulationCategory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void UnsafeArenaSwap(TrafficRegulationCategory* other);
  void Swap(TrafficRegulationCategory* other);
  friend void swap(TrafficRegulationCategory& a, TrafficRegulationCategory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficRegulationCategory* New() const final {
    return CreateMaybeMessage<TrafficRegulationCategory>(NULL);
  }

  TrafficRegulationCategory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficRegulationCategory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficRegulationCategory& from);
  void MergeFrom(const TrafficRegulationCategory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficRegulationCategory* other);
  protected:
  explicit TrafficRegulationCategory(::google::protobuf::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::google::protobuf::Arena* arena);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign traffic_sign = 2;
  int traffic_sign_size() const;
  void clear_traffic_sign();
  static const int kTrafficSignFieldNumber = 2;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign* mutable_traffic_sign(int index);
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >*
      mutable_traffic_sign();
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign& traffic_sign(int index) const;
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign* add_traffic_sign();
  const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >&
      traffic_sign() const;

  // .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
  bool has_envelope() const;
  void clear_envelope();
  static const int kEnvelopeFieldNumber = 1;
  private:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& _internal_envelope() const;
  public:
  const ::sensoris::protobuf::types::base::CategoryEnvelope& envelope() const;
  ::sensoris::protobuf::types::base::CategoryEnvelope* release_envelope();
  ::sensoris::protobuf::types::base::CategoryEnvelope* mutable_envelope();
  void set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  void unsafe_arena_set_allocated_envelope(
      ::sensoris::protobuf::types::base::CategoryEnvelope* envelope);
  ::sensoris::protobuf::types::base::CategoryEnvelope* unsafe_arena_release_envelope();

  // @@protoc_insertion_point(class_scope:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign > traffic_sign_;
  ::sensoris::protobuf::types::base::CategoryEnvelope* envelope_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TrafficSign_ShapeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.Type type = 1;
inline void TrafficSign_ShapeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type TrafficSign_ShapeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type >(type_);
}
inline void TrafficSign_ShapeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ShapeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ShapeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ShapeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ShapeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_ShapeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_TypeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.Type type = 1;
inline void TrafficSign_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type TrafficSign_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type >(type_);
}
inline void TrafficSign_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.confidence)
}

// .google.protobuf.StringValue other_text = 3;
inline bool TrafficSign_TypeAndConfidence::has_other_text() const {
  return this != internal_default_instance() && other_text_ != NULL;
}
inline const ::google::protobuf::StringValue& TrafficSign_TypeAndConfidence::_internal_other_text() const {
  return *other_text_;
}
inline const ::google::protobuf::StringValue& TrafficSign_TypeAndConfidence::other_text() const {
  const ::google::protobuf::StringValue* p = other_text_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::release_other_text() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  
  ::google::protobuf::StringValue* temp = other_text_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  other_text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::unsafe_arena_release_other_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  
  ::google::protobuf::StringValue* temp = other_text_;
  other_text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_TypeAndConfidence::mutable_other_text() {
  
  if (other_text_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    other_text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
  return other_text_;
}
inline void TrafficSign_TypeAndConfidence::set_allocated_other_text(::google::protobuf::StringValue* other_text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(other_text_);
  }
  if (other_text) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(other_text)->GetArena();
    if (message_arena != submessage_arena) {
      other_text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, other_text, submessage_arena);
    }
    
  } else {
    
  }
  other_text_ = other_text;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence.other_text)
}

// -------------------------------------------------------------------

// TrafficSign_ValueAndConfidence

// .google.protobuf.StringValue value = 1;
inline bool TrafficSign_ValueAndConfidence::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::google::protobuf::StringValue& TrafficSign_ValueAndConfidence::_internal_value() const {
  return *value_;
}
inline const ::google::protobuf::StringValue& TrafficSign_ValueAndConfidence::value() const {
  const ::google::protobuf::StringValue* p = value_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::release_value() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  
  ::google::protobuf::StringValue* temp = value_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  
  ::google::protobuf::StringValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_ValueAndConfidence::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
  return value_;
}
inline void TrafficSign_ValueAndConfidence::set_allocated_value(::google::protobuf::StringValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.value)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ValueAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValueAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValueAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValueAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_ValueAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_PermanencyAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.Type type = 1;
inline void TrafficSign_PermanencyAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type TrafficSign_PermanencyAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type >(type_);
}
inline void TrafficSign_PermanencyAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_PermanencyAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_PermanencyAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_PermanencyAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_PermanencyAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_PermanencyAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_ValidationAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.Type type = 1;
inline void TrafficSign_ValidationAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type TrafficSign_ValidationAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type >(type_);
}
inline void TrafficSign_ValidationAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_ValidationAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValidationAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_ValidationAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_ValidationAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_ValidationAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_DominantBackgroundColorAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.Type type = 1;
inline void TrafficSign_DominantBackgroundColorAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type TrafficSign_DominantBackgroundColorAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type >(type_);
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_DominantBackgroundColorAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_DominantBackgroundColorAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_DominantBackgroundColorAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_DominantBackgroundColorAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_DominantBackgroundColorAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence.confidence)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.Type type = 1;
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::clear_type() {
  type_ = 0;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::type() const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.type)
  return static_cast< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type >(type_);
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_type(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.type)
}

// .sensoris.protobuf.types.base.Confidence confidence = 2;
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::has_confidence() const {
  return this != internal_default_instance() && confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_confidence() const {
  return *confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::release_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_release_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = confidence_;
  confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::mutable_confidence() {
  
  if (confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
  return confidence_;
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_allocated_confidence(::sensoris::protobuf::types::base::Confidence* confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(confidence_);
  }
  if (confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(confidence)->GetArena();
    if (message_arena != submessage_arena) {
      confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, confidence, submessage_arena);
    }
    
  } else {
    
  }
  confidence_ = confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.confidence)
}

// .google.protobuf.StringValue other_text = 3;
inline bool TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::has_other_text() const {
  return this != internal_default_instance() && other_text_ != NULL;
}
inline const ::google::protobuf::StringValue& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::_internal_other_text() const {
  return *other_text_;
}
inline const ::google::protobuf::StringValue& TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::other_text() const {
  const ::google::protobuf::StringValue* p = other_text_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  return p != NULL ? *p : *reinterpret_cast<const ::google::protobuf::StringValue*>(
      &::google::protobuf::_StringValue_default_instance_);
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::release_other_text() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  
  ::google::protobuf::StringValue* temp = other_text_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  other_text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::unsafe_arena_release_other_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  
  ::google::protobuf::StringValue* temp = other_text_;
  other_text_ = NULL;
  return temp;
}
inline ::google::protobuf::StringValue* TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::mutable_other_text() {
  
  if (other_text_ == NULL) {
    auto* p = CreateMaybeMessage<::google::protobuf::StringValue>(GetArenaNoVirtual());
    other_text_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
  return other_text_;
}
inline void TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence::set_allocated_other_text(::google::protobuf::StringValue* other_text) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(other_text_);
  }
  if (other_text) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(other_text)->GetArena();
    if (message_arena != submessage_arena) {
      other_text = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, other_text, submessage_arena);
    }
    
  } else {
    
  }
  other_text_ = other_text;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence.other_text)
}

// -------------------------------------------------------------------

// TrafficSign_SupplementarySignAndConfidence

// .sensoris.protobuf.types.base.Confidence existence_confidence = 1;
inline bool TrafficSign_SupplementarySignAndConfidence::has_existence_confidence() const {
  return this != internal_default_instance() && existence_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence::_internal_existence_confidence() const {
  return *existence_confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign_SupplementarySignAndConfidence::existence_confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = existence_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::release_existence_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_existence_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign_SupplementarySignAndConfidence::mutable_existence_confidence() {
  
  if (existence_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    existence_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
  return existence_confidence_;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(existence_confidence_);
  }
  if (existence_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(existence_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      existence_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, existence_confidence, submessage_arena);
    }
    
  } else {
    
  }
  existence_confidence_ = existence_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 2;
inline bool TrafficSign_SupplementarySignAndConfidence::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign_SupplementarySignAndConfidence::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign_SupplementarySignAndConfidence::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign_SupplementarySignAndConfidence::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
  return detection_status_;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.detection_status)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.TypeAndConfidence type_and_confidence = 3;
inline bool TrafficSign_SupplementarySignAndConfidence::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void TrafficSign_SupplementarySignAndConfidence::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& TrafficSign_SupplementarySignAndConfidence::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence& TrafficSign_SupplementarySignAndConfidence::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* TrafficSign_SupplementarySignAndConfidence::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
  return type_and_confidence_;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 4;
inline bool TrafficSign_SupplementarySignAndConfidence::has_value_and_confidence() const {
  return this != internal_default_instance() && value_and_confidence_ != NULL;
}
inline void TrafficSign_SupplementarySignAndConfidence::clear_value_and_confidence() {
  if (GetArenaNoVirtual() == NULL && value_and_confidence_ != NULL) {
    delete value_and_confidence_;
  }
  value_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign_SupplementarySignAndConfidence::_internal_value_and_confidence() const {
  return *value_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign_SupplementarySignAndConfidence::value_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* p = value_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValueAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::release_value_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = value_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::unsafe_arena_release_value_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = value_and_confidence_;
  value_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign_SupplementarySignAndConfidence::mutable_value_and_confidence() {
  
  if (value_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence>(GetArenaNoVirtual());
    value_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
  return value_and_confidence_;
}
inline void TrafficSign_SupplementarySignAndConfidence::set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_and_confidence_;
  }
  if (value_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(value_and_confidence);
    if (message_arena != submessage_arena) {
      value_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  value_and_confidence_ = value_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence.value_and_confidence)
}

// -------------------------------------------------------------------

// TrafficSign

// .sensoris.protobuf.types.base.EventEnvelope envelope = 1;
inline bool TrafficSign::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficSign::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::EventEnvelope& TrafficSign::envelope() const {
  const ::sensoris::protobuf::types::base::EventEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventEnvelope*>(
      &::sensoris::protobuf::types::base::_EventEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  
  ::sensoris::protobuf::types::base::EventEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventEnvelope* TrafficSign::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
  return envelope_;
}
inline void TrafficSign::set_allocated_envelope(::sensoris::protobuf::types::base::EventEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.envelope)
}

// .sensoris.protobuf.types.base.Confidence existence_confidence = 2;
inline bool TrafficSign::has_existence_confidence() const {
  return this != internal_default_instance() && existence_confidence_ != NULL;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign::_internal_existence_confidence() const {
  return *existence_confidence_;
}
inline const ::sensoris::protobuf::types::base::Confidence& TrafficSign::existence_confidence() const {
  const ::sensoris::protobuf::types::base::Confidence* p = existence_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::Confidence*>(
      &::sensoris::protobuf::types::base::_Confidence_default_instance_);
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::release_existence_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::unsafe_arena_release_existence_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  
  ::sensoris::protobuf::types::base::Confidence* temp = existence_confidence_;
  existence_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::Confidence* TrafficSign::mutable_existence_confidence() {
  
  if (existence_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::Confidence>(GetArenaNoVirtual());
    existence_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
  return existence_confidence_;
}
inline void TrafficSign::set_allocated_existence_confidence(::sensoris::protobuf::types::base::Confidence* existence_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(existence_confidence_);
  }
  if (existence_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(existence_confidence)->GetArena();
    if (message_arena != submessage_arena) {
      existence_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, existence_confidence, submessage_arena);
    }
    
  } else {
    
  }
  existence_confidence_ = existence_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.existence_confidence)
}

// .sensoris.protobuf.types.base.EventDetectionStatus detection_status = 3;
inline bool TrafficSign::has_detection_status() const {
  return this != internal_default_instance() && detection_status_ != NULL;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign::_internal_detection_status() const {
  return *detection_status_;
}
inline const ::sensoris::protobuf::types::base::EventDetectionStatus& TrafficSign::detection_status() const {
  const ::sensoris::protobuf::types::base::EventDetectionStatus* p = detection_status_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::EventDetectionStatus*>(
      &::sensoris::protobuf::types::base::_EventDetectionStatus_default_instance_);
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::release_detection_status() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::unsafe_arena_release_detection_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  
  ::sensoris::protobuf::types::base::EventDetectionStatus* temp = detection_status_;
  detection_status_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::EventDetectionStatus* TrafficSign::mutable_detection_status() {
  
  if (detection_status_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::EventDetectionStatus>(GetArenaNoVirtual());
    detection_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
  return detection_status_;
}
inline void TrafficSign::set_allocated_detection_status(::sensoris::protobuf::types::base::EventDetectionStatus* detection_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(detection_status_);
  }
  if (detection_status) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(detection_status)->GetArena();
    if (message_arena != submessage_arena) {
      detection_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, detection_status, submessage_arena);
    }
    
  } else {
    
  }
  detection_status_ = detection_status;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.detection_status)
}

// .sensoris.protobuf.types.spatial.RectangularBoxAndAccuracy rectangular_box_and_accuracy = 4;
inline bool TrafficSign::has_rectangular_box_and_accuracy() const {
  return this != internal_default_instance() && rectangular_box_and_accuracy_ != NULL;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& TrafficSign::_internal_rectangular_box_and_accuracy() const {
  return *rectangular_box_and_accuracy_;
}
inline const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy& TrafficSign::rectangular_box_and_accuracy() const {
  const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* p = rectangular_box_and_accuracy_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy*>(
      &::sensoris::protobuf::types::spatial::_RectangularBoxAndAccuracy_default_instance_);
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::release_rectangular_box_and_accuracy() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = rectangular_box_and_accuracy_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  rectangular_box_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::unsafe_arena_release_rectangular_box_and_accuracy() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  
  ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* temp = rectangular_box_and_accuracy_;
  rectangular_box_and_accuracy_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* TrafficSign::mutable_rectangular_box_and_accuracy() {
  
  if (rectangular_box_and_accuracy_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy>(GetArenaNoVirtual());
    rectangular_box_and_accuracy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
  return rectangular_box_and_accuracy_;
}
inline void TrafficSign::set_allocated_rectangular_box_and_accuracy(::sensoris::protobuf::types::spatial::RectangularBoxAndAccuracy* rectangular_box_and_accuracy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(rectangular_box_and_accuracy_);
  }
  if (rectangular_box_and_accuracy) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(rectangular_box_and_accuracy)->GetArena();
    if (message_arena != submessage_arena) {
      rectangular_box_and_accuracy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rectangular_box_and_accuracy, submessage_arena);
    }
    
  } else {
    
  }
  rectangular_box_and_accuracy_ = rectangular_box_and_accuracy;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.rectangular_box_and_accuracy)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ShapeAndConfidence shape_and_confidence = 5;
inline bool TrafficSign::has_shape_and_confidence() const {
  return this != internal_default_instance() && shape_and_confidence_ != NULL;
}
inline void TrafficSign::clear_shape_and_confidence() {
  if (GetArenaNoVirtual() == NULL && shape_and_confidence_ != NULL) {
    delete shape_and_confidence_;
  }
  shape_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& TrafficSign::_internal_shape_and_confidence() const {
  return *shape_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence& TrafficSign::shape_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* p = shape_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ShapeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::release_shape_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* temp = shape_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  shape_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::unsafe_arena_release_shape_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* temp = shape_and_confidence_;
  shape_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* TrafficSign::mutable_shape_and_confidence() {
  
  if (shape_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence>(GetArenaNoVirtual());
    shape_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
  return shape_and_confidence_;
}
inline void TrafficSign::set_allocated_shape_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence* shape_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete shape_and_confidence_;
  }
  if (shape_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(shape_and_confidence);
    if (message_arena != submessage_arena) {
      shape_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, shape_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  shape_and_confidence_ = shape_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.shape_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.TypeAndConfidence type_and_confidence = 6;
inline bool TrafficSign::has_type_and_confidence() const {
  return this != internal_default_instance() && type_and_confidence_ != NULL;
}
inline void TrafficSign::clear_type_and_confidence() {
  if (GetArenaNoVirtual() == NULL && type_and_confidence_ != NULL) {
    delete type_and_confidence_;
  }
  type_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& TrafficSign::_internal_type_and_confidence() const {
  return *type_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence& TrafficSign::type_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* p = type_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_TypeAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::release_type_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* temp = type_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::unsafe_arena_release_type_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* temp = type_and_confidence_;
  type_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* TrafficSign::mutable_type_and_confidence() {
  
  if (type_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence>(GetArenaNoVirtual());
    type_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
  return type_and_confidence_;
}
inline void TrafficSign::set_allocated_type_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence* type_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_and_confidence_;
  }
  if (type_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(type_and_confidence);
    if (message_arena != submessage_arena) {
      type_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  type_and_confidence_ = type_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.type_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValueAndConfidence value_and_confidence = 7;
inline bool TrafficSign::has_value_and_confidence() const {
  return this != internal_default_instance() && value_and_confidence_ != NULL;
}
inline void TrafficSign::clear_value_and_confidence() {
  if (GetArenaNoVirtual() == NULL && value_and_confidence_ != NULL) {
    delete value_and_confidence_;
  }
  value_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign::_internal_value_and_confidence() const {
  return *value_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence& TrafficSign::value_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* p = value_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValueAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::release_value_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = value_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  value_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::unsafe_arena_release_value_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* temp = value_and_confidence_;
  value_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* TrafficSign::mutable_value_and_confidence() {
  
  if (value_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence>(GetArenaNoVirtual());
    value_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
  return value_and_confidence_;
}
inline void TrafficSign::set_allocated_value_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValueAndConfidence* value_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_and_confidence_;
  }
  if (value_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(value_and_confidence);
    if (message_arena != submessage_arena) {
      value_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  value_and_confidence_ = value_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.value_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.PermanencyAndConfidence permanency_and_confidence = 8;
inline bool TrafficSign::has_permanency_and_confidence() const {
  return this != internal_default_instance() && permanency_and_confidence_ != NULL;
}
inline void TrafficSign::clear_permanency_and_confidence() {
  if (GetArenaNoVirtual() == NULL && permanency_and_confidence_ != NULL) {
    delete permanency_and_confidence_;
  }
  permanency_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& TrafficSign::_internal_permanency_and_confidence() const {
  return *permanency_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence& TrafficSign::permanency_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* p = permanency_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_PermanencyAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::release_permanency_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* temp = permanency_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  permanency_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::unsafe_arena_release_permanency_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* temp = permanency_and_confidence_;
  permanency_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* TrafficSign::mutable_permanency_and_confidence() {
  
  if (permanency_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence>(GetArenaNoVirtual());
    permanency_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
  return permanency_and_confidence_;
}
inline void TrafficSign::set_allocated_permanency_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence* permanency_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete permanency_and_confidence_;
  }
  if (permanency_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(permanency_and_confidence);
    if (message_arena != submessage_arena) {
      permanency_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, permanency_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  permanency_and_confidence_ = permanency_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.permanency_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.ValidationAndConfidence validation_and_confidence = 9;
inline bool TrafficSign::has_validation_and_confidence() const {
  return this != internal_default_instance() && validation_and_confidence_ != NULL;
}
inline void TrafficSign::clear_validation_and_confidence() {
  if (GetArenaNoVirtual() == NULL && validation_and_confidence_ != NULL) {
    delete validation_and_confidence_;
  }
  validation_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& TrafficSign::_internal_validation_and_confidence() const {
  return *validation_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence& TrafficSign::validation_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* p = validation_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_ValidationAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::release_validation_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* temp = validation_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  validation_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::unsafe_arena_release_validation_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* temp = validation_and_confidence_;
  validation_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* TrafficSign::mutable_validation_and_confidence() {
  
  if (validation_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence>(GetArenaNoVirtual());
    validation_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
  return validation_and_confidence_;
}
inline void TrafficSign::set_allocated_validation_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence* validation_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete validation_and_confidence_;
  }
  if (validation_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(validation_and_confidence);
    if (message_arena != submessage_arena) {
      validation_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, validation_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  validation_and_confidence_ = validation_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.validation_and_confidence)
}

// .sensoris.protobuf.categories.trafficregulation.TrafficSign.DominantBackgroundColorAndConfidence background_color_and_confidence = 10;
inline bool TrafficSign::has_background_color_and_confidence() const {
  return this != internal_default_instance() && background_color_and_confidence_ != NULL;
}
inline void TrafficSign::clear_background_color_and_confidence() {
  if (GetArenaNoVirtual() == NULL && background_color_and_confidence_ != NULL) {
    delete background_color_and_confidence_;
  }
  background_color_and_confidence_ = NULL;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& TrafficSign::_internal_background_color_and_confidence() const {
  return *background_color_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence& TrafficSign::background_color_and_confidence() const {
  const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* p = background_color_and_confidence_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence*>(
      &::sensoris::protobuf::categories::trafficregulation::_TrafficSign_DominantBackgroundColorAndConfidence_default_instance_);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::release_background_color_and_confidence() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* temp = background_color_and_confidence_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  background_color_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::unsafe_arena_release_background_color_and_confidence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  
  ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* temp = background_color_and_confidence_;
  background_color_and_confidence_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* TrafficSign::mutable_background_color_and_confidence() {
  
  if (background_color_and_confidence_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence>(GetArenaNoVirtual());
    background_color_and_confidence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
  return background_color_and_confidence_;
}
inline void TrafficSign::set_allocated_background_color_and_confidence(::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence* background_color_and_confidence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete background_color_and_confidence_;
  }
  if (background_color_and_confidence) {
    ::google::protobuf::Arena* submessage_arena =
      ::google::protobuf::Arena::GetArena(background_color_and_confidence);
    if (message_arena != submessage_arena) {
      background_color_and_confidence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, background_color_and_confidence, submessage_arena);
    }
    
  } else {
    
  }
  background_color_and_confidence_ = background_color_and_confidence;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficSign.background_color_and_confidence)
}

// repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign.SupplementarySignAndConfidence supplementary_sign_and_confidence = 11;
inline int TrafficSign::supplementary_sign_and_confidence_size() const {
  return supplementary_sign_and_confidence_.size();
}
inline void TrafficSign::clear_supplementary_sign_and_confidence() {
  supplementary_sign_and_confidence_.Clear();
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* TrafficSign::mutable_supplementary_sign_and_confidence(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return supplementary_sign_and_confidence_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >*
TrafficSign::mutable_supplementary_sign_and_confidence() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return &supplementary_sign_and_confidence_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence& TrafficSign::supplementary_sign_and_confidence(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return supplementary_sign_and_confidence_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence* TrafficSign::add_supplementary_sign_and_confidence() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return supplementary_sign_and_confidence_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence >&
TrafficSign::supplementary_sign_and_confidence() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficregulation.TrafficSign.supplementary_sign_and_confidence)
  return supplementary_sign_and_confidence_;
}

// -------------------------------------------------------------------

// TrafficRegulationCategory

// .sensoris.protobuf.types.base.CategoryEnvelope envelope = 1;
inline bool TrafficRegulationCategory::has_envelope() const {
  return this != internal_default_instance() && envelope_ != NULL;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficRegulationCategory::_internal_envelope() const {
  return *envelope_;
}
inline const ::sensoris::protobuf::types::base::CategoryEnvelope& TrafficRegulationCategory::envelope() const {
  const ::sensoris::protobuf::types::base::CategoryEnvelope* p = envelope_;
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  return p != NULL ? *p : *reinterpret_cast<const ::sensoris::protobuf::types::base::CategoryEnvelope*>(
      &::sensoris::protobuf::types::base::_CategoryEnvelope_default_instance_);
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::release_envelope() {
  // @@protoc_insertion_point(field_release:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  if (GetArenaNoVirtual() != NULL) {
    temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
  }
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::unsafe_arena_release_envelope() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  
  ::sensoris::protobuf::types::base::CategoryEnvelope* temp = envelope_;
  envelope_ = NULL;
  return temp;
}
inline ::sensoris::protobuf::types::base::CategoryEnvelope* TrafficRegulationCategory::mutable_envelope() {
  
  if (envelope_ == NULL) {
    auto* p = CreateMaybeMessage<::sensoris::protobuf::types::base::CategoryEnvelope>(GetArenaNoVirtual());
    envelope_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
  return envelope_;
}
inline void TrafficRegulationCategory::set_allocated_envelope(::sensoris::protobuf::types::base::CategoryEnvelope* envelope) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(envelope_);
  }
  if (envelope) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(envelope)->GetArena();
    if (message_arena != submessage_arena) {
      envelope = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, envelope, submessage_arena);
    }
    
  } else {
    
  }
  envelope_ = envelope;
  // @@protoc_insertion_point(field_set_allocated:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.envelope)
}

// repeated .sensoris.protobuf.categories.trafficregulation.TrafficSign traffic_sign = 2;
inline int TrafficRegulationCategory::traffic_sign_size() const {
  return traffic_sign_.size();
}
inline void TrafficRegulationCategory::clear_traffic_sign() {
  traffic_sign_.Clear();
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign* TrafficRegulationCategory::mutable_traffic_sign(int index) {
  // @@protoc_insertion_point(field_mutable:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return traffic_sign_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >*
TrafficRegulationCategory::mutable_traffic_sign() {
  // @@protoc_insertion_point(field_mutable_list:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return &traffic_sign_;
}
inline const ::sensoris::protobuf::categories::trafficregulation::TrafficSign& TrafficRegulationCategory::traffic_sign(int index) const {
  // @@protoc_insertion_point(field_get:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return traffic_sign_.Get(index);
}
inline ::sensoris::protobuf::categories::trafficregulation::TrafficSign* TrafficRegulationCategory::add_traffic_sign() {
  // @@protoc_insertion_point(field_add:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return traffic_sign_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sensoris::protobuf::categories::trafficregulation::TrafficSign >&
TrafficRegulationCategory::traffic_sign() const {
  // @@protoc_insertion_point(field_list:sensoris.protobuf.categories.trafficregulation.TrafficRegulationCategory.traffic_sign)
  return traffic_sign_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trafficregulation
}  // namespace categories
}  // namespace protobuf
}  // namespace sensoris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ShapeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_TypeAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_PermanencyAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_ValidationAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_DominantBackgroundColorAndConfidence_Type_descriptor();
}
template <> struct is_proto_enum< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type>() {
  return ::sensoris::protobuf::categories::trafficregulation::TrafficSign_SupplementarySignAndConfidence_TypeAndConfidence_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sensoris_2fprotobuf_2fcategories_2ftraffic_5fregulation_2eproto
